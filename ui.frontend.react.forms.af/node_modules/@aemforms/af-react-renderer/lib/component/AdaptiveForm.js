"use strict";
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const FormContext_1 = __importDefault(require("./FormContext"));
const af_core_1 = require("@aemforms/af-core");
const react_intl_1 = require("react-intl");
// quarry intl is not working with react-intl formatMessage
const i18n_1 = require("./i18n");
// @ts-ignore
const package_json_1 = __importDefault(require("../../package.json"));
const i18n_json_1 = __importDefault(require("../i18n.json"));
const hooks_1 = require("../hooks");
const AdaptiveForm = function (props) {
    var _a;
    const { formJson, mappings, locale, localizationMessages, onInitialize, focusOn, loggerType = 'error' } = props;
    const [state, setState] = (0, react_1.useState)(null);
    //  this gets updated to new value on every rerender.
    //  using JSON.stringify to convert object to string and storing it in usePrevious
    const prevFormJsonStr = (0, hooks_1.usePrevious)((0, af_core_1.jsonString)(formJson));
    const [refMap] = (0, react_1.useState)({});
    if (localizationMessages) {
        // not using useMemo hook because createForm call is already optimized
        // any expensive react operation should generally be inside useMemo
        // todo: the input to defineMessages react-intl API could come from a restful end point
        (0, react_intl_1.defineMessages)((0, i18n_1.getTranslationMessages)(formJson));
    }
    let localeDictJson = localizationMessages;
    let localizationMessagesProp;
    if (typeof localizationMessages === 'string') {
        try {
            // if messages are in incorrect format, just log an error
            localeDictJson = JSON.parse(localizationMessages);
        }
        catch (ex) {
            console.log('Translation messages are in incorrect format');
            localeDictJson = localizationMessages;
        }
    }
    let afLocalization = Object.assign({}, i18n_json_1.default);
    if (locale) {
        localizationMessagesProp = localeDictJson === null || localeDictJson === void 0 ? void 0 : localeDictJson[locale];
        if (localizationMessagesProp) {
            afLocalization = (afLocalization === null || afLocalization === void 0 ? void 0 : afLocalization[locale]) || {};
            localizationMessagesProp = Object.assign(Object.assign({}, localizationMessagesProp), afLocalization);
        }
    }
    try {
        const x = require('@quarry/eim-provider');
        try {
            x.useAdoption({ name: '@aemforms/adaptive-form', version: package_json_1.default.version });
        }
        catch (e) {
            console.warn('unable to report adoption metrics');
        }
    }
    catch (e) {
        console.warn('unable to report adoption metrics');
    }
    // this logs event only if used inside unified shell
    // name aligns to the string used in quarry external docs
    (0, react_1.useEffect)(() => {
        // @ts-ignore
        let prevFormJson = prevFormJsonStr ? JSON.parse(prevFormJsonStr) : undefined;
        const isOnlyDataAdded = (0, af_core_1.checkIfKeyAdded)(formJson, prevFormJson, 'data');
        // useEffect gets called even if there is no change in formJson, hence adding an explicit check here
        // @ts-ignore
        const shouldNewModelBeCreated = ((isOnlyDataAdded && (0, af_core_1.jsonString)(formJson === null || formJson === void 0 ? void 0 : formJson.data) !== (0, af_core_1.jsonString)(prevFormJson === null || prevFormJson === void 0 ? void 0 : prevFormJson.data)) || !isOnlyDataAdded);
        // @ts-ignore
        try {
            const form = shouldNewModelBeCreated ? (0, af_core_1.createFormInstance)(formJson, () => { }, loggerType, isOnlyDataAdded ? state === null || state === void 0 ? void 0 : state.model : null) : state === null || state === void 0 ? void 0 : state.model;
            if (typeof onInitialize === 'function') {
                onInitialize({
                    type: 'initialize',
                    // @ts-ignore
                    target: form,
                    payload: undefined,
                    metadata: undefined,
                    isCustomEvent: false
                });
            }
            if (!isOnlyDataAdded) {
                // initialize all the event handlers
                Object.keys(props)
                    .map((propKey) => {
                    if (propKey.startsWith('on') && propKey !== 'onInitialize' && typeof props[propKey] === 'function') {
                        // get the event name from the function
                        let eventName = propKey.substring(propKey.indexOf('on') + 2);
                        eventName = eventName.charAt(0).toLowerCase() + eventName.slice(1);
                        // subscribe to the event
                        // @ts-ignore
                        form.subscribe((action) => {
                            props[propKey](action);
                        }, eventName);
                    }
                });
                // @ts-ignore
                const localState = { model: form, id: form.getUniqueId() };
                // @ts-ignore
                setState(localState);
            }
        }
        catch (e) {
            console.error('unable to create Form. Please validate the json');
        }
    }, [formJson]);
    if (focusOn && refMap[focusOn]) {
        refMap[focusOn].setFocus();
    }
    const formState = (_a = state === null || state === void 0 ? void 0 : state.model) === null || _a === void 0 ? void 0 : _a.getState();
    const Comp = mappings.form;
    return (state && formState ?
        // @ts-ignore
        (react_1.default.createElement(FormContext_1.default.Provider, { value: { mappings, form: state.model, modelId: state.id, refMap: refMap } },
            react_1.default.createElement(react_intl_1.IntlProvider, { onError: () => { }, locale: locale, messages: localizationMessagesProp }, Comp ? react_1.default.createElement(Comp, Object.assign({ key: formState.id + '__' + state.id }, formState)) : null))) : null);
};
exports.default = AdaptiveForm;
