"use strict";
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePrevious = exports.useFocus = exports.useRuleEngine = void 0;
const FormContext_1 = __importDefault(require("../component/FormContext"));
const react_1 = require("react");
//@ts-ignore
const af_core_1 = require("@aemforms/af-core");
const af_core_2 = require("@aemforms/af-core");
const af_formatters_1 = require("@aemforms/af-formatters");
/**
 * Binds the component's state to the Form and dynamically changing it depending upon
 * the rules written for that Field in the Form
 * @param props
 * @param supportFormats
 */
const useRuleEngine = function (props, supportFormats = false) {
    var _a;
    const context = (0, react_1.useContext)(FormContext_1.default);
    const id = props.id;
    const element = (_a = context.form) === null || _a === void 0 ? void 0 : _a.getElement(id);
    // use the state, if an empty controller (like objects outside of form vocab), fallback to props
    const [elementState, setElementState] = (0, react_1.useState)((element === null || element === void 0 ? void 0 : element.getState()) || props);
    const [isInFocus, setInFocus] = (0, react_1.useState)(false);
    (0, react_1.useEffect)(() => {
        const subscription = element === null || element === void 0 ? void 0 : element.subscribe((e) => {
            const state = e.target.getState();
            setElementState(state);
        });
        return () => {
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
        };
    }, [id]);
    (0, react_1.useEffect)(() => {
        const items = (element === null || element === void 0 ? void 0 : element.items) || [];
        const subscriptions = items === null || items === void 0 ? void 0 : items.map(item => {
            var _a;
            const childElement = (_a = context.form) === null || _a === void 0 ? void 0 : _a.getElement(item.id);
            return childElement === null || childElement === void 0 ? void 0 : childElement.subscribe((e) => {
                var _a;
                const changes = ((_a = e === null || e === void 0 ? void 0 : e.payload) === null || _a === void 0 ? void 0 : _a.changes) || [];
                let isChanged = changes.filter(({ propertyName }) => propertyName === 'enabled' || propertyName === 'visible').length;
                if (isChanged) {
                    setElementState(element === null || element === void 0 ? void 0 : element.getState());
                }
            });
        });
        return () => {
            subscriptions.forEach(subscription => {
                subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
            });
        };
    }, [id]);
    const pad2Digits = (num) => num < 10 ? `0${num}` : `${num}`;
    const pad4Digits = (num) => num > 999 ? `${num}` : ['0', '00', '000'][4 - `${num}`.length] + num;
    const dispatchChange = (val) => {
        if (!(element === null || element === void 0 ? void 0 : element.isContainer)) {
            console.log('changed ' + val);
            //@ts-ignore
            //supporting editFormat only for dates now
            if (supportFormats && val != null && element.editFormat && element.format === 'date') {
                //@ts-ignore
                const parsedVal = (0, af_formatters_1.parse)(val.toString(), element.language, element.editFormat, null, false);
                console.log('parsed ' + parsedVal);
                if (parsedVal instanceof Date) {
                    element.value = pad4Digits(parsedVal.getFullYear()) + '-' +
                        pad2Digits(parsedVal.getMonth() + 1) + '-' +
                        pad2Digits(parsedVal.getDate());
                }
                else {
                    element.value = parsedVal;
                }
                console.log('model ' + element.value);
            }
            else {
                element.value = val;
            }
        }
    };
    const dispatchBlur = () => {
        if (!(element === null || element === void 0 ? void 0 : element.isContainer)) {
            console.log('Blur');
            const blurAction = new af_core_2.Blur(null);
            setInFocus(false);
            element === null || element === void 0 ? void 0 : element.dispatch(blurAction);
        }
    };
    const dispatchClick = () => {
        const clickAction = new af_core_1.Click(null);
        element === null || element === void 0 ? void 0 : element.dispatch(clickAction);
    };
    const dispatchFocus = () => {
        setInFocus(true);
        element === null || element === void 0 ? void 0 : element.dispatch(new af_core_1.Focus());
    };
    const dispatchAddItem = (n) => {
        const action = new af_core_1.AddItem(n);
        element === null || element === void 0 ? void 0 : element.dispatch(action);
    };
    const dispatchRemoveItem = (n) => {
        const action = new af_core_1.RemoveItem(n);
        element === null || element === void 0 ? void 0 : element.dispatch(action);
    };
    //@ts-ignore
    return [Object.assign(Object.assign({}, elementState), { isInFocus }), { dispatchChange, dispatchClick, dispatchAddItem, dispatchRemoveItem, dispatchBlur, dispatchFocus }];
};
exports.useRuleEngine = useRuleEngine;
// @ts-ignore
const useFocus = function (props) {
    const context = (0, react_1.useContext)(FormContext_1.default);
    const id = props.id;
    const ref = (0, react_1.useRef)(null);
    const setRef = (0, react_1.useCallback)(node => {
        if (ref.current) {
            // Make sure to cleanup any events/references added to the last instance
        }
        if (node) {
            // Check if a node is actually passed. Otherwise node would be null.
            // You can now do what you need to, addEventListeners, measure, etc.
        }
        // Save a reference to the node
        ref.current = node;
    }, []);
    const setFocus = function () {
        // @ts-ignore
        ref.current && ref.current.focus();
    };
    if (context === null || context === void 0 ? void 0 : context.refMap) {
        context.refMap[id] = { 'setFocus': setFocus };
    }
    return [setRef, setFocus];
};
exports.useFocus = useFocus;
/**
 * React hook to get the previous state
 * @param value
 */
const usePrevious = function (value) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    const ref = (0, react_1.useRef)();
    // Store current value in ref
    (0, react_1.useEffect)(() => {
        ref.current = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)
    return ref.current;
};
exports.usePrevious = usePrevious;
