/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

'use strict';

class ActionImpl {
    _metadata;
    _type;
    _payload;
    _target;
    constructor(payload, type, _metadata) {
        this._metadata = _metadata;
        this._payload = payload;
        this._type = type;
    }
    get type() {
        return this._type;
    }
    get payload() {
        return this._payload;
    }
    get metadata() {
        return this._metadata;
    }
    get target() {
        return this._target;
    }
    get isCustomEvent() {
        return false;
    }
    payloadToJson() {
        return this.payload;
    }
    toJson() {
        return {
            payload: this.payloadToJson(),
            type: this.type,
            isCustomEvent: this.isCustomEvent
        };
    }
    toString() {
        return JSON.stringify(this.toJson());
    }
}
class Change extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'change', { dispatch });
    }
    withAdditionalChange(change) {
        return new Change(this.payload.changes.concat(change.payload.changes), this.metadata);
    }
}
class Invalid extends ActionImpl {
    constructor(payload = {}) {
        super(payload, 'invalid', {});
    }
}
class Valid extends ActionImpl {
    constructor(payload = {}) {
        super(payload, 'valid', {});
    }
}
class ExecuteRule extends ActionImpl {
    constructor(payload = {}, dispatch = false) {
        super(payload, 'executeRule', { dispatch });
    }
}
const propertyChange = (propertyName, currentValue, prevValue) => {
    return new Change({
        changes: [
            {
                propertyName,
                currentValue,
                prevValue
            }
        ]
    });
};
class Initialize extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'initialize', { dispatch });
    }
}
class FormLoad extends ActionImpl {
    constructor() {
        super({}, 'load', { dispatch: false });
    }
}
class Click extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'click', { dispatch });
    }
}
class Blur extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'blur', { dispatch });
    }
}
class ValidationComplete extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'validationComplete', { dispatch });
    }
}
class Focus extends ActionImpl {
    constructor() {
        super({}, 'focus', { dispatch: false });
    }
}
class Submit extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'submit', { dispatch });
    }
}
class Reset extends ActionImpl {
    constructor(payload, dispatch = false) {
        super(payload, 'reset', { dispatch });
    }
}
class FieldChanged extends ActionImpl {
    constructor(changes, field) {
        super({
            field,
            changes
        }, 'fieldChanged');
    }
}
class CustomEvent extends ActionImpl {
    constructor(eventName, payload = {}, dispatch = false) {
        super(payload, eventName, { dispatch });
    }
    get isCustomEvent() {
        return true;
    }
}
class AddItem extends ActionImpl {
    constructor(payload) {
        super(payload, 'addItem');
    }
}
class RemoveItem extends ActionImpl {
    constructor(payload) {
        super(payload, 'removeItem');
    }
}
class AddInstance extends ActionImpl {
    constructor(payload) {
        super(payload, 'addInstance');
    }
}
class RemoveInstance extends ActionImpl {
    constructor(payload) {
        super(payload, 'removeInstance');
    }
}

class DataValue {
    $_name;
    $_value;
    $_type;
    $_fields = [];
    constructor($_name, $_value, $_type = typeof $_value) {
        this.$_name = $_name;
        this.$_value = $_value;
        this.$_type = $_type;
    }
    valueOf() {
        return this.$_value;
    }
    get $name() {
        return this.$_name;
    }
    get $value() {
        const enabled = this.$_fields.find(x => x.enabled !== false);
        if (!enabled && this.$_fields.length) {
            return undefined;
        }
        return this.$_value;
    }
    setValue(typedValue, originalValue, fromField) {
        this.$_value = typedValue;
        this.$_fields.forEach(x => {
            if (fromField !== x) {
                x.value = originalValue;
            }
        });
    }
    get $type() {
        return this.$_type;
    }
    $bindToField(field) {
        if (this.$_fields.indexOf(field) === -1) {
            this.$_fields.push(field);
        }
    }
    $convertToDataValue() {
        return this;
    }
    get $isDataGroup() {
        return false;
    }
}

const value = Symbol('NullValue');
class NullDataValueClass extends DataValue {
    constructor() {
        super('', value, 'null');
    }
    setValue() {
    }
    $bindToField() {
    }
    $length() {
        return 0;
    }
    $convertToDataValue() {
        return this;
    }
    $addDataNode() {
    }
    $removeDataNode() {
    }
    $getDataNode() {
        return this;
    }
    $containsDataNode() {
        return false;
    }
}
const NullDataValue = new NullDataValueClass();

class DataGroup extends DataValue {
    $_items;
    createEntry(key, value) {
        const t = value instanceof Array ? 'array' : typeof value;
        if (typeof value === 'object' && value != null) {
            return new DataGroup(key, value, t);
        }
        else {
            return new DataValue(key, value, t);
        }
    }
    constructor(_name, _value, _type = typeof _value) {
        super(_name, _value, _type);
        if (_value instanceof Array) {
            this.$_items = _value.map((value, index) => {
                return this.createEntry(index, value);
            });
        }
        else {
            this.$_items = Object.fromEntries(Object.entries(_value).map(([key, value]) => {
                return [key, this.createEntry(key, value)];
            }));
        }
    }
    get $value() {
        const enabled = this.$_fields.find(x => x.enabled !== false);
        if (!enabled && this.$_fields.length) {
            return this.$type === 'array' ? [] : {};
        }
        else if (this.$type === 'array') {
            return Object.values(this.$_items).filter(x => typeof x !== 'undefined').map(x => x.$value);
        }
        else {
            return Object.fromEntries(Object.values(this.$_items).filter(x => typeof x !== 'undefined').map(x => {
                return [x.$name, x.$value];
            }));
        }
    }
    get $length() {
        return Object.entries(this.$_items).length;
    }
    $convertToDataValue() {
        return new DataValue(this.$name, this.$value, this.$type);
    }
    $addDataNode(name, value, override = false) {
        if (value !== NullDataValue) {
            if (this.$type === 'array') {
                const index = name;
                if (!override) {
                    this.$_items.splice(index, 0, value);
                }
                else {
                    this.$_items[name] = value;
                }
            }
            else {
                this.$_items[name] = value;
            }
        }
    }
    $removeDataNode(name) {
        this.$_items[name] = undefined;
    }
    $getDataNode(name) {
        if (this.$_items.hasOwnProperty(name)) {
            return this.$_items[name];
        }
    }
    $containsDataNode(name) {
        return this.$_items.hasOwnProperty(name) && typeof (this.$_items[name]) !== 'undefined';
    }
    get $isDataGroup() {
        return true;
    }
}

const TOK_DOT$2 = 'DOT';
const TOK_IDENTIFIER = 'Identifier';
const TOK_GLOBAL$3 = 'Global';
const TOK_BRACKET = 'bracket';
const TOK_NUMBER$2 = 'Number';
const globalStartToken$1 = '$';
const identifier = (value, start) => {
    return {
        type: TOK_IDENTIFIER,
        value,
        start
    };
};
const bracket = (value, start) => {
    return {
        type: TOK_BRACKET,
        value,
        start
    };
};
const global$ = () => {
    return {
        type: TOK_GLOBAL$3,
        start: 0,
        value: globalStartToken$1
    };
};
const isAlphaNum$1 = function (ch) {
    return (ch >= 'a' && ch <= 'z')
        || (ch >= 'A' && ch <= 'Z')
        || (ch >= '0' && ch <= '9')
        || ch === '_';
};
const isGlobal = (prev, stream, pos) => {
    return prev === null && stream[pos] === globalStartToken$1;
};
const isIdentifier$1 = (stream, pos) => {
    const ch = stream[pos];
    if (ch === '$') {
        return stream.length > pos && isAlphaNum$1(stream[pos + 1]);
    }
    return (ch >= 'a' && ch <= 'z')
        || (ch >= 'A' && ch <= 'Z')
        || ch === '_';
};
const isNum$1 = (ch) => {
    return (ch >= '0' && ch <= '9');
};
class Tokenizer {
    stream;
    _current;
    _tokens = [];
    _result_tokens = [];
    constructor(stream) {
        this.stream = stream;
        this._current = 0;
    }
    _consumeGlobal() {
        this._current += 1;
        return global$();
    }
    _consumeUnquotedIdentifier(stream) {
        const start = this._current;
        this._current += 1;
        while (this._current < stream.length && isAlphaNum$1(stream[this._current])) {
            this._current += 1;
        }
        return identifier(stream.slice(start, this._current), start);
    }
    _consumeQuotedIdentifier(stream) {
        const start = this._current;
        this._current += 1;
        const maxLength = stream.length;
        while (stream[this._current] !== '"' && this._current < maxLength) {
            let current = this._current;
            if (stream[current] === '\\' && (stream[current + 1] === '\\'
                || stream[current + 1] === '"')) {
                current += 2;
            }
            else {
                current += 1;
            }
            this._current = current;
        }
        this._current += 1;
        return identifier(JSON.parse(stream.slice(start, this._current)), start);
    }
    _consumeNumber(stream) {
        const start = this._current;
        this._current += 1;
        const maxLength = stream.length;
        while (isNum$1(stream[this._current]) && this._current < maxLength) {
            this._current += 1;
        }
        const n = stream.slice(start, this._current);
        const value = parseInt(n, 10);
        return { type: TOK_NUMBER$2, value, start };
    }
    _consumeBracket(stream) {
        const start = this._current;
        this._current += 1;
        let value;
        if (isNum$1(stream[this._current])) {
            value = this._consumeNumber(stream).value;
        }
        else {
            throw new Error(`unexpected exception at position ${this._current}. Must be a character`);
        }
        if (this._current < this.stream.length && stream[this._current] !== ']') {
            throw new Error(`unexpected exception at position ${this._current}. Must be a character`);
        }
        this._current++;
        return bracket(value, start);
    }
    tokenize() {
        const stream = this.stream;
        while (this._current < stream.length) {
            const prev = this._tokens.length ? this._tokens.slice(-1)[0] : null;
            if (isGlobal(prev, stream, this._current)) {
                const token = this._consumeGlobal();
                this._tokens.push(token);
                this._result_tokens.push(token);
            }
            else if (isIdentifier$1(stream, this._current)) {
                const token = this._consumeUnquotedIdentifier(stream);
                this._tokens.push(token);
                this._result_tokens.push(token);
            }
            else if (stream[this._current] === '.' && prev != null && prev.type !== TOK_DOT$2) {
                this._tokens.push({
                    type: TOK_DOT$2,
                    value: '.',
                    start: this._current
                });
                this._current += 1;
            }
            else if (stream[this._current] === '[') {
                const token = this._consumeBracket(stream);
                this._tokens.push(token);
                this._result_tokens.push(token);
            }
            else if (stream[this._current] === '"') {
                const token = this._consumeQuotedIdentifier(stream);
                this._tokens.push(token);
                this._result_tokens.push(token);
            }
            else {
                const p = Math.max(0, this._current - 2);
                const s = Math.min(this.stream.length, this._current + 2);
                throw new Error(`Exception at parsing stream ${this.stream.slice(p, s)}`);
            }
        }
        return this._result_tokens;
    }
}
const tokenize = (stream) => {
    return new Tokenizer(stream).tokenize();
};
const resolveData = (data, input, create) => {
    let tokens;
    if (typeof input === 'string') {
        tokens = tokenize(input);
    }
    else {
        tokens = input;
    }
    let result = data;
    let i = 0;
    const createIntermediateNode = (token, nextToken, create) => {
        return nextToken === null ? create :
            (nextToken.type === TOK_BRACKET) ? new DataGroup(token.value, [], 'array') :
                new DataGroup(token.value, {});
    };
    while (i < tokens.length && result != null) {
        const token = tokens[i];
        if (token.type === TOK_GLOBAL$3) {
            result = data;
        }
        else if (token.type === TOK_IDENTIFIER) {
            if (result instanceof DataGroup && result.$type === 'object') {
                if (result.$containsDataNode(token.value) && result.$getDataNode(token.value).$value !== null) {
                    result = result.$getDataNode(token.value);
                }
                else if (create) {
                    const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                    const toCreate = createIntermediateNode(token, nextToken, create);
                    result.$addDataNode(token.value, toCreate);
                    result = toCreate;
                }
                else {
                    result = undefined;
                }
            }
            else {
                throw new Error(`Looking for ${token.value} in ${result.$value}`);
            }
        }
        else if (token.type === TOK_BRACKET) {
            if (result instanceof DataGroup && result.$type === 'array') {
                const index = token.value;
                if (index < result.$length) {
                    result = result.$getDataNode(index);
                }
                else if (create) {
                    const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                    const toCreate = createIntermediateNode(token, nextToken, create);
                    result.$addDataNode(index, toCreate);
                    result = toCreate;
                }
                else {
                    result = undefined;
                }
            }
            else {
                throw new Error(`Looking for index ${token.value} in non array${result.$value}`);
            }
        }
        i += 1;
    }
    return result;
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
const editableProperties = [
    'value',
    'label',
    'description',
    'visible',
    'enabled',
    'readOnly',
    'enum',
    'enumNames',
    'required',
    'properties',
    'exclusiveMinimum',
    'exclusiveMaximum',
    'maximum',
    'maxItems',
    'minimum',
    'minItems'
];
const dynamicProps = [
    ...editableProperties,
    'valid',
    'index',
    'activeChild'
];
const staticFields = ['plain-text', 'image'];
class ActionImplWithTarget {
    _action;
    _target;
    constructor(_action, _target) {
        this._action = _action;
        this._target = _target;
    }
    get type() {
        return this._action.type;
    }
    get payload() {
        return this._action.payload;
    }
    get metadata() {
        return this._action.metadata;
    }
    get target() {
        return this._target;
    }
    get isCustomEvent() {
        return this._action.isCustomEvent;
    }
    get originalAction() {
        return this._action.originalAction;
    }
    toString() {
        return this._action.toString();
    }
}
const target = Symbol('target');
const qualifiedName = Symbol('qualifiedName');
function dependencyTracked() {
    return function (target, propertyKey, descriptor) {
        const get = descriptor.get;
        if (get != undefined) {
            descriptor.get = function () {
                this.ruleEngine.trackDependency(this);
                return get.call(this);
            };
        }
    };
}
const addOnly = (includeOrExclude) => (...fieldTypes) => (target, propertyKey, descriptor) => {
    const get = descriptor.get;
    if (get != undefined) {
        descriptor.get = function () {
            if (fieldTypes.indexOf(this.fieldType) > -1 === includeOrExclude) {
                return get.call(this);
            }
            return undefined;
        };
    }
    const set = descriptor.set;
    if (set != undefined) {
        descriptor.set = function (value) {
            if (fieldTypes.indexOf(this.fieldType) > -1 === includeOrExclude) {
                set.call(this, value);
            }
        };
    }
};
const include = addOnly(true);
const exclude = addOnly(false);
class BaseNode {
    _options;
    _ruleNode;
    _lang = '';
    _callbacks = {};
    _dependents = [];
    _jsonModel;
    _tokens = [];
    get isContainer() {
        return false;
    }
    constructor(params, _options) {
        this._options = _options;
        this[qualifiedName] = null;
        this._jsonModel = {
            ...params,
            id: 'id' in params ? params.id : this.form.getUniqueId()
        };
    }
    setupRuleNode() {
        const self = this;
        this._ruleNode = new Proxy(this.ruleNodeReference(), {
            get: (ruleNodeReference, prop) => {
                return self.getFromRule(ruleNodeReference, prop);
            }
        });
    }
    ruleNodeReference() {
        return this;
    }
    getRuleNode() {
        return this._ruleNode;
    }
    getFromRule(ruleNodeReference, prop) {
        if (prop === Symbol.toPrimitive || (prop === 'valueOf' && !ruleNodeReference.hasOwnProperty('valueOf'))) {
            return this.valueOf;
        }
        else if (prop === target) {
            return this;
        }
        else if (typeof (prop) === 'string') {
            if (prop.startsWith('$')) {
                prop = prop.substr(1);
                if (typeof this[prop] !== 'function') {
                    const retValue = this[prop];
                    if (retValue instanceof BaseNode) {
                        return retValue.getRuleNode();
                    }
                    else if (retValue instanceof Array) {
                        return retValue.map(r => r instanceof BaseNode ? r.getRuleNode() : r);
                    }
                    else {
                        return retValue;
                    }
                }
            }
            else {
                if (ruleNodeReference.hasOwnProperty(prop)) {
                    return ruleNodeReference[prop];
                }
                else if (typeof ruleNodeReference[prop] === 'function') {
                    return ruleNodeReference[prop];
                }
            }
        }
    }
    get id() {
        return this._jsonModel.id;
    }
    get index() {
        if (this.parent) {
            return this.parent.indexOf(this);
        }
        return 0;
    }
    get parent() {
        return this._options.parent;
    }
    get type() {
        return this._jsonModel.type;
    }
    get repeatable() {
        return this.parent?.hasDynamicItems();
    }
    get fieldType() {
        return this._jsonModel.fieldType || 'text-input';
    }
    get ':type'() {
        return this._jsonModel[':type'] || this.fieldType;
    }
    get name() {
        return this._jsonModel.name;
    }
    get description() {
        return this._jsonModel.description;
    }
    set description(d) {
        this._setProperty('description', d);
    }
    get dataRef() {
        return this._jsonModel.dataRef;
    }
    get visible() {
        return this._jsonModel.visible;
    }
    set visible(v) {
        if (v !== this._jsonModel.visible) {
            const changeAction = propertyChange('visible', v, this._jsonModel.visible);
            this._jsonModel.visible = v;
            this.notifyDependents(changeAction);
        }
    }
    get form() {
        return this._options.form;
    }
    get ruleEngine() {
        return this.form.ruleEngine;
    }
    get label() {
        return this._jsonModel.label;
    }
    set label(l) {
        if (l !== this._jsonModel.label) {
            const changeAction = propertyChange('label', l, this._jsonModel.label);
            this._jsonModel = {
                ...this._jsonModel,
                label: l
            };
            this.notifyDependents(changeAction);
        }
    }
    get uniqueItems() {
        return this._jsonModel.uniqueItems;
    }
    isTransparent() {
        const isNonTransparent = this.parent?._jsonModel.type === 'array';
        return !this._jsonModel.name && !isNonTransparent;
    }
    getState(isRepeatableChild = false) {
        return {
            ...this._jsonModel,
            properties: this.properties,
            index: this.index,
            parent: undefined,
            qualifiedName: this.qualifiedName,
            events: {},
            rules: {},
            repeatable: this.repeatable === true ? true : undefined,
            ':type': this[':type']
        };
    }
    subscribe(callback, eventName = 'change') {
        this._callbacks[eventName] = this._callbacks[eventName] || [];
        this._callbacks[eventName].push(callback);
        return {
            unsubscribe: () => {
                this._callbacks[eventName] = this._callbacks[eventName].filter(x => x !== callback);
            }
        };
    }
    _addDependent(dependent) {
        if (this._dependents.find(({ node }) => node === dependent) === undefined) {
            const subscription = this.subscribe((change) => {
                const changes = change.payload.changes;
                const propsToLook = [...dynamicProps, 'items'];
                const isPropChanged = changes.findIndex(x => {
                    return propsToLook.indexOf(x.propertyName) > -1;
                }) > -1;
                if (isPropChanged) {
                    dependent.dispatch(new ExecuteRule());
                }
            });
            this._dependents.push({ node: dependent, subscription });
        }
    }
    removeDependent(dependent) {
        const index = this._dependents.findIndex(({ node }) => node === dependent);
        if (index > -1) {
            this._dependents[index].subscription.unsubscribe();
            this._dependents.splice(index, 1);
        }
    }
    queueEvent(action) {
        const actionWithTarget = new ActionImplWithTarget(action, this);
        this.form.getEventQueue().queue(this, actionWithTarget, ['valid', 'invalid'].indexOf(actionWithTarget.type) > -1);
    }
    dispatch(action) {
        this.queueEvent(action);
        this.form.getEventQueue().runPendingQueue();
    }
    notifyDependents(action) {
        const handlers = this._callbacks[action.type] || [];
        handlers.forEach(x => {
            x(new ActionImplWithTarget(action, this));
        });
    }
    _setProperty(prop, newValue, notify = true) {
        const oldValue = this._jsonModel[prop];
        let isValueSame = false;
        if (newValue !== null && oldValue !== null &&
            typeof newValue === 'object' && typeof oldValue === 'object') {
            isValueSame = JSON.stringify(newValue) === JSON.stringify(oldValue);
        }
        else {
            isValueSame = oldValue === newValue;
        }
        if (!isValueSame) {
            this._jsonModel[prop] = newValue;
            const changeAction = propertyChange(prop, newValue, oldValue);
            if (notify) {
                this.notifyDependents(changeAction);
            }
            return changeAction.payload.changes;
        }
        return [];
    }
    _bindToDataModel(contextualDataModel) {
        if (this.id === '$form') {
            this._data = contextualDataModel;
            return;
        }
        const dataRef = this._jsonModel.dataRef;
        let _data, _parent = contextualDataModel, _key = '';
        if (dataRef === null) {
            _data = NullDataValue;
        }
        else if (dataRef !== undefined) {
            if (this._tokens.length === 0) {
                this._tokens = tokenize(dataRef);
            }
            let searchData = contextualDataModel;
            if (this._tokens[0].type === TOK_GLOBAL$3) {
                searchData = this.form.getDataNode();
            }
            if (typeof searchData !== 'undefined') {
                const name = this._tokens[this._tokens.length - 1].value;
                const create = this.defaultDataModel(name);
                _data = resolveData(searchData, this._tokens, create);
                _parent = resolveData(searchData, this._tokens.slice(0, -1));
                _key = name;
            }
        }
        else {
            if (contextualDataModel !== NullDataValue && staticFields.indexOf(this.fieldType) === -1) {
                _parent = contextualDataModel;
                const name = this._jsonModel.name || '';
                const key = contextualDataModel.$type === 'array' ? this.index : name;
                _key = key;
                if (key !== '') {
                    const create = this.defaultDataModel(key);
                    if (create !== undefined) {
                        _data = contextualDataModel.$getDataNode(key);
                        if (_data === undefined) {
                            _data = create;
                            contextualDataModel.$addDataNode(key, _data);
                        }
                    }
                }
                else {
                    _data = undefined;
                }
            }
        }
        if (_data) {
            if (!this.isContainer && _parent !== NullDataValue && _data !== NullDataValue) {
                _data = _data?.$convertToDataValue();
                _parent.$addDataNode(_key, _data, true);
            }
            _data?.$bindToField(this);
            this._data = _data;
        }
    }
    _data;
    getDataNode() {
        return this._data;
    }
    get language() {
        if (!this._lang) {
            if (this.parent) {
                this._lang = this.parent.language;
            }
            else {
                this._lang = Intl.DateTimeFormat().resolvedOptions().locale;
            }
        }
        return this._lang;
    }
    get properties() {
        return this._jsonModel.properties || {};
    }
    set properties(p) {
        this._setProperty('properties', { ...p });
    }
    getNonTransparentParent() {
        let nonTransparentParent = this.parent;
        while (nonTransparentParent != null && nonTransparentParent.isTransparent()) {
            nonTransparentParent = nonTransparentParent.parent;
        }
        return nonTransparentParent;
    }
    _initialize() {
        if (typeof this._data === 'undefined') {
            let dataNode, parent = this.parent;
            do {
                dataNode = parent.getDataNode();
                parent = parent.parent;
            } while (dataNode === undefined);
            this._bindToDataModel(dataNode);
        }
    }
    _applyUpdates(propNames, updates) {
        return propNames.reduce((acc, propertyName) => {
            const currentValue = updates[propertyName];
            const changes = this._setProperty(propertyName, currentValue, false);
            if (changes.length > 0) {
                acc[propertyName] = changes[0];
            }
            return acc;
        }, {});
    }
    get qualifiedName() {
        if (this.isTransparent()) {
            return null;
        }
        if (this[qualifiedName] !== null) {
            return this[qualifiedName];
        }
        const parent = this.getNonTransparentParent();
        if (parent && parent.type === 'array') {
            this[qualifiedName] = `${parent.qualifiedName}[${this.index}]`;
        }
        else {
            this[qualifiedName] = `${parent.qualifiedName}.${this.name}`;
        }
        return this[qualifiedName];
    }
    focus() {
        if (this.parent) {
            this.parent.activeChild = this;
        }
    }
}
__decorate([
    dependencyTracked()
], BaseNode.prototype, "index", null);
__decorate([
    dependencyTracked()
], BaseNode.prototype, "description", null);
__decorate([
    dependencyTracked()
], BaseNode.prototype, "visible", null);
__decorate([
    dependencyTracked()
], BaseNode.prototype, "label", null);
__decorate([
    dependencyTracked()
], BaseNode.prototype, "properties", null);

const translationProps = ['description', 'placeholder', 'enum', 'enumNames', 'label.value', 'constraintMessages.accept',
    'constraintMessages.enum', 'constraintMessages.exclusiveMinimum', 'constraintMessages.exclusiveMaximum', 'constraintMessages.format', 'constraintMessages.maxFileSize', 'constraintMessages.maxLength',
    'constraintMessages.maximum', 'constraintMessages.maxItems', 'constraintMessages.minLength', 'constraintMessages.minimum', 'constraintMessages.minItems', 'constraintMessages.pattern', 'constraintMessages.required',
    'constraintMessages.step', 'constraintMessages.type', 'constraintMessages.validationExpression'];
const constraintProps = ['accept', 'enum', 'exclusiveMinimum', 'exclusiveMaximum',
    'format', 'maxFileSize', 'maxLength', 'maximum', 'maxItems',
    'minLength', 'minimum', 'minItems', 'pattern', 'required', 'step', 'validationExpression', 'enumNames'];

const objToMap = (o) => new Map(Object.entries(o));
const stringViewTypes = objToMap({ 'date': 'date-input', 'data-url': 'file-input', 'binary': 'file-input' });
const typeToViewTypes = objToMap({
    'number': 'number-input',
    'boolean': 'checkbox',
    'object': 'panel',
    'array': 'panel',
    'file': 'file-input',
    'file[]': 'file-input'
});
const arrayTypes = ['string[]', 'boolean[]', 'number[]', 'array'];
const defaultFieldTypes = (schema) => {
    const type = schema.type || 'string';
    if ('enum' in schema) {
        const enums = schema.enum;
        if (enums.length > 2 || arrayTypes.indexOf(type) > -1) {
            return 'drop-down';
        }
        else {
            return 'checkbox';
        }
    }
    if (type === 'string' || type === 'string[]') {
        return stringViewTypes.get(schema.format) || 'text-input';
    }
    return typeToViewTypes.get(type) || 'text-input';
};
const fieldSchema = (input) => {
    if ('items' in input) {
        const fieldset = input;
        const items = fieldset.items;
        if (fieldset.type === 'array') {
            return {
                type: 'array',
                items: fieldSchema(items[0]),
                minItems: fieldset?.minItems,
                maxItems: fieldset?.maxItems
            };
        }
        else {
            const iter = items.filter(x => x.name != null);
            return {
                type: 'object',
                properties: Object.fromEntries(iter.map(item => [item.name, fieldSchema(item)])),
                required: iter.filter(x => x.required).map(x => x.name)
            };
        }
    }
    else {
        const field = input;
        const schemaProps = ['type', 'maxLength', 'minLength', 'minimum', 'maximum', 'format', 'pattern', 'step', 'enum'];
        const schema = schemaProps.reduce((acc, prop) => {
            const p = prop;
            if (prop in field && field[p] != undefined) {
                acc[prop] = field[p];
            }
            return acc;
        }, {});
        if (field.dataRef === 'none' || Object.keys(schema).length == 0) {
            return undefined;
        }
        return {
            title: field.label?.value,
            description: field.description,
            ...schema
        };
    }
};
const exportDataSchema = (form) => {
    return fieldSchema(form);
};

const getProperty = (data, key, def) => {
    if (key in data) {
        return data[key];
    }
    else if (!key.startsWith(':')) {
        const prefixedKey = `:${key}`;
        if (prefixedKey in data) {
            return data[prefixedKey];
        }
    }
    return def;
};
const isFile = function (item) {
    return (item?.type === 'file' || item?.type === 'file[]') ||
        ((item?.type === 'string' || item?.type === 'string[]') &&
            (item?.format === 'binary' || item?.format === 'data-url'));
};
const checkIfConstraintsArePresent = function (item) {
    return constraintProps.some(cp => item[cp] !== undefined);
};
const isCheckbox = function (item) {
    const fieldType = item?.fieldType || defaultFieldTypes(item);
    return fieldType === 'checkbox';
};
const isCheckboxGroup = function (item) {
    const fieldType = item?.fieldType || defaultFieldTypes(item);
    return fieldType === 'checkbox-group';
};
const isDateField = function (item) {
    const fieldType = item?.fieldType || defaultFieldTypes(item);
    return (fieldType === 'text-input' && item?.format === 'date') || fieldType === 'date-input';
};
function deepClone(obj, idGenerator) {
    let result;
    if (obj instanceof Array) {
        result = [];
        result = obj.map(x => deepClone(x, idGenerator));
    }
    else if (typeof obj === 'object' && obj !== null) {
        result = {};
        Object.entries(obj).forEach(([key, value]) => {
            result[key] = deepClone(value, idGenerator);
        });
    }
    else {
        result = obj;
    }
    if (idGenerator && result && result.id) {
        result.id = idGenerator();
    }
    return result;
}
function checkIfKeyAdded(currentObj, prevObj, objKey) {
    if (currentObj != null && prevObj != null) {
        const newPrvObj = { ...prevObj };
        newPrvObj[objKey] = currentObj[objKey];
        const newJsonStr = jsonString(currentObj).replace(jsonString(newPrvObj), '');
        return newJsonStr === '';
    }
    else {
        return false;
    }
}
const jsonString = (obj) => {
    return JSON.stringify(obj, null, 2);
};
const isRepeatable = (obj) => {
    return ((obj.repeatable &&
        ((obj.minOccur === undefined && obj.maxOccur === undefined) ||
            (obj.minOccur !== undefined && obj.maxOccur !== undefined && obj.maxOccur !== 0) ||
            (obj.minOccur !== undefined && obj.maxOccur !== undefined && obj.minOccur !== 0 && obj.maxOccur !== 0) ||
            (obj.minOccur !== undefined && obj.minOccur >= 0) ||
            (obj.maxOccur !== undefined && obj.maxOccur !== 0))) || false);
};

class Scriptable extends BaseNode {
    _events = {};
    _rules = {};
    getRules() {
        return typeof this._jsonModel.rules !== 'object' ? {} : this._jsonModel.rules;
    }
    getCompiledRule(eName, rule) {
        if (!(eName in this._rules)) {
            const eString = rule || this.getRules()[eName];
            if (typeof eString === 'string' && eString.length > 0) {
                try {
                    this._rules[eName] = this.ruleEngine.compileRule(eString);
                }
                catch (e) {
                    this.form.logger.error(`Unable to compile rule \`"${eName}" : "${eString}"\` Exception : ${e}`);
                }
            }
            else {
                throw new Error(`only expression strings are supported. ${typeof (eString)} types are not supported`);
            }
        }
        return this._rules[eName];
    }
    getCompiledEvent(eName) {
        if (!(eName in this._events)) {
            let eString = this._jsonModel.events?.[eName];
            if (typeof eString === 'string' && eString.length > 0) {
                eString = [eString];
            }
            if (typeof eString !== 'undefined' && eString.length > 0) {
                this._events[eName] = eString.map(x => {
                    try {
                        return this.ruleEngine.compileRule(x);
                    }
                    catch (e) {
                        this.form.logger.error(`Unable to compile expression \`"${eName}" : "${eString}"\` Exception : ${e}`);
                    }
                    return null;
                }).filter(x => x !== null);
            }
        }
        return this._events[eName] || [];
    }
    applyUpdates(updates) {
        Object.entries(updates).forEach(([key, value]) => {
            if (key in editableProperties || (key in this && typeof this[key] !== 'function')) {
                try {
                    this[key] = value;
                }
                catch (e) {
                    console.error(e);
                }
            }
        });
    }
    executeAllRules(context) {
        const entries = Object.entries(this.getRules());
        if (entries.length > 0) {
            const scope = this.getExpressionScope();
            entries.forEach(([prop, rule]) => {
                const node = this.getCompiledRule(prop, rule);
                if (node) {
                    const newVal = this.ruleEngine.execute(node, scope, context, true);
                    if (editableProperties.indexOf(prop) > -1) {
                        this[prop] = newVal;
                    }
                    else {
                        this.form.logger.warn(`${prop} is not a valid editable property.`);
                    }
                }
            });
        }
    }
    getExpressionScope() {
        const parent = this.getNonTransparentParent();
        const target = {
            self: this.getRuleNode(),
            siblings: parent?.ruleNodeReference() || {}
        };
        const scope = new Proxy(target, {
            get: (target, prop) => {
                if (prop === Symbol.toStringTag) {
                    return 'Object';
                }
                prop = prop;
                if (prop.startsWith('$')) {
                    const retValue = target.self[prop];
                    if (retValue instanceof BaseNode) {
                        return retValue.getRuleNode();
                    }
                    else if (retValue instanceof Array) {
                        return retValue.map(r => r instanceof BaseNode ? r.getRuleNode() : r);
                    }
                    else {
                        return retValue;
                    }
                }
                else {
                    if (prop in target.siblings) {
                        return target.siblings[prop];
                    }
                    else {
                        return target.self[prop];
                    }
                }
            },
            has: (target, prop) => {
                prop = prop;
                const selfPropertyOrChild = target.self[prop];
                const sibling = target.siblings[prop];
                return typeof selfPropertyOrChild != 'undefined' || typeof sibling != 'undefined';
            }
        });
        return scope;
    }
    executeEvent(context, node) {
        let updates;
        if (node) {
            updates = this.ruleEngine.execute(node, this.getExpressionScope(), context);
        }
        if (typeof updates !== 'undefined' && updates != null) {
            this.applyUpdates(updates);
        }
    }
    executeRule(event, context) {
        if (typeof event.payload.ruleName === 'undefined') {
            this.executeAllRules(context);
        }
    }
    executeExpression(expr) {
        const ruleContext = {
            'form': this.form,
            '$form': this.form.getRuleNode(),
            '$field': this.getRuleNode(),
            'field': this
        };
        const node = this.ruleEngine.compileRule(expr);
        return this.ruleEngine.execute(node, this.getExpressionScope(), ruleContext);
    }
    executeAction(action) {
        const context = {
            'form': this.form,
            '$form': this.form.getRuleNode(),
            '$field': this.getRuleNode(),
            'field': this,
            '$event': {
                type: action.type,
                payload: action.payload,
                target: this.getRuleNode()
            }
        };
        const eventName = action.isCustomEvent ? `custom:${action.type}` : action.type;
        const funcName = action.isCustomEvent ? `custom_${action.type}` : action.type;
        const node = this.getCompiledEvent(eventName);
        if (funcName in this && typeof this[funcName] === 'function') {
            this[funcName](action, context);
        }
        node.forEach((n) => this.executeEvent(context, n));
        this.notifyDependents(action);
    }
}

class Container extends Scriptable {
    _children = [];
    _childrenReference;
    _itemTemplate = null;
    fieldFactory;
    constructor(json, _options) {
        super(json, { form: _options.form, parent: _options.parent });
        this.fieldFactory = _options.fieldFactory;
    }
    ruleNodeReference() {
        return this._childrenReference;
    }
    get items() {
        return this._children;
    }
    get maxItems() {
        return this._jsonModel.maxItems;
    }
    set maxItems(m) {
        this._jsonModel.maxItems = m;
        const minItems = this._jsonModel.minItems || 1;
        const itemsLength = this._children.length;
        const items2Remove = Math.min(itemsLength - m, itemsLength - minItems);
        if (items2Remove > 0) {
            for (let i = 0; i < items2Remove; i++) {
                this.getDataNode().$removeDataNode(m + i);
                this._childrenReference.pop();
            }
            const elems = this._children.splice(m, items2Remove);
            this.notifyDependents(propertyChange('items', elems, null));
        }
    }
    get minItems() {
        return this._jsonModel.minItems;
    }
    hasDynamicItems() {
        return this._itemTemplate != null;
    }
    get isContainer() {
        return true;
    }
    _activeChild = null;
    isSiteContainer(item) {
        return ':items' in item;
    }
    isAFormField(item) {
        return ('fieldType' in item || 'id' in item || 'name' in item || 'dataRef' in item || 'type' in item);
    }
    getItemsState(isRepeatableChild = false) {
        if (this._jsonModel.type === 'array' || isRepeatable(this._jsonModel) || isRepeatableChild) {
            return this._children.map(x => {
                return { ...x.getState(true) };
            });
        }
        else {
            return this._jsonModel.items.map(x => {
                if (this.isSiteContainer(x)) {
                    return {
                        ...x,
                        ':items': this.walkSiteContainerItems(x)
                    };
                }
                else if (this.isAFormField(x)) {
                    return { ...this.form.getElement(x?.id).getState(isRepeatableChild) };
                }
                else {
                    return x;
                }
            });
        }
    }
    getState(isRepeatableChild = false) {
        return {
            ...super.getState(isRepeatableChild),
            items: this.getItemsState(isRepeatableChild)
        };
    }
    _createChild(child, options) {
        const { parent = this } = options;
        return this.fieldFactory.createField(child, {
            form: options.form,
            parent
        });
    }
    walkSiteContainerItems(x) {
        return Object.fromEntries(Object.entries(x[':items']).map(([key, value]) => {
            if (this.isAFormField(value)) {
                return [key, this.form.getElement(value?.id).getState()];
            }
            else if (this.isSiteContainer(value)) {
                return this.walkSiteContainerItems(value);
            }
            else {
                return [key, value];
            }
        }));
    }
    _addChildToRuleNode(child, options) {
        const self = this;
        const { parent = this } = options;
        const name = parent.type == 'array' ? parent._children.length + '' : child.name || '';
        if (name.length > 0) {
            Object.defineProperty(parent._childrenReference, name, {
                get: () => {
                    if (child.isContainer && child.hasDynamicItems()) {
                        self.ruleEngine.trackDependency(child);
                    }
                    if (self.hasDynamicItems()) {
                        self.ruleEngine.trackDependency(self);
                        if (this._children[name] !== undefined) {
                            return this._children[name].getRuleNode();
                        }
                    }
                    else {
                        return child.getRuleNode();
                    }
                },
                configurable: true,
                enumerable: true
            });
        }
    }
    _addChild(itemJson, index, cloneIds = false) {
        let nonTransparentParent = this;
        while (nonTransparentParent != null && nonTransparentParent.isTransparent()) {
            nonTransparentParent = nonTransparentParent.parent;
        }
        if (typeof index !== 'number' || index > nonTransparentParent._children.length) {
            index = this._children.length;
        }
        const form = this.form;
        const itemTemplate = {
            index,
            ...deepClone(itemJson, cloneIds ? () => { return form.getUniqueId(); } : undefined)
        };
        const retVal = this._createChild(itemTemplate, { parent: this, form: this.form });
        itemJson.id = retVal.id;
        this.form.fieldAdded(retVal);
        this._addChildToRuleNode(retVal, { parent: nonTransparentParent });
        if (index === this._children.length) {
            this._children.push(retVal);
        }
        else {
            this._children.splice(index, 0, retVal);
        }
        return retVal;
    }
    indexOf(f) {
        return this._children.indexOf(f);
    }
    defaultDataModel(name) {
        const type = this._jsonModel.type || undefined;
        if (type === undefined) {
            return undefined;
        }
        else {
            const instance = type === 'array' ? [] : {};
            return new DataGroup(name, instance, type);
        }
    }
    _initialize() {
        super._initialize();
        const items = this._jsonModel.items || [];
        this._childrenReference = this._jsonModel.type == 'array' ? [] : {};
        if (this._jsonModel.type == 'array' && items.length === 1 && this.getDataNode() != null) {
            this._itemTemplate = deepClone(items[0]);
            if (typeof (this._jsonModel.minItems) !== 'number') {
                this._jsonModel.minItems = 0;
            }
            if (typeof (this._jsonModel.maxItems) !== 'number') {
                this._jsonModel.maxItems = -1;
            }
            if (typeof (this._jsonModel.initialItems) !== 'number') {
                this._jsonModel.initialItems = Math.max(1, this._jsonModel.minItems);
            }
            for (let i = 0; i < this._jsonModel.initialItems; i++) {
                const child = this._addChild(this._itemTemplate, null, i > 0);
                items[0].id = child.id;
                child._initialize();
            }
        }
        else if (items.length > 0) {
            items.forEach((item) => {
                if (this.isSiteContainer(item)) {
                    this._initializeSiteContainer(item);
                }
                else if (this.isAFormField(item)) {
                    const child = this._addChild(item);
                    child._initialize();
                }
                else {
                    this.form.logger.warn('A container item was not initialized.');
                }
            });
            this._jsonModel.minItems = this._children.length;
            this._jsonModel.maxItems = this._children.length;
            this._jsonModel.initialItems = this._children.length;
        }
        else {
            this.form.logger.warn('A container exists with no items.');
        }
        this.setupRuleNode();
    }
    _initializeSiteContainer(item) {
        Object.entries(item[':items']).forEach(([key, value]) => {
            if (this.isAFormField(value)) {
                const child = this._addChild(value);
                child._initialize();
            }
            else if (this.isSiteContainer(value)) {
                return this._initializeSiteContainer(value);
            }
        });
    }
    addItem(action) {
        if ((action.type === 'addItem' || action.type == 'addInstance') && this._itemTemplate != null) {
            if ((this._jsonModel.maxItems === -1) || (this._children.length < this._jsonModel.maxItems)) {
                const dataNode = this.getDataNode();
                let instanceIndex = action.payload;
                const retVal = this._addChild(this._itemTemplate, action.payload, true);
                if (typeof instanceIndex !== 'number' || instanceIndex > this._children.length) {
                    instanceIndex = this._children.length;
                }
                const _data = retVal.defaultDataModel(instanceIndex);
                if (_data) {
                    dataNode.$addDataNode(instanceIndex, _data);
                }
                retVal._initialize();
                this.notifyDependents(propertyChange('items', retVal.getState(), null));
                retVal.dispatch(new Initialize());
                retVal.dispatch(new ExecuteRule());
                for (let i = instanceIndex + 1; i < this._children.length; i++) {
                    this._children[i].dispatch(new ExecuteRule());
                }
            }
        }
    }
    removeItem(action) {
        if ((action.type === 'removeItem' || action.type == 'removeInstance') && this._itemTemplate != null) {
            if (this._children.length == 0) {
                return;
            }
            let instanceIndex = action.payload;
            if (typeof instanceIndex !== 'number') {
                instanceIndex = this._children.length - 1;
            }
            const state = this._children[instanceIndex].getState();
            if (this._children.length > this._jsonModel.minItems) {
                this._childrenReference.pop();
                this._children.splice(instanceIndex, 1);
                this.getDataNode().$removeDataNode(instanceIndex);
                for (let i = instanceIndex; i < this._children.length; i++) {
                    this._children[i].dispatch(new ExecuteRule());
                }
                this.notifyDependents(propertyChange('items', null, state));
            }
        }
    }
    queueEvent(action) {
        super.queueEvent(action);
        if (action.metadata?.dispatch) {
            this.items.forEach(x => {
                x.queueEvent(action);
            });
        }
    }
    reset() {
        if (this.type === 'array' || isRepeatable(this._jsonModel)) {
            if (this.items.length > this._jsonModel.initialItems) {
                const itemsToBeRemoved = this.items.length - this._jsonModel.initialItems;
                for (let i = 0; i < itemsToBeRemoved; i++) {
                    this.dispatch(new RemoveItem());
                }
            }
        }
        this.items.forEach(x => {
            x.reset();
        });
    }
    validate() {
        return this.items.flatMap(x => {
            return x.validate();
        }).filter(x => x.fieldName !== '');
    }
    dispatch(action) {
        super.dispatch(action);
    }
    importData(contextualDataModel) {
        this._bindToDataModel(contextualDataModel);
        const dataNode = this.getDataNode() || contextualDataModel;
        this.syncDataAndFormModel(dataNode);
    }
    syncDataAndFormModel(contextualDataModel) {
        if (contextualDataModel?.$type === 'array' && this._itemTemplate != null) {
            const dataLength = contextualDataModel?.$value.length;
            const itemsLength = this._children.length;
            const maxItems = this._jsonModel.maxItems === -1 ? dataLength : this._jsonModel.maxItems;
            const minItems = this._jsonModel.minItems;
            let items2Add = Math.min(dataLength - itemsLength, maxItems - itemsLength);
            const items2Remove = Math.min(itemsLength - dataLength, itemsLength - minItems);
            while (items2Add > 0) {
                items2Add--;
                const child = this._addChild(this._itemTemplate);
                child._initialize();
            }
            if (items2Remove > 0) {
                this._children.splice(dataLength, items2Remove);
                for (let i = 0; i < items2Remove; i++) {
                    this._childrenReference.pop();
                }
            }
        }
        this._children.forEach(x => {
            x.importData(contextualDataModel);
        });
    }
    get activeChild() {
        return this._activeChild;
    }
    set activeChild(c) {
        if (c !== this._activeChild) {
            let activeChild = this._activeChild;
            while (activeChild instanceof Container) {
                const temp = activeChild.activeChild;
                activeChild.activeChild = null;
                activeChild = temp;
            }
            const change = propertyChange('activeChild', c, this._activeChild);
            this._activeChild = c;
            if (this.parent && c !== null) {
                this.parent.activeChild = this;
            }
            this._jsonModel.activeChild = c?.id;
            this.notifyDependents(change);
        }
    }
}
__decorate([
    dependencyTracked()
], Container.prototype, "maxItems", null);
__decorate([
    dependencyTracked()
], Container.prototype, "minItems", null);
__decorate([
    dependencyTracked()
], Container.prototype, "activeChild", null);

class Node {
    _jsonModel;
    constructor(inputModel) {
        this._jsonModel = {
            ...inputModel
        };
    }
    getP(key, def) {
        return getProperty(this._jsonModel, key, def);
    }
    get isContainer() {
        return false;
    }
}

class FormMetaData extends Node {
    get version() {
        return this.getP('version', '');
    }
    get grammar() {
        return this.getP('grammar', '');
    }
}

const levels = {
    off: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4
};
class Logger {
    debug(msg) {
        this.log(msg, 'debug');
    }
    info(msg) {
        this.log(msg, 'info');
    }
    warn(msg) {
        this.log(msg, 'warn');
    }
    error(msg) {
        this.log(msg, 'error');
    }
    log(msg, level) {
        if (this.logLevel !== 0 && this.logLevel <= levels[level]) {
            console[level](msg);
        }
    }
    logLevel;
    constructor(logLevel = 'off') {
        this.logLevel = levels[logLevel];
    }
}

class EventNode {
    _node;
    _event;
    constructor(_node, _event) {
        this._node = _node;
        this._event = _event;
    }
    get node() {
        return this._node;
    }
    get event() {
        return this._event;
    }
    isEqual(that) {
        return that !== null && that !== undefined && this._node == that._node && this._event.type == that._event.type;
    }
    toString() {
        return this._node.id + '__' + this.event.type;
    }
    valueOf() {
        return this.toString();
    }
}
class EventQueue {
    logger;
    static MAX_EVENT_CYCLE_COUNT = 10;
    _runningEventCount;
    _isProcessing = false;
    _pendingEvents = [];
    constructor(logger = new Logger('off')) {
        this.logger = logger;
        this._runningEventCount = {};
    }
    get length() {
        return this._pendingEvents.length;
    }
    get isProcessing() {
        return this._isProcessing;
    }
    isQueued(node, event) {
        const evntNode = new EventNode(node, event);
        return this._pendingEvents.find(x => evntNode.isEqual(x)) !== undefined;
    }
    queue(node, events, priority = false) {
        if (!node || !events) {
            return;
        }
        if (!(events instanceof Array)) {
            events = [events];
        }
        events.forEach(e => {
            const evntNode = new EventNode(node, e);
            const counter = this._runningEventCount[evntNode.valueOf()] || 0;
            if (counter < EventQueue.MAX_EVENT_CYCLE_COUNT) {
                this.logger.info(`Queued event : ${e.type} node: ${node.id} - ${node.name}`);
                if (priority) {
                    const index = this._isProcessing ? 1 : 0;
                    this._pendingEvents.splice(index, 0, evntNode);
                }
                else {
                    this._pendingEvents.push(evntNode);
                }
                this._runningEventCount[evntNode.valueOf()] = counter + 1;
            }
            else {
                this.logger.info(`Skipped queueing event : ${e.type} node: ${node.id} - ${node.name} with count=${counter}`);
            }
        });
    }
    runPendingQueue() {
        if (this._isProcessing) {
            return;
        }
        this._isProcessing = true;
        while (this._pendingEvents.length > 0) {
            const e = this._pendingEvents[0];
            this.logger.info(`Dequeued event : ${e.event.type} node: ${e.node.id} - ${e.node.name}`);
            e.node.executeAction(e.event);
            this._pendingEvents.shift();
        }
        this._runningEventCount = {};
        this._isProcessing = false;
    }
}

class FileObject {
    data;
    mediaType = 'application/octet-stream';
    name = 'unknown';
    size = 0;
    constructor(init) {
        Object.assign(this, init);
    }
    get type() {
        return this.mediaType;
    }
    toJSON() {
        return {
            'name': this.name,
            'size': this.size,
            'mediaType': this.mediaType,
            'data': this.data.toString()
        };
    }
    equals(obj) {
        return (this.data === obj.data &&
            this.mediaType === obj.mediaType &&
            this.name === obj.name &&
            this.size === obj.size);
    }
}

const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'.split('');
const fileSizeRegex = /^(\d*\.?\d+)(\\?(?=[KMGT])([KMGT])(?:i?B)?|B?)$/i;
const randomWord = (l) => {
    const ret = [];
    for (let i = 0; i <= l; i++) {
        const randIndex = Math.floor(Math.random() * (chars.length));
        ret.push(chars[randIndex]);
    }
    return ret.join('');
};
const isEmpty = (value) => {
    return value === '' || value === null || value === undefined;
};
const getAttachments = (input) => {
    const items = input.items || [];
    return items?.reduce((acc, item) => {
        let ret = null;
        if (item.isContainer) {
            ret = getAttachments(item);
        }
        else {
            if (isFile(item.getState())) {
                ret = {};
                const name = item.name || '';
                const dataRef = (item.dataRef != null)
                    ? item.dataRef
                    : (name.length > 0 ? item.name : undefined);
                if (item.value instanceof Array) {
                    ret[item.id] = item.value.map((x) => {
                        return { ...x, 'dataRef': dataRef };
                    });
                }
                else if (item.value != null) {
                    ret[item.id] = { ...item.value, 'dataRef': dataRef };
                }
            }
        }
        return Object.assign(acc, ret);
    }, {});
};
const getFileSizeInBytes = (str) => {
    let retVal = 0;
    if (typeof str === 'string') {
        const matches = fileSizeRegex.exec(str.trim());
        if (matches != null) {
            retVal = sizeToBytes(parseFloat(matches[1]), (matches[2] || 'kb').toUpperCase());
        }
    }
    return retVal;
};
const sizeToBytes = (size, symbol) => {
    const sizes = { 'KB': 1, 'MB': 2, 'GB': 3, 'TB': 4 };
    const i = Math.pow(1024, sizes[symbol]);
    return Math.round(size * i);
};
const IdGenerator = function* (initial = 50) {
    const initialize = function () {
        const arr = [];
        for (let i = 0; i < initial; i++) {
            arr.push(randomWord(10));
        }
        return arr;
    };
    const passedIds = {};
    let ids = initialize();
    do {
        let x = ids.pop();
        while (x in passedIds) {
            if (ids.length === 0) {
                ids = initialize();
            }
            x = ids.pop();
        }
        passedIds[x] = true;
        yield ids.pop();
        if (ids.length === 0) {
            ids = initialize();
        }
    } while (ids.length > 0);
};
const isDataUrl = (str) => {
    const dataUrlRegex = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
    return dataUrlRegex.exec(str.trim()) != null;
};
const extractFileInfo = (file) => {
    if (file !== null) {
        let retVal = null;
        if (file instanceof FileObject) {
            retVal = file;
        }
        else if (typeof File !== 'undefined' && file instanceof File) {
            retVal = {
                name: file.name,
                mediaType: file.type,
                size: file.size,
                data: file
            };
        }
        else if (typeof file === 'string' && isDataUrl(file)) {
            const result = dataURItoBlob(file);
            if (result !== null) {
                const { blob, name } = result;
                retVal = {
                    name: name,
                    mediaType: blob.type,
                    size: blob.size,
                    data: blob
                };
            }
        }
        else {
            let jFile = file;
            try {
                jFile = JSON.parse(file);
                retVal = jFile;
                if (!retVal.mediaType) {
                    retVal.mediaType = retVal.type;
                }
            }
            catch (ex) {
            }
            if (typeof jFile?.data === 'string' && isDataUrl(jFile?.data)) {
                const result = dataURItoBlob(jFile?.data);
                if (result !== null) {
                    const blob = result.blob;
                    retVal = {
                        name: jFile?.name,
                        mediaType: jFile?.type || jFile?.mediaType,
                        size: blob.size,
                        data: blob
                    };
                }
            }
            else if (typeof jFile === 'string') {
                const fileName = jFile.split('/').pop();
                retVal = {
                    name: fileName,
                    mediaType: 'application/octet-stream',
                    size: 0,
                    data: jFile
                };
            }
            else if (typeof jFile === 'object') {
                retVal = {
                    name: jFile?.name,
                    mediaType: jFile?.type || jFile?.mediaType,
                    size: jFile?.size,
                    data: jFile?.data
                };
            }
        }
        if (retVal !== null && retVal.data != null) {
            return new FileObject(retVal);
        }
        return null;
    }
    else {
        return null;
    }
};
const dataURItoBlob = (dataURI) => {
    const regex = /^data:([a-z]+\/[a-z0-9-+.]+)?(?:;name=([^;]+))?(;base64)?,(.+)$/;
    const groups = regex.exec(dataURI);
    if (groups !== null) {
        const type = groups[1] || '';
        const name = groups[2] || 'unknown';
        const isBase64 = typeof groups[3] === 'string';
        if (isBase64) {
            const binary = atob(groups[4]);
            const array = [];
            for (let i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            const blob = new window.Blob([new Uint8Array(array)], { type });
            return { name, blob };
        }
        else {
            const blob = new window.Blob([groups[4]], { type });
            return { name, blob };
        }
    }
    else {
        return null;
    }
};

const request$1 = (url, data = null, options = {}) => {
    const opts = { ...defaultRequestOptions, ...options };
    const updatedUrl = opts.method === 'GET' && data ? convertQueryString(url, data) : url;
    if (opts.method !== 'GET') {
        opts.body = data;
    }
    return fetch(updatedUrl, {
        ...opts
    }).then(async (response) => {
        let body;
        if (!response.ok) {
            console.error(`Error fetching response from ${url} : ${response.statusText}`);
            body = response.statusText;
        }
        else {
            if (response?.headers?.get('Content-Type')?.includes('application/json')) {
                body = await response.json();
            }
            else {
                body = await response.text();
            }
        }
        const headers = {};
        response?.headers?.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            status: response.status,
            body,
            headers
        };
    });
};
const defaultRequestOptions = {
    method: 'GET'
};
const convertQueryString = (endpoint, payload) => {
    if (!payload) {
        return endpoint;
    }
    let updatedPayload = {};
    try {
        updatedPayload = JSON.parse(payload);
    }
    catch (err) {
        console.log('Query params invalid');
    }
    const params = [];
    Object.keys(updatedPayload).forEach((key) => {
        if (Array.isArray(updatedPayload[key])) {
            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(JSON.stringify(updatedPayload[key]))}`);
        }
        else {
            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(updatedPayload[key])}`);
        }
    });
    if (!params.length) {
        return endpoint;
    }
    return endpoint.includes('?') ? `${endpoint}&${params.join('&')}` : `${endpoint}?${params.join('&')}`;
};

const getCustomEventName = (name) => {
    const eName = name;
    if (eName.length > 0 && eName.startsWith('custom:')) {
        return eName.substring('custom:'.length);
    }
    return eName;
};
const request = async (context, uri, httpVerb, payload, success, error, headers) => {
    const endpoint = uri;
    const requestOptions = {
        method: httpVerb
    };
    let result;
    let inputPayload;
    try {
        if (payload && payload instanceof FileObject && payload.data instanceof File) {
            const formData = new FormData();
            formData.append(payload.name, payload.data);
            inputPayload = formData;
        }
        else if (payload instanceof FormData) {
            inputPayload = payload;
        }
        else if (payload && typeof payload === 'object' && Object.keys(payload).length > 0) {
            const headerNames = Object.keys(headers);
            if (headerNames.length > 0) {
                requestOptions.headers = {
                    ...headers,
                    ...(headerNames.indexOf('Content-Type') === -1 ? { 'Content-Type': 'application/json' } : {})
                };
            }
            else {
                requestOptions.headers = { 'Content-Type': 'application/json' };
            }
            const contentType = requestOptions?.headers?.['Content-Type'] || 'application/json';
            if (contentType === 'application/json') {
                inputPayload = JSON.stringify(payload);
            }
            else if (contentType.indexOf('multipart/form-data') > -1) {
                inputPayload = multipartFormData(payload);
            }
            else if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
                inputPayload = urlEncoded(payload);
            }
        }
        result = await request$1(endpoint, inputPayload, requestOptions);
    }
    catch (e) {
        context.form.logger.error('Error invoking a rest API');
        const eName = getCustomEventName(error);
        context.form.dispatch(new CustomEvent(eName, {}, true));
        return;
    }
    const eName = getCustomEventName(success);
    context.form.dispatch(new CustomEvent(eName, result, true));
};
const urlEncoded = (data) => {
    const formData = new URLSearchParams();
    Object.entries(data).forEach(([key, value]) => {
        if (value != null && typeof value === 'object') {
            formData.append(key, jsonString(value));
        }
        else {
            formData.append(key, value);
        }
    });
    return formData;
};
const multipartFormData = (data, attachments) => {
    const formData = new FormData();
    Object.entries(data).forEach(([key, value]) => {
        if (value != null && typeof value === 'object') {
            formData.append(key, jsonString(value));
        }
        else {
            formData.append(key, value);
        }
    });
    const addAttachmentToFormData = (objValue, formData) => {
        if (objValue?.data instanceof File) {
            let attIdentifier = `${objValue?.dataRef}/${objValue?.name}`;
            if (!attIdentifier.startsWith('/')) {
                attIdentifier = `/${attIdentifier}`;
            }
            formData.append(attIdentifier, objValue.data);
        }
    };
    if (attachments) {
        Object.keys(attachments).reduce((acc, curr) => {
            const objValue = attachments[curr];
            if (objValue && objValue instanceof Array) {
                return [...acc, ...objValue.map((x) => addAttachmentToFormData(x, formData))];
            }
            else {
                return [...acc, addAttachmentToFormData(objValue, formData)];
            }
        }, []);
    }
    return formData;
};
const submit = async (context, success, error, submitAs = 'multipart/form-data', input_data = null) => {
    const endpoint = context.form.action;
    let data = input_data;
    if (typeof data != 'object' || data == null) {
        data = context.form.exportData();
    }
    const attachments = getAttachments(context.form);
    let submitContentType = submitAs;
    const submitDataAndMetaData = { 'data': data, 'submitMetadata': { 'lang': context.form.lang } };
    let formData = submitDataAndMetaData;
    if (Object.keys(attachments).length > 0 || submitAs === 'multipart/form-data') {
        formData = multipartFormData(submitDataAndMetaData, attachments);
        submitContentType = 'multipart/form-data';
    }
    await request(context, endpoint, 'POST', formData, success, error, {
        'Content-Type': submitContentType
    });
};
const createAction = (name, payload = {}) => {
    switch (name) {
        case 'change':
            return new Change(payload);
        case 'submit':
            return new Submit(payload);
        case 'click':
            return new Click(payload);
        case 'addItem':
            return new AddItem(payload);
        case 'removeItem':
            return new RemoveItem(payload);
        case 'reset':
            return new Reset(payload);
        case 'addInstance':
            return new AddInstance(payload);
        case 'removeInstance':
            return new RemoveInstance(payload);
        default:
            console.error('invalid action');
    }
};
class FunctionRuntimeImpl {
    customFunctions = {};
    registerFunctions(functions) {
        Object.entries(functions).forEach(([name, funcDef]) => {
            let finalFunction = funcDef;
            if (typeof funcDef === 'function') {
                finalFunction = {
                    _func: (args) => {
                        return funcDef(...args);
                    },
                    _signature: []
                };
            }
            if (!finalFunction.hasOwnProperty('_func')) {
                console.warn(`Unable to register function with name ${name}.`);
                return;
            }
            this.customFunctions[name] = finalFunction;
        });
    }
    unregisterFunctions(...names) {
        names.forEach(name => {
            if (name in this.customFunctions) {
                delete this.customFunctions[name];
            }
        });
    }
    getFunctions() {
        function isArray(obj) {
            if (obj !== null) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            }
            return false;
        }
        function valueOf(a) {
            if (a === null || a === undefined) {
                return a;
            }
            if (isArray(a)) {
                return a.map(i => valueOf(i));
            }
            return a.valueOf();
        }
        function toString(a) {
            if (a === null || a === undefined) {
                return '';
            }
            return a.toString();
        }
        const defaultFunctions = {
            validate: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    let validation;
                    if (typeof element === 'string' || typeof element === 'undefined') {
                        validation = interpreter.globals.form.validate();
                    }
                    else {
                        validation = interpreter.globals.form.getElement(element.$id).validate();
                    }
                    if (Array.isArray(validation) && validation.length) {
                        interpreter.globals.form.logger.error('Form Validation Error');
                    }
                    return validation;
                },
                _signature: []
            },
            setFocus: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    try {
                        const field = interpreter.globals.form.getElement(element.$id);
                        interpreter.globals.form.setFocus(field);
                    }
                    catch (e) {
                        interpreter.globals.form.logger.error('Invalid argument passed in setFocus. An element is expected');
                    }
                },
                _signature: []
            },
            getData: {
                _func: (args, data, interpreter) => {
                    interpreter.globals.form.logger.warn('The `getData` function is depricated. Use `exportData` instead.');
                    return interpreter.globals.form.exportData();
                },
                _signature: []
            },
            exportData: {
                _func: (args, data, interpreter) => {
                    return interpreter.globals.form.exportData();
                },
                _signature: []
            },
            importData: {
                _func: (args, data, interpreter) => {
                    const inputData = args[0];
                    if (typeof inputData === 'object' && inputData !== null) {
                        interpreter.globals.form.importData(inputData);
                    }
                    return {};
                },
                _signature: []
            },
            submitForm: {
                _func: (args, data, interpreter) => {
                    const success = toString(args[0]);
                    const error = toString(args[1]);
                    const submit_as = args.length > 2 ? toString(args[2]) : 'multipart/form-data';
                    const submit_data = args.length > 3 ? valueOf(args[3]) : null;
                    interpreter.globals.form.dispatch(new Submit({
                        success,
                        error,
                        submit_as,
                        data: submit_data
                    }));
                    return {};
                },
                _signature: []
            },
            request: {
                _func: (args, data, interpreter) => {
                    const uri = toString(args[0]);
                    const httpVerb = toString(args[1]);
                    const payload = valueOf(args[2]);
                    let success, error, headers = {};
                    if (typeof (args[3]) === 'string') {
                        interpreter.globals.form.logger.warn('This usage of request is deprecated. Please see the documentation and update');
                        success = valueOf(args[3]);
                        error = valueOf(args[4]);
                    }
                    else {
                        headers = valueOf(args[3]);
                        success = valueOf(args[4]);
                        error = valueOf(args[5]);
                    }
                    request(interpreter.globals, uri, httpVerb, payload, success, error, headers);
                    return {};
                },
                _signature: []
            },
            dispatchEvent: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    let eventName = valueOf(args[1]);
                    let payload = args.length > 2 ? valueOf(args[2]) : undefined;
                    let dispatch = false;
                    if (typeof element === 'string') {
                        payload = eventName;
                        eventName = element;
                        dispatch = true;
                    }
                    let event;
                    if (eventName.startsWith('custom:')) {
                        event = new CustomEvent(eventName.substring('custom:'.length), payload, dispatch);
                    }
                    else {
                        event = createAction(eventName, payload);
                    }
                    if (event != null) {
                        if (typeof element === 'string') {
                            interpreter.globals.form.dispatch(event);
                        }
                        else {
                            interpreter.globals.form.getElement(element.$id).dispatch(event);
                        }
                    }
                    return {};
                },
                _signature: []
            }
        };
        return { ...defaultFunctions, ...this.customFunctions };
    }
}
const FunctionRuntime = new FunctionRuntimeImpl();

class Form extends Container {
    _ruleEngine;
    _eventQueue;
    _fields = {};
    _ids;
    _invalidFields = [];
    _logger;
    constructor(n, fieldFactory, _ruleEngine, _eventQueue = new EventQueue(), logLevel = 'off') {
        super(n, { fieldFactory: fieldFactory });
        this._ruleEngine = _ruleEngine;
        this._eventQueue = _eventQueue;
        this._logger = new Logger(logLevel);
        this.queueEvent(new Initialize());
        this.queueEvent(new ExecuteRule());
        this._ids = IdGenerator();
        this._bindToDataModel(new DataGroup('$form', {}));
        this._initialize();
        this.queueEvent(new FormLoad());
    }
    get logger() {
        return this._logger;
    }
    dataRefRegex = /("[^"]+?"|[^.]+?)(?:\.|$)/g;
    get metaData() {
        const metaData = this._jsonModel.metadata || {};
        return new FormMetaData(metaData);
    }
    get action() {
        return this._jsonModel.action;
    }
    get lang() {
        return this._jsonModel.lang || 'en';
    }
    importData(dataModel) {
        this._bindToDataModel(new DataGroup('$form', dataModel));
        this.syncDataAndFormModel(this.getDataNode());
        this._eventQueue.runPendingQueue();
    }
    exportData() {
        return this.getDataNode()?.$value;
    }
    setFocus(field) {
        const parent = field.parent;
        const currentField = field;
        while (parent != null && parent.activeChild != currentField) {
            parent.activeChild = currentField;
        }
    }
    getState() {
        const self = this;
        const res = super.getState();
        res.id = '$form';
        Object.defineProperty(res, 'data', {
            get: function () {
                return self.exportData();
            }
        });
        Object.defineProperty(res, 'attachments', {
            get: function () {
                return getAttachments(self);
            }
        });
        return res;
    }
    get type() {
        return 'object';
    }
    isTransparent() {
        return false;
    }
    get form() {
        return this;
    }
    get ruleEngine() {
        return this._ruleEngine;
    }
    getUniqueId() {
        if (this._ids == null) {
            return '';
        }
        return this._ids.next().value;
    }
    fieldAdded(field) {
        this._fields[field.id] = field;
        field.subscribe((action) => {
            if (this._invalidFields.indexOf(action.target.id) === -1) {
                this._invalidFields.push(action.target.id);
            }
        }, 'invalid');
        field.subscribe((action) => {
            const index = this._invalidFields.indexOf(action.target.id);
            if (index > -1) {
                this._invalidFields.splice(index, 1);
            }
        }, 'valid');
        field.subscribe((action) => {
            const field = action.target.getState();
            if (field) {
                const fieldChangedAction = new FieldChanged(action.payload.changes, field);
                this.dispatch(fieldChangedAction);
            }
        });
    }
    visit(callBack) {
        this.traverseChild(this, callBack);
    }
    traverseChild(container, callBack) {
        container.items.forEach((field) => {
            if (field.isContainer) {
                this.traverseChild(field, callBack);
            }
            callBack(field);
        });
    }
    validate() {
        const validationErrors = super.validate();
        this.dispatch(new ValidationComplete(validationErrors));
        return validationErrors;
    }
    isValid() {
        return this._invalidFields.length === 0;
    }
    dispatch(action) {
        if (action.type === 'submit') {
            super.queueEvent(action);
            this._eventQueue.runPendingQueue();
        }
        else {
            super.dispatch(action);
        }
    }
    submit(action, context) {
        if (this.validate().length === 0) {
            const payload = action?.payload || {};
            submit(context, payload?.success, payload?.error, payload?.submit_as, payload?.data);
        }
    }
    reset() {
        super.reset();
        this._invalidFields = [];
    }
    getElement(id) {
        if (id == this.id) {
            return this;
        }
        return this._fields[id];
    }
    get qualifiedName() {
        return '$form';
    }
    getEventQueue() {
        return this._eventQueue;
    }
    get name() {
        return '$form';
    }
    get value() {
        return null;
    }
    get id() {
        return '$form';
    }
    get title() {
        return this._jsonModel.title || '';
    }
}

var dataTypes = {
  TYPE_NUMBER: 0,
  TYPE_ANY: 1,
  TYPE_STRING: 2,
  TYPE_ARRAY: 3,
  TYPE_OBJECT: 4,
  TYPE_BOOLEAN: 5,
  TYPE_EXPREF: 6,
  TYPE_NULL: 7,
  TYPE_ARRAY_NUMBER: 8,
  TYPE_ARRAY_STRING: 9,
  TYPE_CLASS: 10,
  TYPE_ARRAY_ARRAY: 11,
};

var tokenDefinitions = {
  TOK_EOF: 'EOF',
  TOK_UNQUOTEDIDENTIFIER: 'UnquotedIdentifier',
  TOK_QUOTEDIDENTIFIER: 'QuotedIdentifier',
  TOK_RBRACKET: 'Rbracket',
  TOK_RPAREN: 'Rparen',
  TOK_COMMA: 'Comma',
  TOK_COLON: 'Colon',
  TOK_CONCATENATE: 'Concatenate',
  TOK_RBRACE: 'Rbrace',
  TOK_NUMBER: 'Number',
  TOK_CURRENT: 'Current',
  TOK_GLOBAL: 'Global',
  TOK_FIELD: 'Field',
  TOK_EXPREF: 'Expref',
  TOK_PIPE: 'Pipe',
  TOK_OR: 'Or',
  TOK_AND: 'And',
  TOK_ADD: 'Add',
  TOK_SUBTRACT: 'Subtract',
  TOK_UNARY_MINUS: 'UnaryMinus',
  TOK_MULTIPLY: 'Multiply',
  TOK_POWER: 'Power',
  TOK_UNION: 'Union',
  TOK_DIVIDE: 'Divide',
  TOK_EQ: 'EQ',
  TOK_GT: 'GT',
  TOK_LT: 'LT',
  TOK_GTE: 'GTE',
  TOK_LTE: 'LTE',
  TOK_NE: 'NE',
  TOK_FLATTEN: 'Flatten',
  TOK_STAR: 'Star',
  TOK_FILTER: 'Filter',
  TOK_DOT: 'Dot',
  TOK_NOT: 'Not',
  TOK_LBRACE: 'Lbrace',
  TOK_LBRACKET: 'Lbracket',
  TOK_LPAREN: 'Lparen',
  TOK_LITERAL: 'Literal',
};

const {
  TYPE_NUMBER,
  TYPE_ANY: TYPE_ANY$1,
  TYPE_STRING: TYPE_STRING$1,
  TYPE_ARRAY: TYPE_ARRAY$1,
  TYPE_OBJECT,
  TYPE_BOOLEAN,
  TYPE_EXPREF,
  TYPE_NULL,
  TYPE_ARRAY_NUMBER,
  TYPE_ARRAY_STRING: TYPE_ARRAY_STRING$1,
  TYPE_CLASS: TYPE_CLASS$1,
  TYPE_ARRAY_ARRAY,
} = dataTypes;
const {
  TOK_EXPREF: TOK_EXPREF$3,
} = tokenDefinitions;
const TYPE_NAME_TABLE = {
  [TYPE_NUMBER]: 'number',
  [TYPE_ANY$1]: 'any',
  [TYPE_STRING$1]: 'string',
  [TYPE_ARRAY$1]: 'array',
  [TYPE_OBJECT]: 'object',
  [TYPE_BOOLEAN]: 'boolean',
  [TYPE_EXPREF]: 'expression',
  [TYPE_NULL]: 'null',
  [TYPE_ARRAY_NUMBER]: 'Array<number>',
  [TYPE_ARRAY_STRING$1]: 'Array<string>',
  [TYPE_CLASS$1]: 'class',
  [TYPE_ARRAY_ARRAY]: 'Array<array>',
};
function getTypeName(inputObj, useValueOf = true) {
  if (inputObj === null) return TYPE_NULL;
  let obj = inputObj;
  if (useValueOf) {
    if (typeof inputObj.valueOf === 'function') obj = inputObj.valueOf.call(inputObj);
    else return TYPE_OBJECT;
  }
  switch (Object.prototype.toString.call(obj)) {
    case '[object String]':
      return TYPE_STRING$1;
    case '[object Number]':
      return TYPE_NUMBER;
    case '[object Array]':
      return TYPE_ARRAY$1;
    case '[object Boolean]':
      return TYPE_BOOLEAN;
    case '[object Null]':
      return TYPE_NULL;
    case '[object Object]':
      if (obj.jmespathType === TOK_EXPREF$3) {
        return TYPE_EXPREF;
      }
      return TYPE_OBJECT;
    default:
      return TYPE_OBJECT;
  }
}
function getTypeNames(inputObj) {
  const type1 = getTypeName(inputObj);
  const type2 = getTypeName(inputObj, false);
  return [type1, type2];
}
function matchType(actuals, expectedList, argValue, context, toNumber, toString) {
  const actual = actuals[0];
  if (expectedList.findIndex(
    type => type === TYPE_ANY$1 || actual === type,
  ) !== -1
  ) return argValue;
  let wrongType = false;
  if (actual === TYPE_OBJECT || (expectedList.length === 1 && expectedList[0] === TYPE_CLASS$1)) {
    wrongType = true;
  }
  if (actual === TYPE_ARRAY$1 && (expectedList.length === 1 && expectedList[0] === TYPE_OBJECT)) {
    wrongType = true;
  }
  if (expectedList.includes(TYPE_ARRAY_ARRAY)) {
    if (actual === TYPE_ARRAY$1) {
      argValue.forEach(a => {
        if (!(a instanceof Array)) wrongType = true;
      });
      if (!wrongType) return argValue;
    }
    wrongType = true;
  }
  if (wrongType) {
    throw new Error(`TypeError: ${context} expected argument to be type ${TYPE_NAME_TABLE[expectedList[0]]} but received type ${TYPE_NAME_TABLE[actual]} instead.`);
  }
  let expected = -1;
  if (actual === TYPE_ARRAY$1) {
    if (expectedList.includes(TYPE_ARRAY_STRING$1) && expectedList.includes(TYPE_ARRAY_NUMBER)) {
      if (argValue.length > 0 && typeof argValue[0] === 'string') expected = TYPE_ARRAY_STRING$1;
      else expected = TYPE_ARRAY_NUMBER;
    }
  }
  if (expected === -1 && [TYPE_ARRAY_STRING$1, TYPE_ARRAY_NUMBER, TYPE_ARRAY$1].includes(actual)) {
    expected = expectedList.find(
      e => [TYPE_ARRAY_STRING$1, TYPE_ARRAY_NUMBER, TYPE_ARRAY$1].includes(e),
    );
  }
  if (expected === -1) [expected] = expectedList;
  if (expected === TYPE_ANY$1) return argValue;
  if (expected === TYPE_ARRAY_STRING$1
      || expected === TYPE_ARRAY_NUMBER
      || expected === TYPE_ARRAY$1) {
    if (expected === TYPE_ARRAY$1) {
      if (actual === TYPE_ARRAY_NUMBER || actual === TYPE_ARRAY_STRING$1) return argValue;
      return argValue === null ? [] : [argValue];
    }
    const subtype = expected === TYPE_ARRAY_NUMBER ? TYPE_NUMBER : TYPE_STRING$1;
    if (actual === TYPE_ARRAY$1) {
      const returnArray = argValue.slice();
      for (let i = 0; i < returnArray.length; i += 1) {
        const indexType = getTypeNames(returnArray[i]);
        returnArray[i] = matchType(
          indexType,
          [subtype],
          returnArray[i],
          context,
          toNumber,
          toString,
        );
      }
      return returnArray;
    }
    if ([TYPE_NUMBER, TYPE_STRING$1, TYPE_NULL, TYPE_BOOLEAN].includes(subtype)) {
      return [matchType(actuals, [subtype], argValue, context, toNumber, toString)];
    }
  } else {
    if (expected === TYPE_NUMBER) {
      if ([TYPE_STRING$1, TYPE_BOOLEAN, TYPE_NULL].includes(actual)) return toNumber(argValue);
      return 0;
    }
    if (expected === TYPE_STRING$1) {
      if (actual === TYPE_NULL || actual === TYPE_OBJECT) return '';
      return toString(argValue);
    }
    if (expected === TYPE_BOOLEAN) {
      return !!argValue;
    }
    if (expected === TYPE_OBJECT && actuals[1] === TYPE_OBJECT) {
      return argValue;
    }
  }
  throw new Error(`TypeError: ${context} expected argument to be type ${TYPE_NAME_TABLE[expectedList[0]]} but received type ${TYPE_NAME_TABLE[actual]} instead.`);
}

function isArray(obj) {
  if (obj !== null) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  }
  return false;
}
function isObject(obj) {
  if (obj !== null) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }
  return false;
}
function getValueOf(a) {
  if (a === null || a === undefined) return a;
  if (isArray(a)) {
    return a.map(i => getValueOf(i));
  }
  if (typeof (a.valueOf) !== 'function') return a;
  return a.valueOf();
}
function strictDeepEqual(lhs, rhs) {
  const first = getValueOf(lhs);
  const second = getValueOf(rhs);
  if (first === second) {
    return true;
  }
  const firstType = Object.prototype.toString.call(first);
  if (firstType !== Object.prototype.toString.call(second)) {
    return false;
  }
  if (isArray(first) === true) {
    if (first.length !== second.length) {
      return false;
    }
    for (let i = 0; i < first.length; i += 1) {
      if (strictDeepEqual(first[i], second[i]) === false) {
        return false;
      }
    }
    return true;
  }
  if (isObject(first) === true) {
    const keysSeen = {};
    for (const key in first) {
      if (hasOwnProperty.call(first, key)) {
        if (strictDeepEqual(first[key], second[key]) === false) {
          return false;
        }
        keysSeen[key] = true;
      }
    }
    for (const key2 in second) {
      if (hasOwnProperty.call(second, key2)) {
        if (keysSeen[key2] !== true) {
          return false;
        }
      }
    }
    return true;
  }
  return false;
}

const {
  TOK_CURRENT: TOK_CURRENT$2,
  TOK_GLOBAL: TOK_GLOBAL$2,
  TOK_EXPREF: TOK_EXPREF$2,
  TOK_PIPE: TOK_PIPE$2,
  TOK_EQ: TOK_EQ$2,
  TOK_GT: TOK_GT$2,
  TOK_LT: TOK_LT$2,
  TOK_GTE: TOK_GTE$2,
  TOK_LTE: TOK_LTE$2,
  TOK_NE: TOK_NE$2,
  TOK_FLATTEN: TOK_FLATTEN$2,
} = tokenDefinitions;
const {
  TYPE_STRING,
  TYPE_ARRAY_STRING,
  TYPE_ARRAY,
} = dataTypes;
function isFalse(value) {
  if (value === null) return true;
  const obj = getValueOf(value);
  if (obj === '' || obj === false || obj === null) {
    return true;
  }
  if (isArray(obj) && obj.length === 0) {
    return true;
  }
  if (isObject(obj)) {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  }
  return !obj;
}
function objValues(obj) {
  return Object.values(obj);
}
class TreeInterpreter {
  constructor(runtime, globals, toNumber, toString, debug, language) {
    this.runtime = runtime;
    this.globals = globals;
    this.toNumber = toNumber;
    this.toString = toString;
    this.debug = debug;
    this.language = language;
  }
  search(node, value) {
    return this.visit(node, value);
  }
  visit(n, v) {
    const visitFunctions = {
      Field: (node, value) => {
        if (value !== null && (isObject(value) || isArray(value))) {
          let field = value[node.name];
          if (typeof field === 'function') field = undefined;
          if (field === undefined) {
            try {
              this.debug.push(`Failed to find: '${node.name}'`);
              const available = Object.keys(value).map(a => `'${a}'`).toString();
              if (available.length) this.debug.push(`Available fields: ${available}`);
            } catch (e) {}
            return null;
          }
          return field;
        }
        return null;
      },
      Subexpression: (node, value) => {
        let result = this.visit(node.children[0], value);
        for (let i = 1; i < node.children.length; i += 1) {
          result = this.visit(node.children[1], result);
          if (result === null) return null;
        }
        return result;
      },
      IndexExpression: (node, value) => {
        const left = this.visit(node.children[0], value);
        return this.visit(node.children[1], left);
      },
      Index: (node, value) => {
        if (isArray(value)) {
          let index = this.toNumber(this.visit(node.value, value));
          if (index < 0) {
            index = value.length + index;
          }
          const result = value[index];
          if (result === undefined) {
            this.debug.push(`Index ${index} out of range`);
            return null;
          }
          return result;
        }
        if (isObject(value)) {
          const key = this.toString(this.visit(node.value, value));
          const result = value[key];
          if (result === undefined) {
            this.debug.push(`Key ${key} does not exist`);
            return null;
          }
          return result;
        }
        this.debug.push(`left side of index expression ${value} is not an array or object.`);
        return null;
      },
      Slice: (node, value) => {
        if (!isArray(value)) return null;
        const sliceParams = node.children.slice(0).map(
          param => (param != null ? this.toNumber(this.visit(param, value)) : null),
        );
        const computed = this.computeSliceParams(value.length, sliceParams);
        const [start, stop, step] = computed;
        const result = [];
        if (step > 0) {
          for (let i = start; i < stop; i += step) {
            result.push(value[i]);
          }
        } else {
          for (let i = start; i > stop; i += step) {
            result.push(value[i]);
          }
        }
        return result;
      },
      Projection: (node, value) => {
        const base = this.visit(node.children[0], value);
        if (!isArray(base)) return null;
        const collected = [];
        base.forEach(b => {
          const current = this.visit(node.children[1], b);
          if (current !== null) {
            collected.push(current);
          }
        });
        return collected;
      },
      ValueProjection: (node, value) => {
        const projection = this.visit(node.children[0], value);
        if (!isObject(getValueOf(projection))) return null;
        const collected = [];
        const values = objValues(projection);
        values.forEach(val => {
          const current = this.visit(node.children[1], val);
          if (current !== null) collected.push(current);
        });
        return collected;
      },
      FilterProjection: (node, value) => {
        const base = this.visit(node.children[0], value);
        if (!isArray(base)) return null;
        const filtered = base.filter(b => {
          const matched = this.visit(node.children[2], b);
          return !isFalse(matched);
        });
        const finalResults = [];
        filtered.forEach(f => {
          const current = this.visit(node.children[1], f);
          if (current !== null) finalResults.push(current);
        });
        return finalResults;
      },
      Comparator: (node, value) => {
        const first = this.visit(node.children[0], value);
        const second = this.visit(node.children[1], value);
        if (node.name === TOK_EQ$2) return strictDeepEqual(first, second);
        if (node.name === TOK_NE$2) return !strictDeepEqual(first, second);
        if (node.name === TOK_GT$2) return first > second;
        if (node.name === TOK_GTE$2) return first >= second;
        if (node.name === TOK_LT$2) return first < second;
        if (node.name === TOK_LTE$2) return first <= second;
        throw new Error(`Unknown comparator: ${node.name}`);
      },
      [TOK_FLATTEN$2]: (node, value) => {
        const original = this.visit(node.children[0], value);
        if (!isArray(original)) return null;
        const merged = [];
        original.forEach(current => {
          if (isArray(current)) {
            merged.push(...current);
          } else {
            merged.push(current);
          }
        });
        return merged;
      },
      Identity: (_node, value) => value,
      MultiSelectList: (node, value) => {
        if (value === null) return null;
        return node.children.map(child => this.visit(child, value));
      },
      MultiSelectHash: (node, value) => {
        if (value === null) return null;
        const collected = {};
        node.children.forEach(child => {
          collected[child.name] = this.visit(child.value, value);
        });
        return collected;
      },
      OrExpression: (node, value) => {
        let matched = this.visit(node.children[0], value);
        if (isFalse(matched)) matched = this.visit(node.children[1], value);
        return matched;
      },
      AndExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        if (isFalse(first) === true) return first;
        return this.visit(node.children[1], value);
      },
      AddExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        const second = this.visit(node.children[1], value);
        return this.applyOperator(first, second, '+');
      },
      ConcatenateExpression: (node, value) => {
        let first = this.visit(node.children[0], value);
        let second = this.visit(node.children[1], value);
        first = matchType(getTypeNames(first), [TYPE_STRING, TYPE_ARRAY_STRING], first, 'concatenate', this.toNumber, this.toString);
        second = matchType(getTypeNames(second), [TYPE_STRING, TYPE_ARRAY_STRING], second, 'concatenate', this.toNumber, this.toString);
        return this.applyOperator(first, second, '&');
      },
      UnionExpression: (node, value) => {
        let first = this.visit(node.children[0], value);
        let second = this.visit(node.children[1], value);
        first = matchType(getTypeNames(first), [TYPE_ARRAY], first, 'union', this.toNumber, this.toString);
        second = matchType(getTypeNames(second), [TYPE_ARRAY], second, 'union', this.toNumber, this.toString);
        return first.concat(second);
      },
      SubtractExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        const second = this.visit(node.children[1], value);
        return this.applyOperator(first, second, '-');
      },
      MultiplyExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        const second = this.visit(node.children[1], value);
        return this.applyOperator(first, second, '*');
      },
      DivideExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        const second = this.visit(node.children[1], value);
        return this.applyOperator(first, second, '/');
      },
      PowerExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        const second = this.visit(node.children[1], value);
        return this.applyOperator(first, second, '^');
      },
      NotExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        return isFalse(first);
      },
      UnaryMinusExpression: (node, value) => {
        const first = this.visit(node.children[0], value);
        return first * -1;
      },
      Literal: node => node.value,
      Number: node => node.value,
      [TOK_PIPE$2]: (node, value) => {
        const left = this.visit(node.children[0], value);
        return this.visit(node.children[1], left);
      },
      [TOK_CURRENT$2]: (_node, value) => value,
      [TOK_GLOBAL$2]: node => {
        const result = this.globals[node.name];
        return result === undefined ? null : result;
      },
      Function: (node, value) => {
        if (node.name === 'if') return this.runtime.callFunction(node.name, node.children, value, this, false);
        const resolvedArgs = node.children.map(child => this.visit(child, value));
        return this.runtime.callFunction(node.name, resolvedArgs, value, this);
      },
      ExpressionReference: node => {
        const [refNode] = node.children;
        refNode.jmespathType = TOK_EXPREF$2;
        return refNode;
      },
    };
    const fn = n && visitFunctions[n.type];
    if (!fn) throw new Error(`Unknown/missing node type ${(n && n.type) || ''}`);
    return fn(n, v);
  }
  computeSliceParams(arrayLength, sliceParams) {
    function capSliceRange(arrayLen, actual, stp) {
      let actualValue = actual;
      if (actualValue < 0) {
        actualValue += arrayLen;
        if (actualValue < 0) {
          actualValue = stp < 0 ? -1 : 0;
        }
      } else if (actualValue >= arrayLen) {
        actualValue = stp < 0 ? arrayLen - 1 : arrayLen;
      }
      return actualValue;
    }
    let [start, stop, step] = sliceParams;
    if (step === null) {
      step = 1;
    } else if (step === 0) {
      const error = new Error('Invalid slice, step cannot be 0');
      error.name = 'RuntimeError';
      throw error;
    }
    const stepValueNegative = step < 0;
    if (start === null) {
      start = stepValueNegative ? arrayLength - 1 : 0;
    } else {
      start = capSliceRange(arrayLength, start, step);
    }
    if (stop === null) {
      stop = stepValueNegative ? -1 : arrayLength;
    } else {
      stop = capSliceRange(arrayLength, stop, step);
    }
    return [start, stop, step];
  }
  applyOperator(first, second, operator) {
    if (isArray(first) && isArray(second)) {
      const shorter = first.length < second.length ? first : second;
      const diff = Math.abs(first.length - second.length);
      shorter.length += diff;
      shorter.fill(null, shorter.length - diff);
      const result = [];
      for (let i = 0; i < first.length; i += 1) {
        result.push(this.applyOperator(first[i], second[i], operator));
      }
      return result;
    }
    if (isArray(first)) return first.map(a => this.applyOperator(a, second, operator));
    if (isArray(second)) return second.map(a => this.applyOperator(first, a, operator));
    if (operator === '*') return this.toNumber(first) * this.toNumber(second);
    if (operator === '&') return first + second;
    if (operator === '+') {
      return this.toNumber(first) + this.toNumber(second);
    }
    if (operator === '-') return this.toNumber(first) - this.toNumber(second);
    if (operator === '/') {
      const result = first / second;
      return Number.isFinite(result) ? result : null;
    }
    if (operator === '^') {
      return first ** second;
    }
    throw new Error(`Unknown operator: ${operator}`);
  }
}

const {
  TOK_UNQUOTEDIDENTIFIER: TOK_UNQUOTEDIDENTIFIER$1,
  TOK_QUOTEDIDENTIFIER: TOK_QUOTEDIDENTIFIER$1,
  TOK_RBRACKET: TOK_RBRACKET$1,
  TOK_RPAREN: TOK_RPAREN$1,
  TOK_COMMA: TOK_COMMA$1,
  TOK_COLON: TOK_COLON$1,
  TOK_CONCATENATE: TOK_CONCATENATE$1,
  TOK_RBRACE: TOK_RBRACE$1,
  TOK_NUMBER: TOK_NUMBER$1,
  TOK_CURRENT: TOK_CURRENT$1,
  TOK_GLOBAL: TOK_GLOBAL$1,
  TOK_EXPREF: TOK_EXPREF$1,
  TOK_PIPE: TOK_PIPE$1,
  TOK_OR: TOK_OR$1,
  TOK_AND: TOK_AND$1,
  TOK_ADD: TOK_ADD$1,
  TOK_SUBTRACT: TOK_SUBTRACT$1,
  TOK_UNARY_MINUS: TOK_UNARY_MINUS$1,
  TOK_MULTIPLY: TOK_MULTIPLY$1,
  TOK_POWER: TOK_POWER$1,
  TOK_DIVIDE: TOK_DIVIDE$1,
  TOK_UNION: TOK_UNION$1,
  TOK_EQ: TOK_EQ$1,
  TOK_GT: TOK_GT$1,
  TOK_LT: TOK_LT$1,
  TOK_GTE: TOK_GTE$1,
  TOK_LTE: TOK_LTE$1,
  TOK_NE: TOK_NE$1,
  TOK_FLATTEN: TOK_FLATTEN$1,
  TOK_STAR: TOK_STAR$1,
  TOK_FILTER: TOK_FILTER$1,
  TOK_DOT: TOK_DOT$1,
  TOK_NOT: TOK_NOT$1,
  TOK_LBRACE: TOK_LBRACE$1,
  TOK_LBRACKET: TOK_LBRACKET$1,
  TOK_LPAREN: TOK_LPAREN$1,
  TOK_LITERAL: TOK_LITERAL$1,
} = tokenDefinitions;
const basicTokens = {
  '.': TOK_DOT$1,
  ',': TOK_COMMA$1,
  ':': TOK_COLON$1,
  '{': TOK_LBRACE$1,
  '}': TOK_RBRACE$1,
  ']': TOK_RBRACKET$1,
  '(': TOK_LPAREN$1,
  ')': TOK_RPAREN$1,
  '@': TOK_CURRENT$1,
};
const globalStartToken = '$';
const operatorStartToken = {
  '<': true,
  '>': true,
  '=': true,
  '!': true,
};
const skipChars = {
  ' ': true,
  '\t': true,
  '\n': true,
};
function isNum(ch) {
  return (ch >= '0' && ch <= '9') || (ch === '.');
}
function isAlphaNum(ch) {
  return (ch >= 'a' && ch <= 'z')
           || (ch >= 'A' && ch <= 'Z')
           || (ch >= '0' && ch <= '9')
           || ch === '_';
}
function isIdentifier(stream, pos) {
  const ch = stream[pos];
  if (ch === '$') {
    return stream.length > pos && isAlphaNum(stream[pos + 1]);
  }
  return (ch >= 'a' && ch <= 'z')
          || (ch >= 'A' && ch <= 'Z')
          || ch === '_';
}
class Lexer {
  constructor(allowedGlobalNames = [], debug = []) {
    this._allowedGlobalNames = allowedGlobalNames;
    this.debug = debug;
  }
  tokenize(stream) {
    const tokens = [];
    this._current = 0;
    let start;
    let identifier;
    let token;
    while (this._current < stream.length) {
      const prev = tokens.length ? tokens.slice(-1)[0].type : null;
      if (this._isGlobal(prev, stream, this._current)) {
        tokens.push(this._consumeGlobal(stream));
      } else if (isIdentifier(stream, this._current)) {
        start = this._current;
        identifier = this._consumeUnquotedIdentifier(stream);
        tokens.push({
          type: TOK_UNQUOTEDIDENTIFIER$1,
          value: identifier,
          start,
        });
      } else if (basicTokens[stream[this._current]] !== undefined) {
        tokens.push({
          type: basicTokens[stream[this._current]],
          value: stream[this._current],
          start: this._current,
        });
        this._current += 1;
      } else if (stream[this._current] === '-' && ![TOK_GLOBAL$1, TOK_CURRENT$1, TOK_NUMBER$1, TOK_RPAREN$1, TOK_UNQUOTEDIDENTIFIER$1, TOK_QUOTEDIDENTIFIER$1, TOK_RBRACKET$1].includes(prev)) {
        token = this._consumeUnaryMinus(stream);
        tokens.push(token);
      } else if (isNum(stream[this._current])) {
        token = this._consumeNumber(stream);
        tokens.push(token);
      } else if (stream[this._current] === '[') {
        token = this._consumeLBracket(stream);
        tokens.push(token);
      } else if (stream[this._current] === '"') {
        start = this._current;
        identifier = this._consumeQuotedIdentifier(stream);
        tokens.push({
          type: TOK_QUOTEDIDENTIFIER$1,
          value: identifier,
          start,
        });
      } else if (stream[this._current] === "'") {
        start = this._current;
        identifier = this._consumeRawStringLiteral(stream);
        tokens.push({
          type: TOK_LITERAL$1,
          value: identifier,
          start,
        });
      } else if (stream[this._current] === '`') {
        start = this._current;
        const literal = this._consumeLiteral(stream);
        tokens.push({
          type: TOK_LITERAL$1,
          value: literal,
          start,
        });
      } else if (operatorStartToken[stream[this._current]] !== undefined) {
        tokens.push(this._consumeOperator(stream));
      } else if (skipChars[stream[this._current]] !== undefined) {
        this._current += 1;
      } else if (stream[this._current] === '&') {
        start = this._current;
        this._current += 1;
        if (stream[this._current] === '&') {
          this._current += 1;
          tokens.push({ type: TOK_AND$1, value: '&&', start });
        } else if (prev === TOK_COMMA$1 || prev === TOK_LPAREN$1) {
          tokens.push({ type: TOK_EXPREF$1, value: '&', start });
        } else {
          tokens.push({ type: TOK_CONCATENATE$1, value: '&', start });
        }
      } else if (stream[this._current] === '~') {
        start = this._current;
        this._current += 1;
        tokens.push({ type: TOK_UNION$1, value: '~', start });
      } else if (stream[this._current] === '+') {
        start = this._current;
        this._current += 1;
        tokens.push({ type: TOK_ADD$1, value: '+', start });
      } else if (stream[this._current] === '-') {
        start = this._current;
        this._current += 1;
        tokens.push({ type: TOK_SUBTRACT$1, value: '-', start });
      } else if (stream[this._current] === '*') {
        start = this._current;
        this._current += 1;
        const prevToken = tokens.length && tokens.slice(-1)[0].type;
        if (tokens.length === 0 || [
          TOK_LBRACKET$1,
          TOK_DOT$1,
          TOK_PIPE$1,
          TOK_AND$1,
          TOK_OR$1,
          TOK_COMMA$1,
          TOK_COLON$1,
        ].includes(prevToken)) {
          tokens.push({ type: TOK_STAR$1, value: '*', start });
        } else {
          tokens.push({ type: TOK_MULTIPLY$1, value: '*', start });
        }
      } else if (stream[this._current] === '/') {
        start = this._current;
        this._current += 1;
        tokens.push({ type: TOK_DIVIDE$1, value: '/', start });
      } else if (stream[this._current] === '^') {
        start = this._current;
        this._current += 1;
        tokens.push({ type: TOK_POWER$1, value: '^', start });
      } else if (stream[this._current] === '|') {
        start = this._current;
        this._current += 1;
        if (stream[this._current] === '|') {
          this._current += 1;
          tokens.push({ type: TOK_OR$1, value: '||', start });
        } else {
          tokens.push({ type: TOK_PIPE$1, value: '|', start });
        }
      } else {
        const error = new Error(`Unknown character:${stream[this._current]}`);
        error.name = 'LexerError';
        throw error;
      }
    }
    return tokens;
  }
  _consumeUnquotedIdentifier(stream) {
    const start = this._current;
    this._current += 1;
    while (this._current < stream.length && isAlphaNum(stream[this._current])) {
      this._current += 1;
    }
    return stream.slice(start, this._current);
  }
  _consumeQuotedIdentifier(stream) {
    const start = this._current;
    this._current += 1;
    const maxLength = stream.length;
    let foundNonAlpha = !isIdentifier(stream, start + 1);
    while (stream[this._current] !== '"' && this._current < maxLength) {
      let current = this._current;
      if (!isAlphaNum(stream[current])) foundNonAlpha = true;
      if (stream[current] === '\\' && (stream[current + 1] === '\\'
                                             || stream[current + 1] === '"')) {
        current += 2;
      } else {
        current += 1;
      }
      this._current = current;
    }
    this._current += 1;
    const val = stream.slice(start, this._current);
    try {
      if (!foundNonAlpha || val.includes(' ')) {
        this.debug.push(`Suspicious quotes: ${val}`);
        this.debug.push(`Did you intend a literal? '${val.replace(/"/g, '')}'?`);
      }
    } catch (e) {}
    return JSON.parse(val);
  }
  _consumeRawStringLiteral(stream) {
    const start = this._current;
    this._current += 1;
    const maxLength = stream.length;
    while (stream[this._current] !== "'" && this._current < maxLength) {
      let current = this._current;
      if (stream[current] === '\\' && (stream[current + 1] === '\\'
                                             || stream[current + 1] === "'")) {
        current += 2;
      } else {
        current += 1;
      }
      this._current = current;
    }
    this._current += 1;
    const literal = stream.slice(start + 1, this._current - 1);
    return literal.replaceAll("\\'", "'");
  }
  _consumeNumber(stream) {
    const start = this._current;
    this._current += 1;
    const maxLength = stream.length;
    while (isNum(stream[this._current]) && this._current < maxLength) {
      this._current += 1;
    }
    const n = stream.slice(start, this._current);
    let value;
    if (n.includes('.')) {
      value = parseFloat(n);
    } else {
      value = parseInt(n, 10);
    }
    return { type: TOK_NUMBER$1, value, start };
  }
  _consumeUnaryMinus() {
    const start = this._current;
    this._current += 1;
    return { type: TOK_UNARY_MINUS$1, value: '-', start };
  }
  _consumeLBracket(stream) {
    const start = this._current;
    this._current += 1;
    if (stream[this._current] === '?') {
      this._current += 1;
      return { type: TOK_FILTER$1, value: '[?', start };
    }
    if (stream[this._current] === ']') {
      this._current += 1;
      return { type: TOK_FLATTEN$1, value: '[]', start };
    }
    return { type: TOK_LBRACKET$1, value: '[', start };
  }
  _isGlobal(prev, stream, pos) {
    if (prev !== null && prev === TOK_DOT$1) return false;
    const ch = stream[pos];
    if (ch !== globalStartToken) return false;
    let i = pos + 1;
    while (i < stream.length && isAlphaNum(stream[i])) i += 1;
    const global = stream.slice(pos, i);
    return this._allowedGlobalNames.includes(global);
  }
  _consumeGlobal(stream) {
    const start = this._current;
    this._current += 1;
    while (this._current < stream.length && isAlphaNum(stream[this._current])) this._current += 1;
    const global = stream.slice(start, this._current);
    return { type: TOK_GLOBAL$1, name: global, start };
  }
  _consumeOperator(stream) {
    const start = this._current;
    const startingChar = stream[start];
    this._current += 1;
    if (startingChar === '!') {
      if (stream[this._current] === '=') {
        this._current += 1;
        return { type: TOK_NE$1, value: '!=', start };
      }
      return { type: TOK_NOT$1, value: '!', start };
    }
    if (startingChar === '<') {
      if (stream[this._current] === '=') {
        this._current += 1;
        return { type: TOK_LTE$1, value: '<=', start };
      }
      return { type: TOK_LT$1, value: '<', start };
    }
    if (startingChar === '>') {
      if (stream[this._current] === '=') {
        this._current += 1;
        return { type: TOK_GTE$1, value: '>=', start };
      }
      return { type: TOK_GT$1, value: '>', start };
    }
    if (stream[this._current] === '=') {
      this._current += 1;
      return { type: TOK_EQ$1, value: '==', start };
    }
    return { type: TOK_EQ$1, value: '=', start };
  }
  _consumeLiteral(stream) {
    function _looksLikeJSON(str) {
      if (str === '') return false;
      if ('[{"'.includes(str[0])) return true;
      if (['true', 'false', 'null'].includes(str)) return true;
      if ('-0123456789'.includes(str[0])) {
        try {
          JSON.parse(str);
          return true;
        } catch (ex) {
          return false;
        }
      } else {
        return false;
      }
    }
    this._current += 1;
    const start = this._current;
    const maxLength = stream.length;
    let literal;
    let inQuotes = false;
    while ((inQuotes || stream[this._current] !== '`') && this._current < maxLength) {
      let current = this._current;
      if (inQuotes && stream[current] === '\\' && stream[current + 1] === '"') current += 2;
      else {
        if (stream[current] === '"') inQuotes = !inQuotes;
        if (inQuotes && stream[current + 1] === '`') current += 2;
        else if (stream[current] === '\\' && (stream[current + 1] === '\\'
                                              || stream[current + 1] === '`')) {
          current += 2;
        } else {
          current += 1;
        }
      }
      this._current = current;
    }
    let literalString = stream.slice(start, this._current).trimStart();
    literalString = literalString.replaceAll('\\`', '`');
    if (_looksLikeJSON(literalString)) {
      literal = JSON.parse(literalString);
    } else {
      literal = JSON.parse(`"${literalString}"`);
    }
    this._current += 1;
    return literal;
  }
}

const {
  TOK_LITERAL,
  TOK_COLON,
  TOK_EOF,
  TOK_UNQUOTEDIDENTIFIER,
  TOK_QUOTEDIDENTIFIER,
  TOK_RBRACKET,
  TOK_RPAREN,
  TOK_COMMA,
  TOK_CONCATENATE,
  TOK_RBRACE,
  TOK_NUMBER,
  TOK_CURRENT,
  TOK_GLOBAL,
  TOK_FIELD,
  TOK_EXPREF,
  TOK_PIPE,
  TOK_OR,
  TOK_AND,
  TOK_ADD,
  TOK_SUBTRACT,
  TOK_UNARY_MINUS,
  TOK_MULTIPLY,
  TOK_POWER,
  TOK_DIVIDE,
  TOK_UNION,
  TOK_EQ,
  TOK_GT,
  TOK_LT,
  TOK_GTE,
  TOK_LTE,
  TOK_NE,
  TOK_FLATTEN,
  TOK_STAR,
  TOK_FILTER,
  TOK_DOT,
  TOK_NOT,
  TOK_LBRACE,
  TOK_LBRACKET,
  TOK_LPAREN,
} = tokenDefinitions;
const bindingPower = {
  [TOK_EOF]: 0,
  [TOK_UNQUOTEDIDENTIFIER]: 0,
  [TOK_QUOTEDIDENTIFIER]: 0,
  [TOK_RBRACKET]: 0,
  [TOK_RPAREN]: 0,
  [TOK_COMMA]: 0,
  [TOK_RBRACE]: 0,
  [TOK_NUMBER]: 0,
  [TOK_CURRENT]: 0,
  [TOK_GLOBAL]: 0,
  [TOK_FIELD]: 0,
  [TOK_EXPREF]: 0,
  [TOK_PIPE]: 1,
  [TOK_OR]: 2,
  [TOK_AND]: 3,
  [TOK_CONCATENATE]: 5,
  [TOK_ADD]: 6,
  [TOK_SUBTRACT]: 6,
  [TOK_MULTIPLY]: 7,
  [TOK_DIVIDE]: 7,
  [TOK_POWER]: 7,
  [TOK_UNION]: 7,
  [TOK_EQ]: 5,
  [TOK_GT]: 5,
  [TOK_LT]: 5,
  [TOK_GTE]: 5,
  [TOK_LTE]: 5,
  [TOK_NE]: 5,
  [TOK_FLATTEN]: 9,
  [TOK_STAR]: 20,
  [TOK_FILTER]: 21,
  [TOK_DOT]: 40,
  [TOK_NOT]: 30,
  [TOK_UNARY_MINUS]: 30,
  [TOK_LBRACE]: 50,
  [TOK_LBRACKET]: 55,
  [TOK_LPAREN]: 60,
};
class Parser {
  constructor(allowedGlobalNames = []) {
    this._allowedGlobalNames = allowedGlobalNames;
  }
  parse(expression, debug) {
    this._loadTokens(expression, debug);
    this.index = 0;
    const ast = this.expression(0);
    if (this._lookahead(0) !== TOK_EOF) {
      const t = this._lookaheadToken(0);
      const error = new Error(
        `Unexpected token type: ${t.type}, value: ${t.value}`,
      );
      error.name = 'ParserError';
      throw error;
    }
    return ast;
  }
  _loadTokens(expression, debug) {
    const lexer = new Lexer(this._allowedGlobalNames, debug);
    const tokens = lexer.tokenize(expression);
    tokens.push({ type: TOK_EOF, value: '', start: expression.length });
    this.tokens = tokens;
  }
  expression(rbp) {
    const leftToken = this._lookaheadToken(0);
    this._advance();
    let left = this.nud(leftToken);
    let currentToken = this._lookahead(0);
    while (rbp < bindingPower[currentToken]) {
      this._advance();
      left = this.led(currentToken, left);
      currentToken = this._lookahead(0);
    }
    return left;
  }
  _lookahead(number) {
    return this.tokens[this.index + number].type;
  }
  _lookaheadToken(number) {
    return this.tokens[this.index + number];
  }
  _advance() {
    this.index += 1;
  }
  _getIndex() {
    return this.index;
  }
  _setIndex(index) {
    this.index = index;
  }
  nud(token) {
    let left;
    let right;
    let expression;
    let node;
    let args;
    switch (token.type) {
      case TOK_LITERAL:
        return { type: 'Literal', value: token.value };
      case TOK_NUMBER:
        return { type: 'Number', value: token.value };
      case TOK_UNQUOTEDIDENTIFIER:
        return { type: 'Field', name: token.value };
      case TOK_QUOTEDIDENTIFIER:
        node = { type: 'Field', name: token.value };
        if (this._lookahead(0) === TOK_LPAREN) {
          throw new Error('Quoted identifier not allowed for function names.');
        }
        return node;
      case TOK_NOT:
        right = this.expression(bindingPower.Not);
        return { type: 'NotExpression', children: [right] };
      case TOK_UNARY_MINUS:
        right = this.expression(bindingPower.UnaryMinus);
        return { type: 'UnaryMinusExpression', children: [right] };
      case TOK_STAR:
        left = { type: 'Identity' };
        if (this._lookahead(0) === TOK_RBRACKET) {
          right = { type: 'Identity' };
        } else {
          right = this._parseProjectionRHS(bindingPower.Star);
        }
        return { type: 'ValueProjection', children: [left, right] };
      case TOK_FILTER:
        return this.led(token.type, { type: 'Identity' });
      case TOK_LBRACE:
        return this._parseMultiselectHash();
      case TOK_FLATTEN:
        left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };
        right = this._parseProjectionRHS(bindingPower.Flatten);
        return { type: 'Projection', children: [left, right] };
      case TOK_LBRACKET:
        if (this._lookahead(0) === TOK_STAR
            && this._lookahead(1) === TOK_RBRACKET) {
          this._advance();
          this._advance();
          right = this._parseProjectionRHS(bindingPower.Star);
          return {
            type: 'Projection',
            children: [{ type: 'Identity' }, right],
          };
        }
        return this._parseUnchainedIndexExpression();
      case TOK_CURRENT:
        return { type: TOK_CURRENT };
      case TOK_GLOBAL:
        return { type: TOK_GLOBAL, name: token.name };
      case TOK_FIELD:
        return { type: TOK_FIELD };
      case TOK_EXPREF:
        expression = this.expression(bindingPower.Expref);
        return { type: 'ExpressionReference', children: [expression] };
      case TOK_LPAREN:
        args = [];
        while (this._lookahead(0) !== TOK_RPAREN) {
          expression = this.expression(0);
          args.push(expression);
        }
        this._match(TOK_RPAREN);
        return args[0];
      default:
        this._errorToken(token);
    }
  }
  led(tokenName, left) {
    let condition;
    let right;
    let name;
    let args;
    let expression;
    let node;
    let rbp;
    let leftNode;
    let rightNode;
    switch (tokenName) {
      case TOK_CONCATENATE:
        right = this.expression(bindingPower.Concatenate);
        return { type: 'ConcatenateExpression', children: [left, right] };
      case TOK_DOT:
        rbp = bindingPower.Dot;
        if (this._lookahead(0) !== TOK_STAR) {
          right = this._parseDotRHS(rbp);
          return { type: 'Subexpression', children: [left, right] };
        }
        this._advance();
        right = this._parseProjectionRHS(rbp);
        return { type: 'ValueProjection', children: [left, right] };
      case TOK_PIPE:
        right = this.expression(bindingPower.Pipe);
        return { type: TOK_PIPE, children: [left, right] };
      case TOK_OR:
        right = this.expression(bindingPower.Or);
        return { type: 'OrExpression', children: [left, right] };
      case TOK_AND:
        right = this.expression(bindingPower.And);
        return { type: 'AndExpression', children: [left, right] };
      case TOK_ADD:
        right = this.expression(bindingPower.Add);
        return { type: 'AddExpression', children: [left, right] };
      case TOK_SUBTRACT:
        right = this.expression(bindingPower.Subtract);
        return { type: 'SubtractExpression', children: [left, right] };
      case TOK_MULTIPLY:
        right = this.expression(bindingPower.Multiply);
        return { type: 'MultiplyExpression', children: [left, right] };
      case TOK_DIVIDE:
        right = this.expression(bindingPower.Divide);
        return { type: 'DivideExpression', children: [left, right] };
      case TOK_POWER:
        right = this.expression(bindingPower.Power);
        return { type: 'PowerExpression', children: [left, right] };
      case TOK_UNION:
        right = this.expression(bindingPower.Power);
        return { type: 'UnionExpression', children: [left, right] };
      case TOK_LPAREN:
        name = left.name;
        args = [];
        while (this._lookahead(0) !== TOK_RPAREN) {
          expression = this.expression(0);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          }
          args.push(expression);
        }
        this._match(TOK_RPAREN);
        node = { type: 'Function', name, children: args };
        return node;
      case TOK_FILTER:
        condition = this.expression(0);
        this._match(TOK_RBRACKET);
        if (this._lookahead(0) === TOK_FLATTEN) {
          right = { type: 'Identity' };
        } else {
          right = this._parseProjectionRHS(bindingPower.Filter);
        }
        return { type: 'FilterProjection', children: [left, right, condition] };
      case TOK_FLATTEN:
        leftNode = { type: TOK_FLATTEN, children: [left] };
        rightNode = this._parseProjectionRHS(bindingPower.Flatten);
        return { type: 'Projection', children: [leftNode, rightNode] };
      case TOK_EQ:
      case TOK_NE:
      case TOK_GT:
      case TOK_GTE:
      case TOK_LT:
      case TOK_LTE:
        return this._parseComparator(left, tokenName);
      case TOK_LBRACKET:
        if (this._lookahead(0) === TOK_STAR
            && this._lookahead(1) === TOK_RBRACKET) {
          this._advance();
          this._advance();
          right = this._parseProjectionRHS(bindingPower.Star);
          return { type: 'Projection', children: [left, right] };
        }
        right = this._parseChainedIndexExpression();
        return this._projectIfSlice(left, right);
      default:
        this._errorToken(this._lookaheadToken(0));
    }
  }
  _match(tokenType) {
    if (this._lookahead(0) === tokenType) {
      this._advance();
    } else {
      const t = this._lookaheadToken(0);
      const error = new Error(`Expected ${tokenType}, got: ${t.type}`);
      error.name = 'ParserError';
      throw error;
    }
  }
  _errorToken(token) {
    const error = new Error(`Invalid token (${
      token.type}): "${
      token.value}"`);
    error.name = 'ParserError';
    throw error;
  }
  _parseChainedIndexExpression() {
    const oldIndex = this._getIndex();
    if (this._lookahead(0) === TOK_COLON) {
      return this._parseSliceExpression();
    }
    const first = this.expression(0);
    const token = this._lookahead(0);
    if (token === TOK_COLON) {
      this._setIndex(oldIndex);
      return this._parseSliceExpression();
    }
    this._match(TOK_RBRACKET);
    return {
      type: 'Index',
      value: first,
    };
  }
  _parseUnchainedIndexExpression() {
    const oldIndex = this._getIndex();
    const firstToken = this._lookahead(0);
    if (firstToken === TOK_COLON) {
      const right = this._parseSliceExpression();
      return this._projectIfSlice({ type: 'Identity' }, right);
    }
    const first = this.expression(0);
    const currentToken = this._lookahead(0);
    if (currentToken === TOK_COMMA) {
      this._setIndex(oldIndex);
      return this._parseMultiselectList();
    }
    if (currentToken === TOK_COLON) {
      this._setIndex(oldIndex);
      const right = this._parseSliceExpression();
      return this._projectIfSlice({ type: 'Identity' }, right);
    }
    if (firstToken === TOK_NUMBER || firstToken === TOK_UNARY_MINUS) {
      this._match(TOK_RBRACKET);
      return {
        type: 'Index',
        value: first,
      };
    }
    this._setIndex(oldIndex);
    return this._parseMultiselectList();
  }
  _projectIfSlice(left, right) {
    const indexExpr = { type: 'IndexExpression', children: [left, right] };
    if (right.type === 'Slice') {
      return {
        type: 'Projection',
        children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],
      };
    }
    return indexExpr;
  }
  _parseSliceExpression() {
    const parts = [null, null, null];
    let index = 0;
    let currentToken = this._lookahead(0);
    while (currentToken !== TOK_RBRACKET && index < 3) {
      if (currentToken === TOK_COLON && index < 2) {
        index += 1;
        this._advance();
      } else {
        parts[index] = this.expression(0);
        const t = this._lookahead(0);
        if (t !== TOK_COLON && t !== TOK_RBRACKET) {
          const error = new Error(`Syntax error, unexpected token: ${
            t.value}(${t.type})`);
          error.name = 'Parsererror';
          throw error;
        }
      }
      currentToken = this._lookahead(0);
    }
    this._match(TOK_RBRACKET);
    return {
      type: 'Slice',
      children: parts,
    };
  }
  _parseComparator(left, comparator) {
    const right = this.expression(bindingPower[comparator]);
    return { type: 'Comparator', name: comparator, children: [left, right] };
  }
  _parseDotRHS(rbp) {
    const lookahead = this._lookahead(0);
    const exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
    if (exprTokens.indexOf(lookahead) >= 0) {
      return this.expression(rbp);
    }
    if (lookahead === TOK_LBRACKET) {
      this._match(TOK_LBRACKET);
      return this._parseMultiselectList();
    }
    if (lookahead === TOK_LBRACE) {
      this._match(TOK_LBRACE);
      return this._parseMultiselectHash();
    }
  }
  _parseProjectionRHS(rbp) {
    let right;
    if (bindingPower[this._lookahead(0)] < 10) {
      right = { type: 'Identity' };
    } else if (this._lookahead(0) === TOK_LBRACKET) {
      right = this.expression(rbp);
    } else if (this._lookahead(0) === TOK_FILTER) {
      right = this.expression(rbp);
    } else if (this._lookahead(0) === TOK_DOT) {
      this._match(TOK_DOT);
      right = this._parseDotRHS(rbp);
    } else {
      const t = this._lookaheadToken(0);
      const error = new Error(`Sytanx error, unexpected token: ${
        t.value}(${t.type})`);
      error.name = 'ParserError';
      throw error;
    }
    return right;
  }
  _parseMultiselectList() {
    const expressions = [];
    while (this._lookahead(0) !== TOK_RBRACKET) {
      const expression = this.expression(0);
      expressions.push(expression);
      if (this._lookahead(0) === TOK_COMMA) {
        this._match(TOK_COMMA);
        if (this._lookahead(0) === TOK_RBRACKET) {
          throw new Error('Unexpected token Rbracket');
        }
      }
    }
    this._match(TOK_RBRACKET);
    return { type: 'MultiSelectList', children: expressions };
  }
  _parseMultiselectHash() {
    const pairs = [];
    const identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
    let keyToken; let keyName; let value; let
      node;
    if (this._lookahead(0) === TOK_RBRACE) {
      this._advance();
      return { type: 'MultiSelectHash', children: [] };
    }
    for (;;) {
      keyToken = this._lookaheadToken(0);
      if (identifierTypes.indexOf(keyToken.type) < 0) {
        throw new Error(`Expecting an identifier token, got: ${
          keyToken.type}`);
      }
      keyName = keyToken.value;
      this._advance();
      this._match(TOK_COLON);
      value = this.expression(0);
      node = { type: 'KeyValuePair', name: keyName, value };
      pairs.push(node);
      if (this._lookahead(0) === TOK_COMMA) {
        this._match(TOK_COMMA);
      } else if (this._lookahead(0) === TOK_RBRACE) {
        this._match(TOK_RBRACE);
        break;
      }
    }
    return { type: 'MultiSelectHash', children: pairs };
  }
}

function offsetMS(dateObj, timeZone) {
  const tzOffset = new Intl.DateTimeFormat('en-US', { timeZone, timeZoneName: 'longOffset' }).format(dateObj);
  const offset = /GMT([+\-−])?(\d{1,2}):?(\d{0,2})?/.exec(tzOffset);
  if (!offset) return 0;
  const [sign, hours, minutes] = offset.slice(1);
  const result = (((hours || 0) * 60) + 1 * (minutes || 0)) * 60 * 1000;
  return sign === '-' ? result * -1 : result;
}
function round(num, digits) {
  const precision = 10 ** digits;
  return Math.round(num * precision) / precision;
}
const MS_IN_DAY = 24 * 60 * 60 * 1000;
function adjustTimeZone(dateObj, timeZone) {
  if (dateObj === null) return null;
  let baseDate = Date.UTC(
    dateObj.getFullYear(),
    dateObj.getMonth(),
    dateObj.getDate(),
    dateObj.getHours(),
    dateObj.getMinutes(),
    dateObj.getSeconds(),
    dateObj.getMilliseconds(),
  );
  baseDate += offsetMS(dateObj, timeZone);
  return new Date(baseDate);
}
function openFormulaFunctions(valueOf, toString, toNumber, debug = []) {
  return {
    and: {
      _func: resolvedArgs => {
        let result = !!valueOf(resolvedArgs[0]);
        resolvedArgs.slice(1).forEach(arg => {
          result = result && !!valueOf(arg);
        });
        return result;
      },
      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],
    },
    casefold: {
      _func: (args, _data, interpreter) => {
        const str = toString(args[0]);
        return str.toLocaleUpperCase(interpreter.language).toLocaleLowerCase(interpreter.language);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    datedif: {
      _func: args => {
        const d1 = toNumber(args[0]);
        const d2 = toNumber(args[1]);
        const unit = toString(args[2]).toLowerCase();
        if (d2 === d1) return 0;
        if (d2 < d1) return null;
        if (unit === 'd') return Math.floor(d2 - d1);
        const date1 = new Date(d1 * MS_IN_DAY);
        const date2 = new Date(d2 * MS_IN_DAY);
        const yearDiff = date2.getFullYear() - date1.getFullYear();
        let monthDiff = date2.getMonth() - date1.getMonth();
        const dayDiff = date2.getDate() - date1.getDate();
        if (unit === 'y') {
          let y = yearDiff;
          if (monthDiff < 0) y -= 1;
          if (monthDiff === 0 && dayDiff < 0) y -= 1;
          return y;
        }
        if (unit === 'm') {
          return yearDiff * 12 + monthDiff + (dayDiff < 0 ? -1 : 0);
        }
        if (unit === 'ym') {
          if (dayDiff < 0) monthDiff -= 1;
          if (monthDiff <= 0 && yearDiff > 0) return 12 + monthDiff;
          return monthDiff;
        }
        if (unit === 'yd') {
          if (dayDiff < 0) monthDiff -= 1;
          if (monthDiff < 0) date2.setFullYear(date1.getFullYear() + 1);
          else date2.setFullYear(date1.getFullYear());
          return Math.floor((date2.getTime() - date1.getTime()) / MS_IN_DAY);
        }
        throw new TypeError(`Unrecognized unit parameter "${unit}" for datedif()`);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    datetime: {
      _func: args => {
        const year = toNumber(args[0]);
        const month = toNumber(args[1]);
        const day = toNumber(args[2]);
        const hours = args.length > 3 ? toNumber(args[3]) : 0;
        const minutes = args.length > 4 ? toNumber(args[4]) : 0;
        const seconds = args.length > 5 ? toNumber(args[5]) : 0;
        const ms = args.length > 6 ? toNumber(args[6]) : 0;
        const tz = args.length > 7 ? toString(args[7]) : null;
        let jsDate = new Date(year, month - 1, day, hours, minutes, seconds, ms);
        if (tz) {
          jsDate = adjustTimeZone(jsDate, tz);
        }
        return jsDate.getTime() / MS_IN_DAY;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
        { types: [dataTypes.TYPE_STRING], optional: true },
      ],
    },
    day: {
      _func: args => {
        const date = toNumber(args[0]);
        const jsDate = new Date(date * MS_IN_DAY);
        return jsDate.getDate();
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    deepScan: {
      _func: resolvedArgs => {
        const [source, n] = resolvedArgs;
        const name = n.toString();
        const items = [];
        if (source === null) return items;
        function scan(node) {
          Object.entries(node).forEach(([k, v]) => {
            if (k === name) items.push(v);
            if (typeof v === 'object') scan(v);
          });
        }
        scan(source);
        return items;
      },
      _signature: [
        { types: [dataTypes.TYPE_OBJECT, dataTypes.TYPE_ARRAY, dataTypes.TYPE_NULL] },
        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },
      ],
    },
    entries: {
      _func: args => {
        const obj = valueOf(args[0]);
        return Object.entries(obj);
      },
      _signature: [
        {
          types: [
            dataTypes.TYPE_NUMBER,
            dataTypes.TYPE_STRING,
            dataTypes.TYPE_ARRAY,
            dataTypes.TYPE_OBJECT,
            dataTypes.TYPE_BOOLEAN,
          ],
        },
      ],
    },
    eomonth: {
      _func: args => {
        const date = toNumber(args[0]);
        const months = toNumber(args[1]);
        const jsDate = new Date(date * MS_IN_DAY);
        const newDate = new Date(jsDate.getFullYear(), jsDate.getMonth() + months + 1, 0);
        return newDate.getTime() / MS_IN_DAY;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    exp: {
      _func: args => {
        const value = toNumber(args[0]);
        return Math.exp(value);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    false: {
      _func: () => false,
      _signature: [],
    },
    find: {
      _func: args => {
        const query = toString(args[0]);
        const text = toString(args[1]);
        const startPos = args.length > 2 ? toNumber(args[2]) : 0;
        const result = text.indexOf(query, startPos);
        if (result === -1) {
          return null;
        }
        return result;
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    fromEntries: {
      _func: args => {
        const array = args[0];
        return Object.fromEntries(array);
      },
      _signature: [
        { types: [dataTypes.TYPE_ARRAY_ARRAY] },
      ],
    },
    hour: {
      _func: args => {
        const time = toNumber(args[0]) % 1;
        if (time < 0) {
          return null;
        }
        const hour = round(time * 24, 14);
        return Math.floor(hour % 24);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    if: {
      _func: (unresolvedArgs, data, interpreter) => {
        const conditionNode = unresolvedArgs[0];
        const leftBranchNode = unresolvedArgs[1];
        const rightBranchNode = unresolvedArgs[2];
        const condition = interpreter.visit(conditionNode, data);
        if (valueOf(condition)) {
          return interpreter.visit(leftBranchNode, data);
        }
        return interpreter.visit(rightBranchNode, data);
      },
      _signature: [
        { types: [dataTypes.TYPE_ANY] },
        { types: [dataTypes.TYPE_ANY] },
        { types: [dataTypes.TYPE_ANY] }],
    },
    left: {
      _func: args => {
        const numEntries = args.length > 1 ? toNumber(args[1]) : 1;
        if (numEntries < 0) return null;
        if (args[0] instanceof Array) {
          return args[0].slice(0, numEntries);
        }
        const text = toString(args[0]);
        return text.substr(0, numEntries);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    lower: {
      _func: args => {
        const value = toString(args[0]);
        return value.toLowerCase();
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    mid: {
      _func: args => {
        const startPos = toNumber(args[1]);
        const numEntries = toNumber(args[2]);
        if (startPos < 0) return null;
        if (args[0] instanceof Array) {
          return args[0].slice(startPos, startPos + numEntries);
        }
        const text = toString(args[0]);
        return text.substr(startPos, numEntries);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    minute: {
      _func: args => {
        const time = toNumber(args[0]) % 1;
        if (time < 0) {
          return null;
        }
        const minute = Math.round(time * 1440, 10);
        return Math.floor(minute % 60);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    mod: {
      _func: args => {
        const p1 = toNumber(args[0]);
        const p2 = toNumber(args[1]);
        return p1 % p2;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    month: {
      _func: args => {
        const date = toNumber(args[0]);
        const jsDate = new Date(date * MS_IN_DAY);
        return jsDate.getMonth() + 1;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    not: {
      _func: resolveArgs => !valueOf(resolveArgs[0]),
      _signature: [{ types: [dataTypes.TYPE_ANY] }],
    },
    now: {
      _func: () => Date.now() / MS_IN_DAY,
      _signature: [],
    },
    null: {
      _func: () => null,
      _signature: [],
    },
    or: {
      _func: resolvedArgs => {
        let result = !!valueOf(resolvedArgs[0]);
        resolvedArgs.slice(1).forEach(arg => {
          result = result || !!valueOf(arg);
        });
        return result;
      },
      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],
    },
    power: {
      _func: args => {
        const base = toNumber(args[0]);
        const power = toNumber(args[1]);
        return base ** power;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    proper: {
      _func: args => {
        const text = toString(args[0]);
        const words = text.split(' ');
        const properWords = words.map(word => word.charAt(0).toUpperCase()
            + word.slice(1).toLowerCase());
        return properWords.join(' ');
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    replace: {
      _func: args => {
        const oldText = toString(args[0]);
        const startNum = toNumber(args[1]);
        const numChars = toNumber(args[2]);
        const newText = toString(args[3]);
        if (startNum < 0) {
          return null;
        }
        const lhs = oldText.substr(0, startNum);
        const rhs = oldText.substr(startNum + numChars);
        return lhs + newText + rhs;
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    rept: {
      _func: args => {
        const text = toString(args[0]);
        const count = toNumber(args[1]);
        if (count < 0) {
          return null;
        }
        return text.repeat(count);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    right: {
      _func: args => {
        const numEntries = args.length > 1 ? toNumber(args[1]) : 1;
        if (numEntries < 0) return null;
        if (args[0] instanceof Array) {
          if (numEntries === 0) return [];
          return args[0].slice(numEntries * -1);
        }
        const text = toString(args[0]);
        const start = text.length - numEntries;
        return text.substr(start, numEntries);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    round: {
      _func: args => {
        const number = toNumber(args[0]);
        const digits = toNumber(args[1]);
        return round(number, digits);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    search: {
      _func: args => {
        const findText = toString(args[0]);
        const withinText = toString(args[1]);
        const startPos = toNumber(args[2]);
        if (findText === null || withinText === null || withinText.length === 0) return [];
        const reString = findText.replace(/([[.\\^$()+{])/g, '\\$1')
          .replace(/~?\?/g, match => match === '~?' ? '\\?' : '.')
          .replace(/~?\*/g, match => match === '~*' ? '\\*' : '.*?')
          .replace(/~~/g, '~');
        const re = new RegExp(reString);
        const result = withinText.substring(startPos).match(re);
        if (result === null) return [];
        return [result.index + startPos, result[0]];
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    second: {
      _func: args => {
        const time = toNumber(args[0]) % 1;
        if (time < 0) {
          return null;
        }
        const seconds = round(time * 86400, 10);
        return Math.floor(seconds % 60);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    split: {
      _func: args => {
        const str = toString(args[0]);
        const separator = toString(args[1]);
        return str.split(separator);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    sqrt: {
      _func: args => {
        const result = Math.sqrt(toNumber(args[0]));
        if (Number.isNaN(result)) {
          return null;
        }
        return result;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    stdev: {
      _func: args => {
        const values = args[0] || [];
        if (values.length <= 1) {
          return null;
        }
        const coercedValues = values.map(value => toNumber(value));
        const mean = coercedValues.reduce((a, b) => a + b, 0) / values.length;
        const sumSquare = coercedValues.reduce((a, b) => a + b * b, 0);
        const result = Math.sqrt((sumSquare - values.length * mean * mean) / (values.length - 1));
        if (Number.isNaN(result)) {
          return null;
        }
        return result;
      },
      _signature: [
        { types: [dataTypes.TYPE_ARRAY_NUMBER] },
      ],
    },
    stdevp: {
      _func: args => {
        const values = args[0] || [];
        if (values.length === 0) {
          return null;
        }
        const coercedValues = values.map(value => toNumber(value));
        const mean = coercedValues.reduce((a, b) => a + b, 0) / values.length;
        const meanSumSquare = coercedValues.reduce((a, b) => a + b * b, 0) / values.length;
        const result = Math.sqrt(meanSumSquare - mean * mean);
        if (Number.isNaN(result)) {
          return null;
        }
        return result;
      },
      _signature: [
        { types: [dataTypes.TYPE_ARRAY_NUMBER] },
      ],
    },
    substitute: {
      _func: args => {
        const src = toString(args[0]);
        const old = toString(args[1]);
        const replacement = toString(args[2]);
        if (args.length <= 3) return src.replaceAll(old, replacement);
        const whch = toNumber(args[3]);
        if (whch < 1) return src;
        let pos = -1;
        for (let i = 0; i < whch; i += 1) {
          pos += 1;
          const nextFind = src.slice(pos).indexOf(old);
          if (nextFind === -1) return src;
          pos += nextFind;
        }
        return src.slice(0, pos) + src.slice(pos).replace(old, replacement);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_STRING] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    time: {
      _func: args => {
        const hours = toNumber(args[0]);
        const minutes = toNumber(args[1]);
        const seconds = toNumber(args[2]);
        const time = (hours * 3600 + minutes * 60 + seconds) / 86400;
        if (time < 0) {
          return null;
        }
        return time - Math.floor(time);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    today: {
      _func: () => Math.floor(Date.now() / MS_IN_DAY),
      _signature: [],
    },
    trim: {
      _func: args => {
        const text = toString(args[0]);
        return text.split(' ').filter(x => x).join(' ');
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    true: {
      _func: () => true,
      _signature: [],
    },
    trunc: {
      _func: args => {
        const number = toNumber(args[0]);
        const digits = args.length > 1 ? toNumber(args[1]) : 0;
        const method = number >= 0 ? Math.floor : Math.ceil;
        return method(number * 10 ** digits) / 10 ** digits;
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    unique: {
      _func: args => {
        const valueArray = args[0].map(a => valueOf(a));
        return args[0].filter((v, index) => valueArray.indexOf(valueOf(v)) === index);
      },
      _signature: [
        { types: [dataTypes.TYPE_ARRAY] },
      ],
    },
    upper: {
      _func: args => {
        const value = toString(args[0]);
        return value.toUpperCase();
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    value: {
      _func: args => {
        const obj = args[0] || {};
        const index = args[1];
        const result = obj[index];
        if (result === undefined) {
          debug.push(`Failed to find: '${index}'`);
          const available = Object.keys(obj).map(a => `'${a}'`).toString();
          if (available.length) debug.push(`Available fields: ${available}`);
          return null;
        }
        return result;
      },
      _signature: [
        { types: [dataTypes.TYPE_OBJECT, dataTypes.TYPE_ARRAY, dataTypes.TYPE_NULL] },
        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },
      ],
    },
    weekday: {
      _func: args => {
        const date = toNumber(args[0]);
        const type = args.length > 1 ? toNumber(args[1]) : 1;
        const jsDate = new Date(date * MS_IN_DAY);
        const day = jsDate.getDay();
        switch (type) {
          case 1:
            return day + 1;
          case 2:
            return ((day + 6) % 7) + 1;
          case 3:
            return (day + 6) % 7;
          default:
            return null;
        }
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
        { types: [dataTypes.TYPE_NUMBER], optional: true },
      ],
    },
    year: {
      _func: args => {
        const date = toNumber(args[0]);
        const jsDate = new Date(date * MS_IN_DAY);
        return jsDate.getFullYear();
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    charCode: {
      _func: args => {
        const code = toNumber(args[0]);
        if (!Number.isInteger(code)) {
          return null;
        }
        return String.fromCharCode(code);
      },
      _signature: [
        { types: [dataTypes.TYPE_NUMBER] },
      ],
    },
    codePoint: {
      _func: args => {
        const text = toString(args[0]);
        if (text.length === 0) {
          return null;
        }
        return text.codePointAt(0);
      },
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    encodeUrlComponent: {
      _func: args => encodeURIComponent(args[0]),
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    encodeUrl: {
      _func: args => encodeURI(args[0]),
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    decodeUrlComponent: {
      _func: args => decodeURIComponent(args[0]),
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
    decodeUrl: {
      _func: args => decodeURI(args[0]),
      _signature: [
        { types: [dataTypes.TYPE_STRING] },
      ],
    },
  };
}

function functions(
  runtime,
  isObject,
  isArray,
  toNumber,
  getTypeName,
  valueOf,
  toString,
  debug,
) {
  const {
    TYPE_NUMBER,
    TYPE_ANY,
    TYPE_STRING,
    TYPE_ARRAY,
    TYPE_OBJECT,
    TYPE_BOOLEAN,
    TYPE_EXPREF,
    TYPE_NULL,
    TYPE_ARRAY_NUMBER,
    TYPE_ARRAY_STRING,
  } = dataTypes;
  function createKeyFunction(exprefNode, allowedTypes) {
    return x => {
      const current = runtime.interpreter.visit(exprefNode, x);
      if (allowedTypes.indexOf(getTypeName(current)) < 0) {
        const msg = `TypeError: expected one of ${allowedTypes
        }, received ${getTypeName(current)}`;
        throw new Error(msg);
      }
      return current;
    };
  }
  const functionMap = {
    abs: {
      _func: resolvedArgs => Math.abs(resolvedArgs[0]),
      _signature: [{ types: [TYPE_NUMBER] }],
    },
    avg: {
      _func: resolvedArgs => {
        let sum = 0;
        const inputArray = resolvedArgs[0];
        inputArray.forEach(a => {
          sum += a;
        });
        return sum / inputArray.length;
      },
      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],
    },
    ceil: {
      _func: resolvedArgs => Math.ceil(resolvedArgs[0]),
      _signature: [{ types: [TYPE_NUMBER] }],
    },
    contains: {
      _func: resolvedArgs => valueOf(resolvedArgs[0]).indexOf(valueOf(resolvedArgs[1])) >= 0,
      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] },
        { types: [TYPE_ANY] }],
    },
    endsWith: {
      _func: resolvedArgs => {
        const searchStr = valueOf(resolvedArgs[0]);
        const suffix = valueOf(resolvedArgs[1]);
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
      },
      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],
    },
    floor: {
      _func: resolvedArgs => Math.floor(resolvedArgs[0]),
      _signature: [{ types: [TYPE_NUMBER] }],
    },
    join: {
      _func: resolvedArgs => {
        const joinChar = resolvedArgs[0];
        const listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
      },
      _signature: [
        { types: [TYPE_STRING] },
        { types: [TYPE_ARRAY_STRING] },
      ],
    },
    keys: {
      _func: resolvedArgs => {
        if (resolvedArgs[0] === null) return [];
        return Object.keys(resolvedArgs[0]);
      },
      _signature: [{ types: [TYPE_ANY] }],
    },
    length: {
      _func: resolvedArgs => {
        const arg = valueOf(resolvedArgs[0]);
        if (isObject(arg)) return Object.keys(arg).length;
        return isArray(arg) ? arg.length : toString(arg).length;
      },
      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],
    },
    map: {
      _func: resolvedArgs => {
        const exprefNode = resolvedArgs[0];
        return resolvedArgs[1].map(arg => runtime.interpreter.visit(exprefNode, arg));
      },
      _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }],
    },
    max: {
      _func: args => {
        const array = args.reduce((prev, cur) => {
          if (Array.isArray(cur)) prev.push(...cur);
          else prev.push(cur);
          return prev;
        }, []);
        const first = array.find(r => r !== null);
        if (array.length === 0 || first === undefined) return null;
        const isNumber = getTypeName(first, true) === TYPE_NUMBER;
        const compare = isNumber
          ? (prev, cur) => {
            const current = toNumber(cur);
            return prev <= current ? current : prev;
          }
          : (prev, cur) => {
            const current = toString(cur);
            return prev.localeCompare(current) === 1 ? prev : current;
          };
        return array.reduce(compare, isNumber ? toNumber(first) : toString(first));
      },
      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING], variadic: true }],
    },
    maxBy: {
      _func: resolvedArgs => {
        const exprefNode = resolvedArgs[1];
        const resolvedArray = resolvedArgs[0];
        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
        let maxNumber = -Infinity;
        let maxRecord;
        let current;
        resolvedArray.forEach(arg => {
          current = keyFunction(arg);
          if (current > maxNumber) {
            maxNumber = current;
            maxRecord = arg;
          }
        });
        return maxRecord;
      },
      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],
    },
    merge: {
      _func: resolvedArgs => {
        const merged = {};
        resolvedArgs.forEach(current => {
          Object.entries(current || {}).forEach(([key, value]) => {
            merged[key] = value;
          });
        });
        return merged;
      },
      _signature: [{ types: [TYPE_OBJECT], variadic: true }],
    },
    min: {
      _func: args => {
        const array = args.reduce((prev, cur) => {
          if (Array.isArray(cur)) prev.push(...cur);
          else prev.push(cur);
          return prev;
        }, []);
        const first = array.find(r => r !== null);
        if (array.length === 0 || first === undefined) return null;
        const isNumber = getTypeName(first, true) === TYPE_NUMBER;
        const compare = isNumber
          ? (prev, cur) => {
            const current = toNumber(cur);
            return prev <= current ? prev : current;
          }
          : (prev, cur) => {
            const current = toString(cur);
            return prev.localeCompare(current) === 1 ? current : prev;
          };
        return array.reduce(compare, isNumber ? toNumber(first) : toString(first));
      },
      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING], variadic: true }],
    },
    minBy: {
      _func: resolvedArgs => {
        const exprefNode = resolvedArgs[1];
        const resolvedArray = resolvedArgs[0];
        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
        let minNumber = Infinity;
        let minRecord;
        let current;
        resolvedArray.forEach(arg => {
          current = keyFunction(arg);
          if (current < minNumber) {
            minNumber = current;
            minRecord = arg;
          }
        });
        return minRecord;
      },
      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],
    },
    notNull: {
      _func: resolvedArgs => resolvedArgs.find(arg => getTypeName(arg) !== TYPE_NULL) || null,
      _signature: [{ types: [TYPE_ANY], variadic: true }],
    },
    reduce: {
      _func: resolvedArgs => {
        const exprefNode = resolvedArgs[0];
        return resolvedArgs[1].reduce(
          (accumulated, current, index, array) => runtime.interpreter.visit(exprefNode, {
            accumulated, current, index, array,
          }),
          resolvedArgs.length === 3 ? resolvedArgs[2] : null,
        );
      },
      _signature: [
        { types: [TYPE_EXPREF] },
        { types: [TYPE_ARRAY] },
        { types: [TYPE_ANY], optional: true },
      ],
    },
    register: {
      _func: resolvedArgs => {
        const functionName = resolvedArgs[0];
        const exprefNode = resolvedArgs[1];
        if (functionMap[functionName]) {
          debug.push(`Cannot re-register '${functionName}'`);
          return {};
        }
        functionMap[functionName] = {
          _func: args => runtime.interpreter.visit(exprefNode, ...args),
          _signature: [{ types: [TYPE_ANY], optional: true }],
        };
        return {};
      },
      _signature: [
        { types: [TYPE_STRING] },
        { types: [TYPE_EXPREF] },
      ],
    },
    reverse: {
      _func: resolvedArgs => {
        const originalStr = valueOf(resolvedArgs[0]);
        const typeName = getTypeName(originalStr);
        if (typeName === TYPE_STRING) {
          let reversedStr = '';
          for (let i = originalStr.length - 1; i >= 0; i -= 1) {
            reversedStr += originalStr[i];
          }
          return reversedStr;
        }
        const reversedArray = resolvedArgs[0].slice(0);
        reversedArray.reverse();
        return reversedArray;
      },
      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],
    },
    sort: {
      _func: resolvedArgs => {
        const sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length > 0) {
          const normalize = getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER ? toNumber : toString;
          sortedArray.sort((a, b) => {
            const va = normalize(a);
            const vb = normalize(b);
            if (va < vb) return -1;
            if (va > vb) return 1;
            return 0;
          });
        }
        return sortedArray;
      },
      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }],
    },
    sortBy: {
      _func: resolvedArgs => {
        const sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
          return sortedArray;
        }
        const exprefNode = resolvedArgs[1];
        const requiredType = getTypeName(
          runtime.interpreter.visit(exprefNode, sortedArray[0]),
        );
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
          throw new Error('TypeError');
        }
        const decorated = [];
        for (let i = 0; i < sortedArray.length; i += 1) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort((a, b) => {
          const exprA = runtime.interpreter.visit(exprefNode, a[1]);
          const exprB = runtime.interpreter.visit(exprefNode, b[1]);
          if (getTypeName(exprA) !== requiredType) {
            throw new Error(
              `TypeError: expected ${requiredType}, received ${
                getTypeName(exprA)}`,
            );
          } else if (getTypeName(exprB) !== requiredType) {
            throw new Error(
              `TypeError: expected ${requiredType}, received ${
                getTypeName(exprB)}`,
            );
          }
          if (exprA > exprB) {
            return 1;
          }
          if (exprA < exprB) {
            return -1;
          }
          return a[0] - b[0];
        });
        for (let j = 0; j < decorated.length; j += 1) {
          [, sortedArray[j]] = decorated[j];
        }
        return sortedArray;
      },
      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],
    },
    startsWith: {
      _func: resolvedArgs => valueOf(resolvedArgs[0]).startsWith(valueOf(resolvedArgs[1])),
      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],
    },
    sum: {
      _func: resolvedArgs => {
        let sum = 0;
        resolvedArgs[0].forEach(arg => {
          sum += arg * 1;
        });
        return sum;
      },
      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],
    },
    toArray: {
      _func: resolvedArgs => {
        if (getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
          return resolvedArgs[0];
        }
        return [resolvedArgs[0]];
      },
      _signature: [{ types: [TYPE_ANY] }],
    },
    toNumber: {
      _func: resolvedArgs => {
        const typeName = getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_NUMBER) {
          return resolvedArgs[0];
        }
        if (typeName === TYPE_STRING) {
          return toNumber(resolvedArgs[0]);
        }
        return null;
      },
      _signature: [{ types: [TYPE_ANY] }],
    },
    toString: {
      _func: resolvedArgs => {
        if (getTypeName(resolvedArgs[0]) === TYPE_STRING) {
          return resolvedArgs[0];
        }
        return JSON.stringify(resolvedArgs[0]);
      },
      _signature: [{ types: [TYPE_ANY] }],
    },
    type: {
      _func: resolvedArgs => ({
        [TYPE_NUMBER]: 'number',
        [TYPE_STRING]: 'string',
        [TYPE_ARRAY]: 'array',
        [TYPE_OBJECT]: 'object',
        [TYPE_BOOLEAN]: 'boolean',
        [TYPE_EXPREF]: 'expref',
        [TYPE_NULL]: 'null',
      }[getTypeName(resolvedArgs[0])]),
      _signature: [{ types: [TYPE_ANY] }],
    },
    values: {
      _func: resolvedArgs => {
        const arg = valueOf(resolvedArgs[0]);
        if (arg === null) return [];
        return Object.values(arg);
      },
      _signature: [{ types: [TYPE_ANY] }],
    },
    zip: {
      _func: args => {
        const count = args.reduce((min, current) => Math.min(min, current.length), args[0].length);
        const result = new Array(count);
        for (let i = 0; i < count; i += 1) {
          result[i] = [];
          args.forEach(a => {
            result[i].push(a[i]);
          });
        }
        return result;
      },
      _signature: [{ types: [TYPE_ARRAY], variadic: true }],
    },
  };
  return functionMap;
}

const {
  TYPE_CLASS,
  TYPE_ANY,
} = dataTypes;
function getToNumber(stringToNumber, debug = []) {
  return value => {
    const n = getValueOf(value);
    if (n === null) return null;
    if (n instanceof Array) {
      debug.push('Converted array to zero');
      return 0;
    }
    const type = typeof n;
    if (type === 'number') return n;
    if (type === 'string') return stringToNumber(n, debug);
    if (type === 'boolean') return n ? 1 : 0;
    debug.push('Converted object to zero');
    return 0;
  };
}
function toString(a) {
  if (a === null || a === undefined) return '';
  return a.toString();
}
const defaultStringToNumber = (str => {
  const n = +str;
  return Number.isNaN(n) ? 0 : n;
});
function isClass(obj) {
  if (obj === null) return false;
  if (Array.isArray(obj)) return false;
  return obj.constructor.name !== 'Object';
}
function matchClass(arg, expectedList) {
  return expectedList.includes(TYPE_CLASS) && isClass(arg);
}
class Runtime {
  constructor(debug, toNumber, customFunctions = {}) {
    this.strictDeepEqual = strictDeepEqual;
    this.toNumber = toNumber;
    this.functionTable = functions(
      this,
      isObject,
      isArray,
      toNumber,
      getTypeName,
      getValueOf,
      toString,
      debug,
    );
    Object.entries(
      openFormulaFunctions(getValueOf, toString, toNumber, debug),
    ).forEach(([fname, func]) => {
      this.functionTable[fname] = func;
    });
    Object.entries(customFunctions).forEach(([fname, func]) => {
      this.functionTable[fname] = func;
    });
  }
  _validateArgs(argName, args, signature, bResolved) {
    if (signature.length === 0) {
      return;
    }
    let pluralized;
    const argsNeeded = signature.filter(arg => !arg.optional).length;
    if (signature[signature.length - 1].variadic) {
      if (args.length < signature.length) {
        pluralized = signature.length === 1 ? ' argument' : ' arguments';
        throw new Error(`ArgumentError: ${argName}() `
        + `takes at least${signature.length}${pluralized
        } but received ${args.length}`);
      }
    } else if (args.length < argsNeeded || args.length > signature.length) {
      pluralized = signature.length === 1 ? ' argument' : ' arguments';
      throw new Error(`ArgumentError: ${argName}() `
      + `takes ${signature.length}${pluralized
      } but received ${args.length}`);
    }
    if (!bResolved) return;
    let currentSpec;
    let actualType;
    const limit = Math.min(signature.length, args.length);
    for (let i = 0; i < limit; i += 1) {
      currentSpec = signature[i].types;
      if (!matchClass(args[i], currentSpec) && !currentSpec.includes(TYPE_ANY)) {
        actualType = getTypeNames(args[i]);
        args[i] = matchType(actualType, currentSpec, args[i], argName, this.toNumber, toString);
      }
    }
  }
  callFunction(name, resolvedArgs, data, interpreter, bResolved = true) {
    if (!Object.prototype.hasOwnProperty.call(this.functionTable, name)) throw new Error(`Unknown function: ${name}()`);
    const functionEntry = this.functionTable[name];
    this._validateArgs(name, resolvedArgs, functionEntry._signature, bResolved);
    return functionEntry._func.call(this, resolvedArgs, data, interpreter);
  }
}
class Formula {
  constructor(debug, customFunctions, stringToNumberFn) {
    this.debug = debug;
    this.toNumber = getToNumber(stringToNumberFn || defaultStringToNumber, debug);
    this.runtime = new Runtime(debug, this.toNumber, customFunctions);
  }
  compile(stream, allowedGlobalNames = []) {
    let ast;
    try {
      const parser = new Parser(allowedGlobalNames);
      ast = parser.parse(stream, this.debug);
    } catch (e) {
      this.debug.push(e.toString());
      throw e;
    }
    return ast;
  }
  search(node, data, globals = {}, language = 'en-US') {
    this.runtime.interpreter = new TreeInterpreter(
      this.runtime,
      globals,
      this.toNumber,
      toString,
      this.debug,
      language,
    );
    try {
      return this.runtime.interpreter.search(node, data);
    } catch (e) {
      this.debug.push(e.message || e.toString());
      throw e;
    }
  }
}

class JsonFormula {
  constructor(
    customFunctions = {},
    stringToNumber = null,
    debug = [],
  ) {
    this.customFunctions = { ...customFunctions };
    this.stringToNumber = stringToNumber;
    this.debug = debug;
    this.formula = new Formula(debug, customFunctions, stringToNumber);
  }
  search(expression, json, globals = {}, language = 'en-US') {
    const ast = this.compile(expression, Object.keys(globals));
    return this.run(ast, json, language, globals);
  }
  run(ast, json, language, globals) {
    return this.formula.search(
      ast,
      json,
      globals,
      language,
    );
  }
  compile(expression, allowedGlobalNames = []) {
    this.debug.length = 0;
    return this.formula.compile(expression, allowedGlobalNames);
  }
}

class RuleEngine {
    _context;
    _globalNames = [
        '$form',
        '$field',
        '$event'
    ];
    formulaEngine;
    debugInfo = [];
    constructor() {
        const customFunctions = FunctionRuntime.getFunctions();
        this.formulaEngine = new JsonFormula(customFunctions, undefined, this.debugInfo);
    }
    compileRule(rule) {
        return this.formulaEngine.compile(rule, this._globalNames);
    }
    execute(node, data, globals, useValueOf = false) {
        const oldContext = this._context;
        this._context = globals;
        let res = undefined;
        try {
            res = this.formulaEngine.run(node, data, 'en-US', globals);
        }
        catch (err) {
            this._context?.form?.logger?.error(err);
        }
        while (this.debugInfo.length > 0) {
            this._context?.form?.logger?.debug(this.debugInfo.pop());
        }
        let finalRes = res;
        if (useValueOf) {
            if (typeof res === 'object' && res !== null) {
                finalRes = Object.getPrototypeOf(res).valueOf.call(res);
            }
        }
        this._context = oldContext;
        return finalRes;
    }
    trackDependency(subscriber) {
        if (this._context && this._context.field !== undefined && this._context.field !== subscriber) {
            subscriber._addDependent(this._context.field);
        }
    }
}

const defaults = {
    visible: true,
    enabled: true
};
class Fieldset extends Container {
    constructor(params, _options) {
        super(params, _options);
        this._applyDefaults();
        this.queueEvent(new Initialize());
        this.queueEvent(new ExecuteRule());
    }
    _applyDefaults() {
        Object.entries(defaults).map(([key, value]) => {
            if (this._jsonModel[key] === undefined) {
                this._jsonModel[key] = value;
            }
        });
        if (this._jsonModel.dataRef && this._jsonModel.type === undefined) {
            this._jsonModel.type = 'object';
        }
    }
    get type() {
        const ret = super.type;
        if (ret === 'array' || ret === 'object') {
            return ret;
        }
        return undefined;
    }
    get items() {
        return super.items;
    }
    get value() {
        return null;
    }
    get fieldType() {
        return 'panel';
    }
    get enabled() {
        return this._jsonModel.enabled;
    }
    set enabled(e) {
        this._setProperty('enabled', e);
    }
}

class InstanceManager extends Fieldset {
    get maxOccur() {
        return this._jsonModel.maxItems;
    }
    set maxOccur(m) {
        this.maxItems = m;
    }
    get minOccur() {
        return this.minItems;
    }
    addInstance(action) {
        return this.addItem(action);
    }
    removeInstance(action) {
        return this.removeItem(action);
    }
}
__decorate([
    dependencyTracked()
], InstanceManager.prototype, "maxOccur", null);
__decorate([
    dependencyTracked()
], InstanceManager.prototype, "minOccur", null);

class ValidationError {
    fieldName;
    errorMessages;
    constructor(fieldName = '', errorMessages = []) {
        this.errorMessages = errorMessages;
        this.fieldName = fieldName;
    }
}

const dateRegex = /^(\d{4})-(\d{1,2})-(\d{1,2})$/;
const days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const daysInMonth = (leapYear, month) => {
    if (leapYear && month == 2) {
        return 29;
    }
    return days[month - 1];
};
const isLeapYear = (year) => {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
};
const coerceType = (param, type) => {
    let num;
    switch (type) {
        case 'string':
            return param + '';
        case 'number':
            num = +param;
            if (!isNaN(num)) {
                return num;
            }
            break;
        case 'boolean':
            if (typeof param === 'string') {
                return param === 'true';
            }
            else if (typeof param === 'number') {
                return param !== 0;
            }
    }
    throw `${param} has invalid type. Expected : ${type}, Actual ${typeof param}`;
};
const checkNumber = (inputVal) => {
    if (inputVal === '' || inputVal == null) {
        return {
            value: '', valid: true
        };
    }
    let value = parseFloat(inputVal);
    const valid = !isNaN(value);
    if (!valid) {
        value = inputVal;
    }
    return {
        value, valid
    };
};
const checkInteger = (inputVal) => {
    if (inputVal == '' || inputVal == null) {
        return {
            value: '', valid: true
        };
    }
    let value = parseFloat(inputVal);
    const valid = !isNaN(value) && Math.round(value) === value;
    if (!valid) {
        value = inputVal;
    }
    return {
        value, valid
    };
};
const toArray = (inputVal) => {
    if (inputVal != null && !(inputVal instanceof Array)) {
        return [inputVal];
    }
    return inputVal;
};
const checkBool = (inputVal) => {
    const valid = typeof inputVal === 'boolean' || inputVal === 'true' || inputVal === 'false';
    const value = typeof inputVal === 'boolean' ? inputVal : (valid ? inputVal === 'true' : inputVal);
    return { valid, value };
};
const checkFile = (inputVal) => {
    const value = extractFileInfo(inputVal);
    const valid = value !== null;
    return {
        value: valid ? value : inputVal,
        valid
    };
};
const matchMediaType = (mediaType, accepts) => {
    return !mediaType || accepts.some((accept) => {
        const trimmedAccept = accept.trim();
        const prefixAccept = trimmedAccept.split('/')[0];
        const suffixAccept = trimmedAccept.split('.')[1];
        return ((trimmedAccept.includes('*') && mediaType.startsWith(prefixAccept)) ||
            (trimmedAccept.includes('.') && mediaType.endsWith(suffixAccept)) ||
            (trimmedAccept === mediaType));
    });
};
const partitionArray = (inputVal, validatorFn) => {
    const value = toArray(inputVal);
    if (value == null) {
        return [[], [value]];
    }
    return value.reduce((acc, x) => {
        if (acc[1].length == 0) {
            const r = validatorFn(x);
            const index = r.valid ? 0 : 1;
            acc[index].push(r.value);
        }
        return acc;
    }, [[], []]);
};
const ValidConstraints = {
    date: ['minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum', 'format'],
    string: ['minLength', 'maxLength', 'pattern'],
    number: ['minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum'],
    array: ['minItems', 'maxItems', 'uniqueItems'],
    file: ['accept', 'maxFileSize']
};
const Constraints = {
    type: (constraint, inputVal) => {
        let value = inputVal;
        if (inputVal == undefined) {
            return {
                valid: true,
                value: inputVal
            };
        }
        let valid = true, res;
        switch (constraint) {
            case 'string':
                valid = true;
                value = inputVal.toString();
                break;
            case 'string[]':
                value = toArray(inputVal);
                break;
            case 'number':
                res = checkNumber(inputVal);
                value = res.value;
                valid = res.valid;
                break;
            case 'boolean':
                res = checkBool(inputVal);
                valid = res.valid;
                value = res.value;
                break;
            case 'integer':
                res = checkInteger(inputVal);
                valid = res.valid;
                value = res.value;
                break;
            case 'integer[]':
                res = partitionArray(inputVal, checkInteger);
                valid = res[1].length === 0;
                value = valid ? res[0] : inputVal;
                break;
            case 'file':
                res = checkFile(inputVal instanceof Array ? inputVal[0] : inputVal);
                valid = res.valid;
                value = res.value;
                break;
            case 'file[]':
                res = partitionArray(inputVal, checkFile);
                valid = res[1].length === 0;
                value = valid ? res[0] : inputVal;
                break;
            case 'number[]':
                res = partitionArray(inputVal, checkNumber);
                valid = res[1].length === 0;
                value = valid ? res[0] : inputVal;
                break;
            case 'boolean[]':
                res = partitionArray(inputVal, checkBool);
                valid = res[1].length === 0;
                value = valid ? res[0] : inputVal;
                break;
        }
        return {
            valid,
            value
        };
    },
    format: (constraint, input) => {
        let valid = true;
        const value = input;
        if (input === null) {
            return { value, valid };
        }
        let res;
        switch (constraint) {
            case 'date':
                res = dateRegex.exec((input || '').trim());
                if (res != null) {
                    const [match, year, month, date] = res;
                    const [nMonth, nDate] = [+month, +date];
                    const leapYear = isLeapYear(+year);
                    valid = (nMonth >= 1 && nMonth <= 12) &&
                        (nDate >= 1 && nDate <= daysInMonth(leapYear, nMonth));
                }
                else {
                    valid = false;
                }
                break;
            case 'data-url':
                valid = true;
                break;
        }
        return { valid, value };
    },
    minimum: (constraint, value) => {
        return { valid: value >= constraint, value };
    },
    maximum: (constraint, value) => {
        return { valid: value <= constraint, value };
    },
    exclusiveMinimum: (constraint, value) => {
        return { valid: value > constraint, value };
    },
    exclusiveMaximum: (constraint, value) => {
        return { valid: value < constraint, value };
    },
    minItems: (constraint, value) => {
        return { valid: (value instanceof Array) && value.length >= constraint, value };
    },
    maxItems: (constraint, value) => {
        return { valid: (value instanceof Array) && value.length <= constraint, value };
    },
    uniqueItems: (constraint, value) => {
        return { valid: !constraint || ((value instanceof Array) && value.length === new Set(value).size), value };
    },
    minLength: (constraint, value) => {
        return { ...Constraints.minimum(constraint, typeof value === 'string' ? value.length : 0), value };
    },
    maxLength: (constraint, value) => {
        return { ...Constraints.maximum(constraint, typeof value === 'string' ? value.length : 0), value };
    },
    pattern: (constraint, value) => {
        let regex;
        if (typeof constraint === 'string') {
            regex = new RegExp(constraint);
        }
        else {
            regex = constraint;
        }
        return { valid: regex.test(value), value };
    },
    required: (constraint, value) => {
        const valid = constraint ? value != null && value !== '' : true;
        return { valid, value };
    },
    enum: (constraint, value) => {
        return {
            valid: constraint.indexOf(value) > -1,
            value
        };
    },
    accept: (constraint, value) => {
        if (!constraint || constraint.length === 0 || value === null || value === undefined) {
            return {
                valid: true,
                value
            };
        }
        const tempValue = value instanceof Array ? value : [value];
        const invalidFile = tempValue.some((file) => !matchMediaType(file.type, constraint));
        return {
            valid: !invalidFile,
            value
        };
    },
    maxFileSize: (constraint, value) => {
        const sizeLimit = typeof constraint === 'string' ? getFileSizeInBytes(constraint) : constraint;
        return {
            valid: !(value instanceof FileObject) || value.size <= sizeLimit,
            value
        };
    }
};

const DATE_TIME_REGEX =
    /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvV]{1,5}|[zZOvVxX]{1,3}|S{1,3}|'(?:[^']|'')*')|[^a-zA-Z']+/g;
const ShorthandStyles$1 = ["full", "long", "medium", "short"];
function getSkeleton(skeleton, language) {
    if (ShorthandStyles$1.find(type => skeleton.includes(type))) {
        const parsed = parseDateStyle(skeleton, language);
        const result = [];
        const symbols = {
            month : 'M',
            year : 'Y',
            day : 'd'
        };
        parsed.forEach(([type, option, length]) => {
            if (type in symbols) {
                result.push(Array(length).fill(symbols[type]).join(''));
            } else if (type === 'literal') {
                result.push(option);
            }
        });
        return result.join('');
    }
    return skeleton;
}
function parseDateStyle(skeleton, language) {
    const options = {};
    const styles = skeleton.split(/\s/).filter(s => s.length);
    options.dateStyle = styles[0];
    if (styles.length > 1) options.timeStyle = styles[1];
    const testDate = new Date(2000, 2, 1, 2, 3, 4);
    const parts = new Intl.DateTimeFormat(language, options).formatToParts(testDate);
    const formattedMarch = parts.find(p => p.type === 'month').value;
    const longMarch = new Intl.DateTimeFormat(language, {month: 'long'}).formatToParts(testDate)[0].value;
    const shortMarch = new Intl.DateTimeFormat(language, {month: 'short'}).formatToParts(testDate)[0].value;
    const result = [];
    parts.forEach(({type, value}) => {
        let option;
        if (type === 'month') {
            option = {
                [formattedMarch]: skeleton === 'medium' ? 'short' : 'long',
                [longMarch]: 'long',
                [shortMarch]: 'short',
                '03': '2-digit',
                '3': 'numeric'
            }[value];
        }
        if (type === 'year') option = {'2000': 'numeric', '00': '2-digit'}[value];
        if (['day', 'hour', 'minute', 'second'].includes(type)) option = value.length === 2 ? '2-digit' : 'numeric';
        if (type === 'literal') option = value;
        if (type === 'dayPeriod') option = 'short';
        result.push([type, option, value.length]);
    });
    return result;
}
function parseDateTimeSkeleton(skeleton, language) {
    if (ShorthandStyles$1.find(type => skeleton.includes(type))) {
        return parseDateStyle(skeleton, language);
    }
    const result = [];
    skeleton.replace(DATE_TIME_REGEX, match => {
        const len = match.length;
        switch (match[0]) {
            case 'G':
                result.push(['era', len === 4 ? 'long' : len === 5 ? 'narrow' : 'short', len]);
                break;
            case 'y':
                result.push(['year', len === 2 ? '2-digit' : 'numeric', len]);
                break;
            case 'Y':
            case 'u':
            case 'U':
            case 'r':
                throw new RangeError(
                    '`Y/u/U/r` (year) patterns are not supported, use `y` instead'
                );
            case 'q':
            case 'Q':
                throw new RangeError('`q/Q` (quarter) patterns are not supported');
            case 'M':
            case 'L':
                result.push(['month', ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1], len]);
                break;
            case 'w':
            case 'W':
                throw new RangeError('`w/W` (week) patterns are not supported');
            case 'd':
                result.push(['day', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'D':
            case 'F':
            case 'g':
                throw new RangeError(
                    '`D/F/g` (day) patterns are not supported, use `d` instead'
                );
            case 'E':
                result.push(['weekday', ['short', 'short', 'short', 'long', 'narrow', 'narrow'][len - 1], len]);
                break;
            case 'e':
                if (len < 4) {
                    throw new RangeError('`e..eee` (weekday) patterns are not supported');
                }
                result.push(['weekday', ['short', 'long', 'narrow', 'short'][len - 4], len]);
                break;
            case 'c':
                if (len < 3 || len > 5) {
                    throw new RangeError('`c, cc, cccccc` (weekday) patterns are not supported');
                }
                result.push(['weekday', ['short', 'long', 'narrow', 'short'][len - 3], len]);
                break;
            case 'a':
                result.push(['hour12', true, 1]);
                break;
            case 'b':
            case 'B':
                throw new RangeError(
                    '`b/B` (period) patterns are not supported, use `a` instead'
                );
            case 'h':
                result.push(['hourCycle', 'h12']);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'H':
                result.push(['hourCycle', 'h23', 1]);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'K':
                result.push(['hourCycle', 'h11', 1]);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'k':
                result.push(['hourCycle', 'h24', 1]);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'j':
            case 'J':
            case 'C':
                throw new RangeError(
                    '`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead'
                );
            case 'm':
                result.push(['minute', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 's':
                result.push(['second', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'S':
                result.push(['fractionalSecondDigits', len, len]);
                break;
            case 'A':
                throw new RangeError(
                    '`S/A` (millisecond) patterns are not supported, use `s` instead'
                );
            case 'O':
                result.push(['timeZoneName', len < 4 ? 'shortOffset' : 'longOffset', len]);
                result.push(['x-timeZoneName', len < 4 ? 'O' : 'OOOO', len]);
                break;
            case 'X':
            case 'x':
            case 'Z':
                result.push(['timeZoneName', 'longOffset', 1]);
                result.push(['x-timeZoneName', match, 1]);
                break;
            case 'z':
            case 'v':
            case 'V':
                throw new RangeError(
                    'z/v/V` (timeZone) patterns are not supported, use `X/x/Z/O` instead'
                );
            case '\'':
                result.push(['literal', match.slice(1, -1).replace(/''/g, '\''), -1]);
                break;
            default:
                result.push(['literal', match, -1]);
        }
        return '';
    });
    return result;
}

function fixDigits(formattedParts, parsed) {
    ['hour', 'minute', 'second'].forEach(type => {
        const defn = formattedParts.find(f => f.type === type);
        if (!defn) return;
        const fmt = parsed.find(pair => pair[0] === type)[1];
        if (fmt === '2-digit' && defn.value.length === 1) defn.value = `0${defn.value}`;
        if (fmt === 'numeric' && defn.value.length === 2 && defn.value.charAt(0) === '0') defn.value = defn.value.slice(1);
    });
}
function fixYear(formattedParts, parsed) {
    const defn = formattedParts.find(f => f.type === 'year');
    if (!defn) return;
    const chars = parsed.find(pair => pair[0] === 'year')[2];
    while(defn.value.length < chars) {
        defn.value = `0${defn.value}`;
    }
}
function formatDateToParts(dateValue, language, skeleton, timeZone) {
    const mappings = key => ({
        hour12: 'dayPeriod',
        fractionalSecondDigits: 'fractionalSecond',
    })[key] || key;
    const allParameters = parseDateTimeSkeleton(skeleton, language);
    allParameters.push(['timeZone', timeZone]);
    const parsed = allParameters.filter(p => !p[0].startsWith('x-'));
    const nonStandard = allParameters.filter(p => p[0].startsWith('x-'));
    const options = Object.fromEntries(parsed);
    delete options.literal;
    const df = new Intl.DateTimeFormat(language, options);
    const formattedParts = df.formatToParts(dateValue);
    fixDigits(formattedParts, allParameters);
    fixYear(formattedParts, parsed);
    return parsed.reduce((result, cur) => {
        if (cur[0] === 'literal') result.push(cur);
        else {
            const v = formattedParts.find(p => p.type === mappings(cur[0]));
            if (v && v.type === 'timeZoneName') {
                const tz = nonStandard.find(p => p[0] === 'x-timeZoneName')[1];
                const category = tz[0];
                if (category === 'Z') {
                    if (tz.length < 4) {
                        v.value = v.value.replace(/(GMT|:)/g, '');
                        if (v.value === '') v.value = '+0000';
                    } else if (tz.length === 5) {
                        if (v.value === 'GMT') v.value = 'Z';
                        else v.value = v.value.replace(/GMT/, '');
                    }
                }
                if (category === 'X' || category === 'x') {
                    if (tz.length === 1) {
                        v.value = v.value.replace(/(GMT|:(00)?)/g, '');
                    }
                    if (tz.length === 2) {
                        v.value = v.value.replace(/(GMT|:)/g, '');
                    }
                    if (tz.length === 3) {
                        v.value = v.value.replace(/GMT/g, '');
                    }
                    if (category === 'X' && v.value === '') v.value = 'Z';
                } else if (tz === 'O') {
                    v.value = v.value.replace(/GMT/g, '').replace(/0(\d+):/, '$1:').replace(/:00/, '');
                    if (v.value === '') v.value = '+0';
                }
            }
            if (v) result.push([v.type, v.value]);
        }
        return result;
    }, []);
}
function formatDate(dateValue, language, skeleton, timeZone) {
    if (skeleton.startsWith('date|')) {
        skeleton = skeleton.split('|')[1];
    }
    if (ShorthandStyles$1.find(type => skeleton.includes(type))) {
        const options = {timeZone};
        const parts = skeleton.split(/\s/).filter(s => s.length);
        if (ShorthandStyles$1.indexOf(parts[0]) > -1) {
            options.dateStyle = parts[0];
        }
        if (parts.length > 1 && ShorthandStyles$1.indexOf(parts[1]) > -1) {
            options.timeStyle = parts[1];
        }
        return new Intl.DateTimeFormat(language, options).format(dateValue);
    }
    const parts = formatDateToParts(dateValue, language, skeleton, timeZone);
    return parts.map(p => p[1]).join('');
}

const currencies = {
  'da-DK': 'DKK',
  'de-DE': 'EUR',
  'en-US': 'USD',
  'en-GB': 'GBP',
  'es-ES': 'EUR',
  'fi-FI': 'EUR',
  'fr-FR': 'EUR',
  'it-IT': 'EUR',
  'ja-JP': 'JPY',
  'nb-NO': 'NOK',
  'nl-NL': 'EUR',
  'pt-BR': 'BRL',
  'sv-SE': 'SEK',
  'zh-CN': 'CNY',
  'zh-TW': 'TWD',
  'ko-KR': 'KRW',
  'cs-CZ': 'CZK',
  'pl-PL': 'PLN',
  'ru-RU': 'RUB',
  'tr-TR': 'TRY'
};
const locales = Object.keys(currencies);
const getCurrency = function (locale) {
  if (locales.indexOf(locale) > -1) {
    return currencies[locale]
  } else {
    const matchingLocale = locales.find(x => x.startsWith(locale));
    if (matchingLocale) {
      return currencies[matchingLocale]
    }
  }
  return ''
};

const NUMBER_REGEX =
    /(?:[#]+|[@]+(#+)?|[0]+|[,]|[.]|[-]|[+]|[%]|[¤]{1,4}(?:\/([a-zA-Z]{3}))?|[;]|[K]{1,2}|E{1,2}[+]?|'(?:[^']|'')*')|[^a-zA-Z']+/g;
const supportedUnits = ['acre', 'bit', 'byte', 'celsius', 'centimeter', 'day',
    'degree', 'fahrenheit', 'fluid-ounce', 'foot', 'gallon', 'gigabit',
    'gigabyte', 'gram', 'hectare', 'hour', 'inch', 'kilobit', 'kilobyte',
    'kilogram', 'kilometer', 'liter', 'megabit', 'megabyte', 'meter', 'mile',
    'mile-scandinavian', 'milliliter', 'millimeter', 'millisecond', 'minute', 'month',
    'ounce', 'percent', 'petabyte', 'pound', 'second', 'stone', 'terabit', 'terabyte', 'week', 'yard', 'year'].join('|');
const ShorthandStyles = [/^currency(?:\/([a-zA-Z]{3}))?$/, /^decimal$/, /^integer$/,  /^percent$/, new RegExp(`^unit\/(${supportedUnits})$`)];
function parseNumberSkeleton(skeleton, language) {
    const options = {};
    const order = [];
    let match, index;
    for (index = 0; index < ShorthandStyles.length && match == null; index++) {
        match = ShorthandStyles[index].exec(skeleton);
    }
    if (match) {
        switch(index) {
            case 1:
                options.style = 'currency';
                options.currencyDisplay = 'narrowSymbol';
                if (match[1]) {
                    options.currency = match[1];
                } else {
                    options.currency = getCurrency(language);
                }
                break;
            case 2:
                new Intl.NumberFormat(language, {}).resolvedOptions();
                options.minimumFractionDigits = options.minimumFractionDigits || 2;
                break;
            case 3:
                options.minimumFractionDigits = 0;
                options.maximumFractionDigits = 0;
                break;
            case 4:
                options.style = 'percent';
                options.maximumFractionDigits = 2;
                break;
            case 5:
                options.style = "unit";
                options.unitDisplay = "long";
                options.unit = match[1];
                break;
        }
        return {
            options,
            order
        }
    }
    options.useGrouping = false;
    options.minimumIntegerDigits = 1;
    options.maximumFractionDigits = 0;
    options.minimumFractionDigits = 0;
    skeleton.replace(NUMBER_REGEX, (match, maxSignificantDigits, currencySymbol, offset) => {
        const len = match.length;
        switch(match[0]) {
            case '#':
                order.push(['digit', len]);
                if (options?.decimal === true) {
                    options.maximumFractionDigits = options.minimumFractionDigits + len;
                }
                break;
            case '@':
                if (options?.minimumSignificantDigits) {
                    throw "@ symbol should occur together"
                }
                const hashes = maxSignificantDigits || "";
                order.push(['@', len - hashes.length]);
                options.minimumSignificantDigits = len - hashes.length;
                options.maximumSignificantDigits = len;
                order.push(['digit', hashes.length]);
                break;
            case ',':
                if (options?.decimal === true) {
                    throw "grouping character not supporting for fractions"
                }
                order.push(['group', 1]);
                options.useGrouping = 'auto';
                break;
            case '.':
                if (options?.decimal) {
                    console.error("only one decimal symbol is allowed");
                } else {
                    order.push(['decimal', 1]);
                    options.decimal = true;
                }
                break;
            case '0':
                order.push('0', len);
                if(options.minimumSignificantDigits || options.maximumSignificantDigits) {
                    throw "0 is not supported with @"
                }
                if (options?.decimal === true) {
                    options.minimumFractionDigits = len;
                    if (!options.maximumFractionDigits) {
                        options.maximumFractionDigits = len;
                    }
                } else {
                    options.minimumIntegerDigits = len;
                }
                break;
            case '-':
                if (offset !== 0) {
                    console.error("sign display is always in the beginning");
                }
                options.signDisplay = 'negative';
                order.push(['signDisplay', 1, '-']);
                break;
            case '+':
                if (offset !== 0 && order[order.length - 1][0] === 'E') {
                    console.error("sign display is always in the beginning");
                }
                if (offset === 0) {
                    options.signDisplay = 'always';
                }
                order.push(['signDisplay', 1, '+']);
                break;
            case '¤':
                if (offset !== 0 && offset !== skeleton.length - 1) {
                    console.error("currency display should be either in the beginning or at the end");
                } else {
                    options.style = 'currency';
                    options.currencyDisplay = ['symbol', 'code', 'name', 'narrowSymbol'][len - 1];
                    options.currency = currencySymbol || getCurrency(language);
                    order.push(['currency', len]);
                }
                break;
            case '%':
                if (offset !== 0 && offset !== skeleton.length - 1) {
                    console.error("percent display should be either in the beginning or at the end");
                } else {
                    order.push(['%', 1]);
                    options.style = 'percent';
                }
                break;
            case 'E':
                order.push(['E', len]);
                options.style = ['scientific','engineering'](len - 1);
                break;
            default:
                console.error("unknown chars" + match);
        }
    });
    return {
        options,
        order
    };
}

function formatNumber(numberValue, language, skeletn) {
    if (skeletn.startsWith('num|')) {
        skeletn = skel.split('|')[1];
    }
    if (!skeletn) return numberValue
    language = language || "en";
    const {options, order} = parseNumberSkeleton(skeletn, language);
    return new Intl.NumberFormat(language, options).format(numberValue);
}

const getCategory = function (skeleton) {
    const chkCategory = skeleton?.match(/^(?:(num|date)\|)?(.+)/);
    return [chkCategory?.[1], chkCategory?.[2]]
};
const format = function (value, locale, skeleton, timezone) {
    const [category, skelton] = getCategory(skeleton);
    switch (category) {
        case 'date':
            if (!(value instanceof Date)) {
                value = new Date(value);
            }
            return formatDate(value, locale, skelton, timezone)
        case 'num':
            return formatNumber(value, locale, skelton)
        default:
            throw `unable to deduce the format. The skeleton should be date|<format> for date formats and num|<format> for numbers`
    }
};

const validTypes = ['string', 'number', 'boolean', 'file', 'string[]', 'number[]', 'boolean[]', 'file[]', 'array', 'object'];
class Field extends Scriptable {
    constructor(params, _options) {
        super(params, _options);
        this._applyDefaults();
        this.queueEvent(new Initialize());
        this.queueEvent(new ExecuteRule());
    }
    _ruleNodeReference = [];
    _initialize() {
        super._initialize();
        this.setupRuleNode();
    }
    ruleNodeReference() {
        if (this.type?.endsWith('[]')) {
            this._ruleNodeReference = [];
        }
        else {
            this._ruleNodeReference = this;
        }
        return this._ruleNodeReference;
    }
    _getDefaults() {
        return {
            readOnly: false,
            enabled: true,
            visible: true,
            type: this._getFallbackType()
        };
    }
    _getFallbackType() {
        const type = this._jsonModel.type;
        let finalType = type;
        if (typeof type !== 'string' || validTypes.indexOf(type) === -1) {
            const _enum = this.enum;
            finalType = typeof (_enum?.[0]);
            if (finalType === 'undefined' && typeof this._jsonModel.default !== 'undefined') {
                if (this._jsonModel.default instanceof Array && this._jsonModel.default.length > 0) {
                    finalType = `${typeof (this._jsonModel.default[0])}[]`;
                }
                else {
                    finalType = typeof (this._jsonModel.default);
                }
            }
            if (finalType.indexOf('undefined') === 0) {
                const typeMappings = {
                    'text-input': 'string',
                    'multiline-input': 'string',
                    'number-input': 'number',
                    'date-input': 'string',
                    'plain-text': 'string',
                    'image': 'string',
                    'checkbox': 'boolean'
                };
                finalType = typeMappings[this.fieldType];
            }
        }
        return finalType;
    }
    _applyDefaults() {
        Object.entries(this._getDefaults()).map(([key, value]) => {
            if (this._jsonModel[key] === undefined && value !== undefined) {
                this._jsonModel[key] = value;
            }
        });
        this.coerceParam('required', 'boolean');
        this.coerceParam('readOnly', 'boolean');
        this.coerceParam('enabled', 'boolean');
        const type = this._jsonModel.type;
        if (typeof type !== 'string' || validTypes.indexOf(type) === -1) {
            this._jsonModel.type = this._getFallbackType();
        }
        if (['plain-text', 'image'].indexOf(this.fieldType) === -1) {
            this._jsonModel.value = undefined;
        }
        const value = this._jsonModel.value;
        if (value === undefined) {
            const typedRes = Constraints.type(this.getInternalType() || 'string', this._jsonModel.default);
            this._jsonModel.value = typedRes.value;
        }
        if (this._jsonModel.type !== 'string') {
            this.unset('emptyValue');
        }
        if (this._jsonModel.fieldType === undefined) {
            this.form.logger.error('fieldType property is mandatory. Please ensure all the fields have a fieldType');
            if (this._jsonModel.viewType) {
                if (this._jsonModel.viewType.startsWith('custom:')) {
                    this.form.logger.error('viewType property has been removed. For custom types, use :type property');
                }
                else {
                    this.form.logger.error('viewType property has been removed. Use fieldType property');
                }
                this._jsonModel.fieldType = this._jsonModel.viewType;
            }
            else {
                this._jsonModel.fieldType = defaultFieldTypes(this._jsonModel);
            }
        }
        if (this._jsonModel.enum === undefined) {
            const type = this._jsonModel.type;
            if (type === 'boolean') {
                this._jsonModel.enum = [true, false];
            }
        }
        else {
            if (typeof this._jsonModel.enumNames === 'undefined') {
                this._jsonModel.enumNames = this._jsonModel.enum.map(_ => _.toString());
            }
            while (this._jsonModel.enumNames.length < this._jsonModel.enum.length) {
                this._jsonModel.enumNames.push(this._jsonModel.enum[this._jsonModel.enumNames.length].toString());
            }
        }
        const props = ['minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum'];
        if (this._jsonModel.type !== 'string') {
            this.unset('format', 'pattern', 'minLength', 'maxLength');
        }
        else if (this._jsonModel.fieldType === 'date-input') {
            this._jsonModel.format = 'date';
        }
        this.coerceParam('minLength', 'number');
        this.coerceParam('maxLength', 'number');
        if (this._jsonModel.type !== 'number' && this._jsonModel.format !== 'date') {
            this.unset('step', ...props);
        }
        props.forEach(c => {
            this.coerceParam(c, this._jsonModel.type);
        });
        if (typeof this._jsonModel.step !== 'number') {
            this.coerceParam('step', 'number');
        }
    }
    unset(...props) {
        props.forEach(p => this._jsonModel[p] = undefined);
    }
    coerceParam(param, type) {
        const val = this._jsonModel[param];
        if (typeof val !== 'undefined' && typeof val !== type) {
            this.form.logger.info(`${param} is not of type ${type}. Trying to coerce.`);
            try {
                this._jsonModel[param] = coerceType(val, type);
            }
            catch (e) {
                this.form.logger.warn(e);
                this.unset(param);
            }
        }
    }
    get editFormat() {
        return this.withCategory(this._jsonModel.editFormat);
    }
    get displayFormat() {
        return this.withCategory(this._jsonModel.displayFormat);
    }
    get placeholder() {
        return this._jsonModel.placeholder;
    }
    get readOnly() {
        return this._jsonModel.readOnly;
    }
    set readOnly(e) {
        this._setProperty('readOnly', e);
    }
    get enabled() {
        return this._jsonModel.enabled;
    }
    set enabled(e) {
        this._setProperty('enabled', e);
    }
    get valid() {
        return this._jsonModel.valid;
    }
    get emptyValue() {
        if (this._jsonModel.emptyValue === 'null') {
            return null;
        }
        else if (this._jsonModel.emptyValue === '' && this.type === 'string') {
            return '';
        }
        else {
            return undefined;
        }
    }
    get enum() {
        return this._jsonModel.enum;
    }
    set enum(e) {
        this._setProperty('enum', e);
    }
    get enumNames() {
        return this._jsonModel.enumNames;
    }
    set enumNames(e) {
        this._setProperty('enumNames', e);
    }
    get required() {
        return this._jsonModel.required || false;
    }
    set required(r) {
        this._setProperty('required', r);
    }
    get maximum() {
        if (this.type === 'number' || this.format === 'date') {
            return this._jsonModel.maximum;
        }
    }
    set maximum(m) {
        if (this.type === 'number' || this.format === 'date') {
            this._setProperty('maximum', m);
        }
    }
    get minimum() {
        if (this.type === 'number' || this.format === 'date') {
            return this._jsonModel.minimum;
        }
    }
    set minimum(m) {
        if (this.type === 'number' || this.format === 'date') {
            this._setProperty('minimum', m);
        }
    }
    isEmpty() {
        return this._jsonModel.value === undefined || this._jsonModel.value === null || this._jsonModel.value === '';
    }
    withCategory(df) {
        if (df) {
            const hasCategory = df?.match(/^(?:date|num)\|/);
            if (hasCategory === null) {
                if (this.format === 'date') {
                    df = `date|${df}`;
                }
                else if (this.type === 'number') {
                    df = `num|${df}`;
                }
                return df;
            }
        }
        return df;
    }
    get editValue() {
        const df = this.editFormat;
        if (df && this.isNotEmpty(this.value) && this.valid !== false) {
            try {
                return format(this.value, this.language, df);
            }
            catch (e) {
                return this.value;
            }
        }
        else {
            return this.value;
        }
    }
    get displayValue() {
        const df = this.displayFormat;
        if (df && this.isNotEmpty(this.value) && this.valid !== false) {
            try {
                return format(this.value, this.language, df);
            }
            catch (e) {
                return this.value;
            }
        }
        else {
            return this.value;
        }
    }
    getDataNodeValue(typedValue) {
        return this.isEmpty() ? this.emptyValue : typedValue;
    }
    updateDataNodeAndTypedValue(val) {
        const dataNode = this.getDataNode();
        if (staticFields.indexOf(this.fieldType) > -1 && typeof dataNode !== 'undefined') {
            return;
        }
        const Constraints = this._getConstraintObject();
        const typeRes = Constraints.type(this.getInternalType() || 'string', val);
        const changes = this._setProperty('value', typeRes.value, false);
        if (changes.length > 0) {
            this._updateRuleNodeReference(typeRes.value);
            if (typeof dataNode !== 'undefined') {
                dataNode.setValue(this.getDataNodeValue(this._jsonModel.value), this._jsonModel.value, this);
            }
        }
        return changes;
    }
    get value() {
        if (this._jsonModel.value === undefined) {
            return null;
        }
        else {
            return this._jsonModel.value;
        }
    }
    set value(v) {
        const changes = this.updateDataNodeAndTypedValue(v);
        let uniqueRes = { valid: true };
        if (changes?.length > 0) {
            let updates = {};
            const typeRes = Constraints.type(this.getInternalType() || 'string', v);
            if (this.parent.uniqueItems && this.parent.type === 'array') {
                uniqueRes = Constraints.uniqueItems(this.parent.uniqueItems, this.parent.getDataNode().$value);
            }
            if (typeRes.valid && uniqueRes.valid) {
                updates = this.evaluateConstraints();
            }
            else {
                const changes = {
                    'valid': typeRes.valid && uniqueRes.valid,
                    'errorMessage': typeRes.valid && uniqueRes.valid ? '' : this.getErrorMessage('type')
                };
                updates = this._applyUpdates(['valid', 'errorMessage'], changes);
            }
            if (updates.valid) {
                this.triggerValidationEvent(updates);
            }
            const changeAction = new Change({ changes: changes.concat(Object.values(updates)) });
            this.dispatch(changeAction);
        }
    }
    reset() {
        const changes = this.updateDataNodeAndTypedValue(this.default);
        if (changes.length > 0) {
            const validationStateChanges = {
                'valid': undefined,
                'errorMessage': ''
            };
            const updates = this._applyUpdates(['valid', 'errorMessage'], validationStateChanges);
            const changeAction = new Change({ changes: changes.concat(Object.values(updates)) });
            this.dispatch(changeAction);
        }
    }
    _updateRuleNodeReference(value) {
        if (this.type?.endsWith('[]')) {
            if (value != null) {
                value.forEach((val, index) => {
                    this._ruleNodeReference[index] = val;
                });
                while (value.length !== this._ruleNodeReference.length) {
                    this._ruleNodeReference.pop();
                }
            }
            else {
                while (this._ruleNodeReference.length !== 0) {
                    this._ruleNodeReference.pop();
                }
            }
        }
    }
    getInternalType() {
        return this.type;
    }
    valueOf() {
        const obj = this[target];
        const actualField = obj === undefined ? this : obj;
        actualField.ruleEngine.trackDependency(actualField);
        return actualField._jsonModel.value || null;
    }
    toString() {
        const obj = this[target];
        const actualField = obj === undefined ? this : obj;
        return actualField._jsonModel.value?.toString() || '';
    }
    getErrorMessage(constraint) {
        return this._jsonModel.constraintMessages?.[constraint] || '';
    }
    get errorMessage() {
        return this._jsonModel.errorMessage;
    }
    get screenReaderText() {
        return this._jsonModel.screenReaderText;
    }
    _getConstraintObject() {
        return Constraints;
    }
    isArrayType() {
        return this.type ? this.type.indexOf('[]') > -1 : false;
    }
    checkEnum(value, constraints) {
        if (this._jsonModel.enforceEnum === true && value != null) {
            const fn = constraints.enum;
            if (value instanceof Array && this.isArrayType()) {
                return value.every(x => fn(this.enum || [], x).valid);
            }
            else {
                return fn(this.enum || [], value).valid;
            }
        }
        return true;
    }
    checkStep() {
        const value = this._jsonModel.value;
        const step = this._jsonModel.step;
        if (typeof step === 'number') {
            const prec = step.toString().split('.')?.[1]?.length || 0;
            const factor = Math.pow(10, prec);
            const fStep = step * factor;
            const fVal = value * factor;
            const iv = this._jsonModel.minimum || this._jsonModel.default || 0;
            const fIVal = iv * factor;
            const qt = (fVal - fIVal) / fStep;
            const valid = Math.abs(fVal - fIVal) % fStep < .001;
            let next, prev;
            if (!valid) {
                next = (Math.ceil(qt) * fStep + fIVal) / factor;
                prev = (next - fStep) / factor;
            }
            return {
                valid,
                next,
                prev
            };
        }
        return {
            valid: true
        };
    }
    checkValidationExpression() {
        if (typeof this._jsonModel.validationExpression === 'string') {
            return this.executeExpression(this._jsonModel.validationExpression);
        }
        return true;
    }
    getConstraints() {
        switch (this.type) {
            case 'string':
                switch (this.format) {
                    case 'date':
                        return ValidConstraints.date;
                    case 'binary':
                        return ValidConstraints.file;
                    case 'data-url':
                        return ValidConstraints.file;
                    default:
                        return ValidConstraints.string;
                }
            case 'file':
                return ValidConstraints.file;
            case 'number':
            case 'integer':
                return ValidConstraints.number;
        }
        if (this.isArrayType()) {
            return ValidConstraints.array;
        }
        return [];
    }
    get format() {
        if (typeof this._jsonModel.format === 'undefined') {
            if (this.type === 'string') {
                switch (this.fieldType) {
                    case 'date-input':
                        this._jsonModel.format = 'date';
                        break;
                    case 'file-input':
                        this._jsonModel.format = 'data-url';
                        break;
                }
            }
        }
        return this._jsonModel.format;
    }
    get enforceEnum() {
        return this._jsonModel.enforceEnum;
    }
    get tooltip() {
        return this._jsonModel.tooltip;
    }
    get maxLength() {
        return this._jsonModel.maxLength;
    }
    get minLength() {
        return this._jsonModel.minLength;
    }
    get pattern() {
        return this._jsonModel.pattern;
    }
    get step() {
        if (this.type === 'number' || this.format === 'date') {
            return this._jsonModel.step;
        }
    }
    get exclusiveMinimum() {
        if (this.type === 'number' || this.format === 'date') {
            return this._jsonModel.exclusiveMinimum;
        }
    }
    set exclusiveMinimum(eM) {
        if (this.type === 'number' || this.format === 'date') {
            this._jsonModel.exclusiveMinimum = eM;
        }
    }
    get exclusiveMaximum() {
        if (this.type === 'number' || this.format === 'date') {
            return this._jsonModel.exclusiveMaximum;
        }
    }
    set exclusiveMaximum(eM) {
        if (this.type === 'number' || this.format === 'date') {
            this._jsonModel.exclusiveMaximum = eM;
        }
    }
    get default() {
        return this._jsonModel.default;
    }
    isNotEmpty(value) {
        return value != null && value !== '';
    }
    evaluateConstraints() {
        let constraint = 'type';
        const elem = this._jsonModel;
        const value = this._jsonModel.value;
        const Constraints = this._getConstraintObject();
        const supportedConstraints = this.getConstraints();
        let valid = true;
        if (valid) {
            valid = Constraints.required(this.required, value).valid &&
                (this.isArrayType() && this.required ? value.length > 0 : true);
            constraint = 'required';
        }
        if (valid && this.isNotEmpty(value)) {
            const invalidConstraint = supportedConstraints.find(key => {
                if (key in elem && elem[key] !== undefined) {
                    const restriction = elem[key];
                    const fn = Constraints[key];
                    if (value instanceof Array && this.isArrayType()) {
                        if (ValidConstraints.array.indexOf(key) !== -1) {
                            return !fn(restriction, value).valid;
                        }
                        else {
                            return value.some(x => !(fn(restriction, x).valid));
                        }
                    }
                    else if (typeof fn === 'function') {
                        return !fn(restriction, value).valid;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            });
            if (invalidConstraint != null) {
                valid = false;
                constraint = invalidConstraint;
            }
            else {
                valid = this.checkEnum(value, Constraints);
                constraint = 'enum';
                if (valid && this.type === 'number') {
                    valid = this.checkStep().valid;
                    constraint = 'step';
                }
                if (valid) {
                    valid = this.checkValidationExpression();
                    constraint = 'validationExpression';
                }
            }
        }
        if (!valid) {
            this.form.logger.info(`${constraint} constraint evaluation failed ${this._jsonModel[constraint]}. Received ${this._jsonModel.value}`);
        }
        const changes = {
            'valid': valid,
            'errorMessage': valid ? '' : this.getErrorMessage(constraint)
        };
        return this._applyUpdates(['valid', 'errorMessage'], changes);
    }
    triggerValidationEvent(changes) {
        if (changes.valid) {
            if (this.valid) {
                this.dispatch(new Valid());
            }
            else {
                this.dispatch(new Invalid());
            }
        }
    }
    validate() {
        const changes = this.evaluateConstraints();
        if (changes.valid) {
            this.triggerValidationEvent(changes);
            this.notifyDependents(new Change({ changes: Object.values(changes) }));
        }
        return this.valid ? [] : [new ValidationError(this.id, [this._jsonModel.errorMessage])];
    }
    importData(contextualDataModel) {
        this._bindToDataModel(contextualDataModel);
        const dataNode = this.getDataNode();
        if (dataNode !== undefined && dataNode !== NullDataValue && dataNode.$value !== this._jsonModel.value) {
            const changeAction = propertyChange('value', dataNode.$value, this._jsonModel.value);
            this._jsonModel.value = dataNode.$value;
            this.queueEvent(changeAction);
        }
    }
    defaultDataModel(name) {
        const value = staticFields.indexOf(this.fieldType) > -1 ? undefined : this.getDataNodeValue(this._jsonModel.value);
        return new DataValue(name, value, this.type || 'string');
    }
    getState() {
        return {
            ...super.getState(),
            editFormat: this.editFormat,
            displayFormat: this.displayFormat,
            editValue: this.editValue,
            displayValue: this.displayValue
        };
    }
}
__decorate([
    dependencyTracked(),
    exclude('button', 'image', 'plain-text')
], Field.prototype, "readOnly", null);
__decorate([
    dependencyTracked(),
    exclude('image', 'plain-text')
], Field.prototype, "enabled", null);
__decorate([
    dependencyTracked()
], Field.prototype, "valid", null);
__decorate([
    dependencyTracked()
], Field.prototype, "enum", null);
__decorate([
    dependencyTracked()
], Field.prototype, "enumNames", null);
__decorate([
    dependencyTracked()
], Field.prototype, "required", null);
__decorate([
    include('date-input', 'number-input')
], Field.prototype, "editValue", null);
__decorate([
    dependencyTracked()
], Field.prototype, "value", null);
__decorate([
    include('text-input', 'date-input', 'file-input')
], Field.prototype, "format", null);
__decorate([
    include('text-input')
], Field.prototype, "maxLength", null);
__decorate([
    include('text-input')
], Field.prototype, "minLength", null);
__decorate([
    include('text-input')
], Field.prototype, "pattern", null);
__decorate([
    dependencyTracked()
], Field.prototype, "exclusiveMinimum", null);
__decorate([
    dependencyTracked()
], Field.prototype, "exclusiveMaximum", null);

function addNameToDataURL(dataURL, name) {
    return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);
}
function processFiles(files) {
    return Promise.all([].map.call(files, processFile));
}
async function processFile(file) {
    const { name, size, type } = file;
    const fileObj = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = event => {
            resolve(new FileObject({
                data: addNameToDataURL(event.target.result, name),
                type,
                name,
                size
            }));
        };
        reader.readAsDataURL(file.data);
    });
    return fileObj;
}
class FileUpload extends Field {
    _getDefaults() {
        return {
            ...super._getDefaults(),
            accept: ['audio/*', 'video/*', 'image/*', 'text/*', 'application/pdf'],
            maxFileSize: '2MB'
        };
    }
    _getFallbackType() {
        return 'file';
    }
    get maxFileSize() {
        return getFileSizeInBytes(this._jsonModel.maxFileSize);
    }
    get accept() {
        return this._jsonModel.accept;
    }
    _applyUpdates(propNames, updates) {
        return propNames.reduce((acc, propertyName) => {
            const prevValue = this._jsonModel[propertyName];
            const currentValue = updates[propertyName];
            if (currentValue !== prevValue) {
                acc[propertyName] = {
                    propertyName,
                    currentValue,
                    prevValue
                };
                if (prevValue instanceof FileObject && typeof currentValue === 'object' && propertyName === 'value') {
                    this._jsonModel[propertyName] = new FileObject({ ...prevValue, ...{ 'data': currentValue.data } });
                }
                else {
                    this._jsonModel[propertyName] = currentValue;
                }
            }
            return acc;
        }, {});
    }
    getInternalType() {
        return this.type?.endsWith('[]') ? 'file[]' : 'file';
    }
    getDataNodeValue(typedValue) {
        let dataNodeValue = typedValue;
        if (dataNodeValue != null) {
            if (this.type === 'string') {
                dataNodeValue = dataNodeValue.data?.toString();
            }
            else if (this.type === 'string[]') {
                dataNodeValue = dataNodeValue instanceof Array ? dataNodeValue : [dataNodeValue];
                dataNodeValue = dataNodeValue.map((_) => _?.data?.toString());
            }
        }
        return dataNodeValue;
    }
    async _serialize() {
        const val = this._jsonModel.value;
        if (val === undefined) {
            return null;
        }
        const filesInfo = await processFiles(val instanceof Array ? val : [val]);
        return filesInfo;
    }
    importData(dataModel) {
        this._bindToDataModel(dataModel);
        const dataNode = this.getDataNode();
        if (dataNode !== undefined) {
            const value = dataNode?.$value;
            if (value != null) {
                const res = Constraints.type(this.getInternalType(), value);
                if (!res.valid) {
                    this.form.logger.error(`unable to bind ${this.name} to data`);
                }
                this.form.getEventQueue().queue(this, propertyChange('value', res.value, this._jsonModel.value));
                this._jsonModel.value = res.value;
            }
            else {
                this._jsonModel.value = null;
            }
        }
    }
}

const requiredConstraint = (offValue) => (constraint, value) => {
    const valid = Constraints.required(constraint, value).valid && (!constraint || value != offValue);
    return { valid, value };
};
class Checkbox extends Field {
    offValue() {
        const opts = this.enum;
        return opts.length > 1 ? opts[1] : null;
    }
    _getConstraintObject() {
        const baseConstraints = { ...super._getConstraintObject() };
        baseConstraints.required = requiredConstraint(this.offValue());
        return baseConstraints;
    }
    _getDefaults() {
        return {
            ...super._getDefaults(),
            enforceEnum: true
        };
    }
    get enum() {
        return this._jsonModel.enum || [];
    }
}

class CheckboxGroup extends Field {
    constructor(params, _options) {
        super(params, _options);
    }
    _getFallbackType() {
        const fallbackType = super._getFallbackType();
        if (typeof fallbackType === 'string') {
            return `${fallbackType}[]`;
        }
        else {
            return 'string[]';
        }
    }
    _getDefaults() {
        return {
            ...super._getDefaults(),
            enforceEnum: true,
            enum: []
        };
    }
}

class DateField extends Field {
    _applyDefaults() {
        super._applyDefaults();
        const locale = new Intl.DateTimeFormat().resolvedOptions().locale;
        if (!this._jsonModel.editFormat) {
            this._jsonModel.editFormat = 'short';
        }
        if (!this._jsonModel.displayFormat) {
            this._jsonModel.displayFormat = this._jsonModel.editFormat;
        }
        if (!this._jsonModel.placeholder) {
            this._jsonModel.placeholder = getSkeleton(this._jsonModel.editFormat, locale);
        }
        if (!this._jsonModel.description) {
            this._jsonModel.description = `To enter today's date use ${formatDate(new Date(), locale, this._jsonModel.editFormat)}`;
        }
    }
}

const alternateFieldTypeMapping = {
    'text': 'text-input',
    'number': 'number-input',
    'email': 'text-input',
    'file': 'file-input',
    'range': 'range',
    'textarea': 'multiline-input'
};
class FormFieldFactoryImpl {
    createField(child, _options) {
        let retVal;
        const options = {
            ..._options,
            fieldFactory: this
        };
        child.fieldType = child.fieldType ? (child.fieldType in alternateFieldTypeMapping ?
            alternateFieldTypeMapping[child.fieldType] : child.fieldType)
            : 'text-input';
        if (isRepeatable(child)) {
            const newChild = {
                ...child,
                ...('items' in child && { 'type': 'object' }),
                minOccur: undefined,
                maxOccur: undefined,
                repeatable: undefined,
                name: undefined
            };
            const newJson = {
                ...{
                    minItems: child.minOccur || 0,
                    maxItems: child.maxOccur || -1,
                    fieldType: child.fieldType,
                    type: 'array',
                    name: child.name,
                    dataRef: child.dataRef
                },
                ...{
                    'items': [newChild]
                }
            };
            retVal = new InstanceManager(newJson, options);
        }
        else if ('items' in child) {
            retVal = new Fieldset(child, options);
        }
        else {
            if (isFile(child) || child.fieldType === 'file-input') {
                retVal = new FileUpload(child, options);
            }
            else if (isCheckbox(child)) {
                retVal = new Checkbox(child, options);
            }
            else if (isCheckboxGroup(child)) {
                retVal = new CheckboxGroup(child, options);
            }
            else if (isDateField(child)) {
                retVal = new DateField(child, options);
            }
            else {
                retVal = new Field(child, options);
            }
        }
        return retVal;
    }
}
const FormFieldFactory = new FormFieldFactoryImpl();

const createFormInstance = (formModel, callback, logLevel = 'error', fModel = undefined) => {
    try {
        let f = fModel;
        if (f == null) {
            f = new Form({ ...formModel }, FormFieldFactory, new RuleEngine(), new EventQueue(new Logger(logLevel)), logLevel);
        }
        const formData = formModel?.data;
        if (formData) {
            f.importData(formData);
        }
        if (typeof callback === 'function') {
            callback(f);
        }
        f.getEventQueue().runPendingQueue();
        return f;
    }
    catch (e) {
        console.error(`Unable to create an instance of the Form ${e}`);
        throw new Error(e);
    }
};
const validateFormInstance = (formModel, data) => {
    try {
        const f = new Form({ ...formModel }, FormFieldFactory, new RuleEngine());
        if (data) {
            f.importData(data);
        }
        return f.validate().length === 0;
    }
    catch (e) {
        throw new Error(e);
    }
};
const validateFormData = (formModel, data) => {
    try {
        const f = new Form({ ...formModel }, FormFieldFactory, new RuleEngine());
        if (data) {
            f.importData(data);
        }
        const res = f.validate();
        return {
            messages: res,
            valid: res.length === 0
        };
    }
    catch (e) {
        throw new Error(e);
    }
};
const fetchForm = (url, headers = {}) => {
    const headerObj = new Headers();
    Object.entries(headers).forEach(([key, value]) => {
        headerObj.append(key, value);
    });
    return new Promise((resolve, reject) => {
        request$1(`${url}.model.json`, null, { headers }).then((response) => {
            if (response.status !== 200) {
                reject('Not Found');
            }
            else {
                let formObj = response.body;
                if ('model' in formObj) {
                    const { model } = formObj;
                    formObj = model;
                }
                resolve(jsonString(formObj));
            }
        });
    });
};
const registerFunctions = (functions) => {
    FunctionRuntime.registerFunctions(functions);
};

const TRANSLATION_TOKEN = '##';
const TRANSLATION_ID = 'afs:translationIds';
const CUSTOM_PROPS_KEY = 'properties';
const defaultBcp47LangTags = [
    'de-DE',
    'en-US',
    'es-ES',
    'fr-FR',
    'it-IT',
    'ja-JP',
    'ko-KR',
    'pt-BR',
    'zh-CN',
    'zh-TW'
];
const invalidateTranslation = (input, updates) => {
    translationProps.forEach((prop) => {
        if (prop in updates && input?.[CUSTOM_PROPS_KEY]?.[TRANSLATION_ID]?.[prop]) {
            delete input?.[CUSTOM_PROPS_KEY]?.[TRANSLATION_ID]?.[prop];
        }
    });
};
const addTranslationId = (input, additionalTranslationProps = []) => {
    const model = input;
    const transProps = [...translationProps, ...additionalTranslationProps];
    _createTranslationId(model, '', transProps);
    return model;
};
const _createTranslationId = (input, path, transProps) => {
    Object.entries(input).forEach(([key, value]) => {
        if (typeof value == 'object') {
            if (input instanceof Array) {
                if (value && 'name' in value) {
                    _createTranslationId(value, `${path === '' ? path : path + TRANSLATION_TOKEN}${value.name}`, transProps);
                }
            }
            else {
                _createTranslationId(value, ((key === 'items') ? path : `${path === '' ? path : path + TRANSLATION_TOKEN}${key}`), transProps);
            }
        }
        else {
            if (':type' in input ||
                'type' in input ||
                'fieldType' in input) {
                for (const transProp of transProps) {
                    if (getOrElse(input, transProp) != null) {
                        if (!(CUSTOM_PROPS_KEY in input)) {
                            input[CUSTOM_PROPS_KEY] = {};
                        }
                        if (!(TRANSLATION_ID in input[CUSTOM_PROPS_KEY])) {
                            input[CUSTOM_PROPS_KEY][TRANSLATION_ID] = {};
                        }
                        if (!(transProp in input[CUSTOM_PROPS_KEY][TRANSLATION_ID])) {
                            input[CUSTOM_PROPS_KEY][TRANSLATION_ID][transProp] = `${path}${TRANSLATION_TOKEN}${transProp}${TRANSLATION_TOKEN}${Math.floor(Math.random() * 10000) + 1}`;
                        }
                    }
                }
            }
        }
    });
};
const _createTranslationObj = (input, translationObj, translationProps) => {
    Object.values(input).forEach((value) => {
        if (typeof value == 'object') {
            _createTranslationObj(value, translationObj, translationProps);
        }
        else {
            for (const translationProp of translationProps) {
                const objValue = getOrElse(input, translationProp);
                if (objValue && input?.[CUSTOM_PROPS_KEY]?.[TRANSLATION_ID]?.[translationProp]) {
                    if (objValue instanceof Array) {
                        objValue.forEach((item, index) => {
                            if (typeof item === 'string') {
                                translationObj[`${input[CUSTOM_PROPS_KEY][TRANSLATION_ID][translationProp]}${TRANSLATION_TOKEN}${index}`] = item;
                            }
                        });
                    }
                    else {
                        translationObj[`${input[CUSTOM_PROPS_KEY][TRANSLATION_ID][translationProp]}`] = objValue;
                    }
                }
            }
        }
    });
};
const getOrElse = (input, key, defaultValue = null) => {
    if (!key) {
        return defaultValue;
    }
    const arr = Array.isArray(key) ? key : key.split('.');
    let objValue = input, index = 0;
    while (index < arr.length && objValue.hasOwnProperty(arr[index])) {
        objValue = objValue[arr[index]];
        index++;
    }
    return index == arr.length ? objValue : defaultValue;
};
const createTranslationObj = (input, additionalTranslationProps = []) => {
    const obj = {};
    const transProps = [...translationProps, ...additionalTranslationProps];
    _createTranslationObj(input, obj, transProps);
    return obj;
};
const createTranslationObject = (input, additionalTranslationProps = [], bcp47LangTags = []) => {
    const transProps = [...translationProps, ...additionalTranslationProps];
    const inputCopy = JSON.parse(JSON.stringify(input));
    const obj = createTranslationObj(addTranslationId(inputCopy, additionalTranslationProps), transProps);
    const langTags = [...defaultBcp47LangTags, ...bcp47LangTags];
    const allLangs = {};
    for (const langTag of langTags) {
        allLangs[langTag] = JSON.parse(JSON.stringify(obj));
    }
    return [inputCopy, allLangs];
};

exports.AddInstance = AddInstance;
exports.AddItem = AddItem;
exports.BaseNode = BaseNode;
exports.Blur = Blur;
exports.CUSTOM_PROPS_KEY = CUSTOM_PROPS_KEY;
exports.Change = Change;
exports.Checkbox = Checkbox;
exports.CheckboxGroup = CheckboxGroup;
exports.Click = Click;
exports.Container = Container;
exports.CustomEvent = CustomEvent;
exports.ExecuteRule = ExecuteRule;
exports.Field = Field;
exports.FieldChanged = FieldChanged;
exports.Fieldset = Fieldset;
exports.FileObject = FileObject;
exports.FileUpload = FileUpload;
exports.Focus = Focus;
exports.Form = Form;
exports.FormLoad = FormLoad;
exports.FormMetaData = FormMetaData;
exports.FunctionRuntime = FunctionRuntime;
exports.Initialize = Initialize;
exports.Invalid = Invalid;
exports.Node = Node;
exports.RemoveInstance = RemoveInstance;
exports.RemoveItem = RemoveItem;
exports.Reset = Reset;
exports.Scriptable = Scriptable;
exports.Submit = Submit;
exports.TRANSLATION_ID = TRANSLATION_ID;
exports.TRANSLATION_TOKEN = TRANSLATION_TOKEN;
exports.Valid = Valid;
exports.ValidationComplete = ValidationComplete;
exports.ValidationError = ValidationError;
exports.addTranslationId = addTranslationId;
exports.checkIfConstraintsArePresent = checkIfConstraintsArePresent;
exports.checkIfKeyAdded = checkIfKeyAdded;
exports.constraintProps = constraintProps;
exports.createFormInstance = createFormInstance;
exports.createTranslationObj = createTranslationObj;
exports.createTranslationObject = createTranslationObject;
exports.deepClone = deepClone;
exports.defaultFieldTypes = defaultFieldTypes;
exports.exportDataSchema = exportDataSchema;
exports.extractFileInfo = extractFileInfo;
exports.fetchForm = fetchForm;
exports.getFileSizeInBytes = getFileSizeInBytes;
exports.getOrElse = getOrElse;
exports.getProperty = getProperty;
exports.invalidateTranslation = invalidateTranslation;
exports.isCheckbox = isCheckbox;
exports.isCheckboxGroup = isCheckboxGroup;
exports.isDateField = isDateField;
exports.isEmpty = isEmpty;
exports.isFile = isFile;
exports.isRepeatable = isRepeatable;
exports.jsonString = jsonString;
exports.propertyChange = propertyChange;
exports.registerFunctions = registerFunctions;
exports.request = request;
exports.translationProps = translationProps;
exports.validateFormData = validateFormData;
exports.validateFormInstance = validateFormInstance;
