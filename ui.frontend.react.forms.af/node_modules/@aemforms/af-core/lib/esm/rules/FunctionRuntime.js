/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { CustomEvent, Submit, RemoveInstance, AddInstance, Reset, RemoveItem, AddItem, Click, Change } from '../controller/Events.js';
import { request as request$1 } from '../utils/Fetch.js';
import { FileObject } from '../FileObject.js';
import { getAttachments } from '../utils/FormUtils.js';
import { jsonString } from '../utils/JsonUtils.js';
import '../types/Json.js';
import '../utils/SchemaUtils.js';

const getCustomEventName = (name) => {
    const eName = name;
    if (eName.length > 0 && eName.startsWith('custom:')) {
        return eName.substring('custom:'.length);
    }
    return eName;
};
const request = async (context, uri, httpVerb, payload, success, error, headers) => {
    const endpoint = uri;
    const requestOptions = {
        method: httpVerb
    };
    let result;
    let inputPayload;
    try {
        if (payload && payload instanceof FileObject && payload.data instanceof File) {
            const formData = new FormData();
            formData.append(payload.name, payload.data);
            inputPayload = formData;
        }
        else if (payload instanceof FormData) {
            inputPayload = payload;
        }
        else if (payload && typeof payload === 'object' && Object.keys(payload).length > 0) {
            const headerNames = Object.keys(headers);
            if (headerNames.length > 0) {
                requestOptions.headers = {
                    ...headers,
                    ...(headerNames.indexOf('Content-Type') === -1 ? { 'Content-Type': 'application/json' } : {})
                };
            }
            else {
                requestOptions.headers = { 'Content-Type': 'application/json' };
            }
            const contentType = requestOptions?.headers?.['Content-Type'] || 'application/json';
            if (contentType === 'application/json') {
                inputPayload = JSON.stringify(payload);
            }
            else if (contentType.indexOf('multipart/form-data') > -1) {
                inputPayload = multipartFormData(payload);
            }
            else if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
                inputPayload = urlEncoded(payload);
            }
        }
        result = await request$1(endpoint, inputPayload, requestOptions);
    }
    catch (e) {
        context.form.logger.error('Error invoking a rest API');
        const eName = getCustomEventName(error);
        context.form.dispatch(new CustomEvent(eName, {}, true));
        return;
    }
    const eName = getCustomEventName(success);
    context.form.dispatch(new CustomEvent(eName, result, true));
};
const urlEncoded = (data) => {
    const formData = new URLSearchParams();
    Object.entries(data).forEach(([key, value]) => {
        if (value != null && typeof value === 'object') {
            formData.append(key, jsonString(value));
        }
        else {
            formData.append(key, value);
        }
    });
    return formData;
};
const multipartFormData = (data, attachments) => {
    const formData = new FormData();
    Object.entries(data).forEach(([key, value]) => {
        if (value != null && typeof value === 'object') {
            formData.append(key, jsonString(value));
        }
        else {
            formData.append(key, value);
        }
    });
    const addAttachmentToFormData = (objValue, formData) => {
        if (objValue?.data instanceof File) {
            let attIdentifier = `${objValue?.dataRef}/${objValue?.name}`;
            if (!attIdentifier.startsWith('/')) {
                attIdentifier = `/${attIdentifier}`;
            }
            formData.append(attIdentifier, objValue.data);
        }
    };
    if (attachments) {
        Object.keys(attachments).reduce((acc, curr) => {
            const objValue = attachments[curr];
            if (objValue && objValue instanceof Array) {
                return [...acc, ...objValue.map((x) => addAttachmentToFormData(x, formData))];
            }
            else {
                return [...acc, addAttachmentToFormData(objValue, formData)];
            }
        }, []);
    }
    return formData;
};
const submit = async (context, success, error, submitAs = 'multipart/form-data', input_data = null) => {
    const endpoint = context.form.action;
    let data = input_data;
    if (typeof data != 'object' || data == null) {
        data = context.form.exportData();
    }
    const attachments = getAttachments(context.form);
    let submitContentType = submitAs;
    const submitDataAndMetaData = { 'data': data, 'submitMetadata': { 'lang': context.form.lang } };
    let formData = submitDataAndMetaData;
    if (Object.keys(attachments).length > 0 || submitAs === 'multipart/form-data') {
        formData = multipartFormData(submitDataAndMetaData, attachments);
        submitContentType = 'multipart/form-data';
    }
    await request(context, endpoint, 'POST', formData, success, error, {
        'Content-Type': submitContentType
    });
};
const createAction = (name, payload = {}) => {
    switch (name) {
        case 'change':
            return new Change(payload);
        case 'submit':
            return new Submit(payload);
        case 'click':
            return new Click(payload);
        case 'addItem':
            return new AddItem(payload);
        case 'removeItem':
            return new RemoveItem(payload);
        case 'reset':
            return new Reset(payload);
        case 'addInstance':
            return new AddInstance(payload);
        case 'removeInstance':
            return new RemoveInstance(payload);
        default:
            console.error('invalid action');
    }
};
class FunctionRuntimeImpl {
    customFunctions = {};
    registerFunctions(functions) {
        Object.entries(functions).forEach(([name, funcDef]) => {
            let finalFunction = funcDef;
            if (typeof funcDef === 'function') {
                finalFunction = {
                    _func: (args) => {
                        return funcDef(...args);
                    },
                    _signature: []
                };
            }
            if (!finalFunction.hasOwnProperty('_func')) {
                console.warn(`Unable to register function with name ${name}.`);
                return;
            }
            this.customFunctions[name] = finalFunction;
        });
    }
    unregisterFunctions(...names) {
        names.forEach(name => {
            if (name in this.customFunctions) {
                delete this.customFunctions[name];
            }
        });
    }
    getFunctions() {
        function isArray(obj) {
            if (obj !== null) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            }
            return false;
        }
        function valueOf(a) {
            if (a === null || a === undefined) {
                return a;
            }
            if (isArray(a)) {
                return a.map(i => valueOf(i));
            }
            return a.valueOf();
        }
        function toString(a) {
            if (a === null || a === undefined) {
                return '';
            }
            return a.toString();
        }
        const defaultFunctions = {
            validate: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    let validation;
                    if (typeof element === 'string' || typeof element === 'undefined') {
                        validation = interpreter.globals.form.validate();
                    }
                    else {
                        validation = interpreter.globals.form.getElement(element.$id).validate();
                    }
                    if (Array.isArray(validation) && validation.length) {
                        interpreter.globals.form.logger.error('Form Validation Error');
                    }
                    return validation;
                },
                _signature: []
            },
            setFocus: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    try {
                        const field = interpreter.globals.form.getElement(element.$id);
                        interpreter.globals.form.setFocus(field);
                    }
                    catch (e) {
                        interpreter.globals.form.logger.error('Invalid argument passed in setFocus. An element is expected');
                    }
                },
                _signature: []
            },
            getData: {
                _func: (args, data, interpreter) => {
                    interpreter.globals.form.logger.warn('The `getData` function is depricated. Use `exportData` instead.');
                    return interpreter.globals.form.exportData();
                },
                _signature: []
            },
            exportData: {
                _func: (args, data, interpreter) => {
                    return interpreter.globals.form.exportData();
                },
                _signature: []
            },
            importData: {
                _func: (args, data, interpreter) => {
                    const inputData = args[0];
                    if (typeof inputData === 'object' && inputData !== null) {
                        interpreter.globals.form.importData(inputData);
                    }
                    return {};
                },
                _signature: []
            },
            submitForm: {
                _func: (args, data, interpreter) => {
                    const success = toString(args[0]);
                    const error = toString(args[1]);
                    const submit_as = args.length > 2 ? toString(args[2]) : 'multipart/form-data';
                    const submit_data = args.length > 3 ? valueOf(args[3]) : null;
                    interpreter.globals.form.dispatch(new Submit({
                        success,
                        error,
                        submit_as,
                        data: submit_data
                    }));
                    return {};
                },
                _signature: []
            },
            request: {
                _func: (args, data, interpreter) => {
                    const uri = toString(args[0]);
                    const httpVerb = toString(args[1]);
                    const payload = valueOf(args[2]);
                    let success, error, headers = {};
                    if (typeof (args[3]) === 'string') {
                        interpreter.globals.form.logger.warn('This usage of request is deprecated. Please see the documentation and update');
                        success = valueOf(args[3]);
                        error = valueOf(args[4]);
                    }
                    else {
                        headers = valueOf(args[3]);
                        success = valueOf(args[4]);
                        error = valueOf(args[5]);
                    }
                    request(interpreter.globals, uri, httpVerb, payload, success, error, headers);
                    return {};
                },
                _signature: []
            },
            dispatchEvent: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    let eventName = valueOf(args[1]);
                    let payload = args.length > 2 ? valueOf(args[2]) : undefined;
                    let dispatch = false;
                    if (typeof element === 'string') {
                        payload = eventName;
                        eventName = element;
                        dispatch = true;
                    }
                    let event;
                    if (eventName.startsWith('custom:')) {
                        event = new CustomEvent(eventName.substring('custom:'.length), payload, dispatch);
                    }
                    else {
                        event = createAction(eventName, payload);
                    }
                    if (event != null) {
                        if (typeof element === 'string') {
                            interpreter.globals.form.dispatch(event);
                        }
                        else {
                            interpreter.globals.form.getElement(element.$id).dispatch(event);
                        }
                    }
                    return {};
                },
                _signature: []
            }
        };
        return { ...defaultFunctions, ...this.customFunctions };
    }
}
const FunctionRuntime = new FunctionRuntimeImpl();

export { FunctionRuntime, request, submit };
