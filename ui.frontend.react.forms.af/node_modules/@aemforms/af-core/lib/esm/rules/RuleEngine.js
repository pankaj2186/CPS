/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import Formula from '@adobe/json-formula';
import { FunctionRuntime } from './FunctionRuntime.js';
import '../controller/Events.js';
import '../utils/Fetch.js';
import '../FileObject.js';
import '../utils/FormUtils.js';
import '../utils/JsonUtils.js';
import '../types/Json.js';
import '../utils/SchemaUtils.js';

class RuleEngine {
    _context;
    _globalNames = [
        '$form',
        '$field',
        '$event'
    ];
    formulaEngine;
    debugInfo = [];
    constructor() {
        const customFunctions = FunctionRuntime.getFunctions();
        this.formulaEngine = new Formula(customFunctions, undefined, this.debugInfo);
    }
    compileRule(rule) {
        return this.formulaEngine.compile(rule, this._globalNames);
    }
    execute(node, data, globals, useValueOf = false) {
        const oldContext = this._context;
        this._context = globals;
        let res = undefined;
        try {
            res = this.formulaEngine.run(node, data, 'en-US', globals);
        }
        catch (err) {
            this._context?.form?.logger?.error(err);
        }
        while (this.debugInfo.length > 0) {
            this._context?.form?.logger?.debug(this.debugInfo.pop());
        }
        let finalRes = res;
        if (useValueOf) {
            if (typeof res === 'object' && res !== null) {
                finalRes = Object.getPrototypeOf(res).valueOf.call(res);
            }
        }
        this._context = oldContext;
        return finalRes;
    }
    trackDependency(subscriber) {
        if (this._context && this._context.field !== undefined && this._context.field !== subscriber) {
            subscriber._addDependent(this._context.field);
        }
    }
}

export { RuleEngine as default };
