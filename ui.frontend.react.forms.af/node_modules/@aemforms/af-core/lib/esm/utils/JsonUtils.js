/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { constraintProps } from '../types/Json.js';
import { defaultFieldTypes } from './SchemaUtils.js';

const getProperty = (data, key, def) => {
    if (key in data) {
        return data[key];
    }
    else if (!key.startsWith(':')) {
        const prefixedKey = `:${key}`;
        if (prefixedKey in data) {
            return data[prefixedKey];
        }
    }
    return def;
};
const isFile = function (item) {
    return (item?.type === 'file' || item?.type === 'file[]') ||
        ((item?.type === 'string' || item?.type === 'string[]') &&
            (item?.format === 'binary' || item?.format === 'data-url'));
};
const checkIfConstraintsArePresent = function (item) {
    return constraintProps.some(cp => item[cp] !== undefined);
};
const isCheckbox = function (item) {
    const fieldType = item?.fieldType || defaultFieldTypes(item);
    return fieldType === 'checkbox';
};
const isCheckboxGroup = function (item) {
    const fieldType = item?.fieldType || defaultFieldTypes(item);
    return fieldType === 'checkbox-group';
};
const isDateField = function (item) {
    const fieldType = item?.fieldType || defaultFieldTypes(item);
    return (fieldType === 'text-input' && item?.format === 'date') || fieldType === 'date-input';
};
function deepClone(obj, idGenerator) {
    let result;
    if (obj instanceof Array) {
        result = [];
        result = obj.map(x => deepClone(x, idGenerator));
    }
    else if (typeof obj === 'object' && obj !== null) {
        result = {};
        Object.entries(obj).forEach(([key, value]) => {
            result[key] = deepClone(value, idGenerator);
        });
    }
    else {
        result = obj;
    }
    if (idGenerator && result && result.id) {
        result.id = idGenerator();
    }
    return result;
}
function checkIfKeyAdded(currentObj, prevObj, objKey) {
    if (currentObj != null && prevObj != null) {
        const newPrvObj = { ...prevObj };
        newPrvObj[objKey] = currentObj[objKey];
        const newJsonStr = jsonString(currentObj).replace(jsonString(newPrvObj), '');
        return newJsonStr === '';
    }
    else {
        return false;
    }
}
const jsonString = (obj) => {
    return JSON.stringify(obj, null, 2);
};
const isRepeatable = (obj) => {
    return ((obj.repeatable &&
        ((obj.minOccur === undefined && obj.maxOccur === undefined) ||
            (obj.minOccur !== undefined && obj.maxOccur !== undefined && obj.maxOccur !== 0) ||
            (obj.minOccur !== undefined && obj.maxOccur !== undefined && obj.minOccur !== 0 && obj.maxOccur !== 0) ||
            (obj.minOccur !== undefined && obj.minOccur >= 0) ||
            (obj.maxOccur !== undefined && obj.maxOccur !== 0))) || false);
};

export { checkIfConstraintsArePresent, checkIfKeyAdded, deepClone, getProperty, isCheckbox, isCheckboxGroup, isDateField, isFile, isRepeatable, jsonString };
