/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { translationProps } from '../types/Json.js';

const TRANSLATION_TOKEN = '##';
const TRANSLATION_ID = 'afs:translationIds';
const CUSTOM_PROPS_KEY = 'properties';
const defaultBcp47LangTags = [
    'de-DE',
    'en-US',
    'es-ES',
    'fr-FR',
    'it-IT',
    'ja-JP',
    'ko-KR',
    'pt-BR',
    'zh-CN',
    'zh-TW'
];
const invalidateTranslation = (input, updates) => {
    translationProps.forEach((prop) => {
        if (prop in updates && input?.[CUSTOM_PROPS_KEY]?.[TRANSLATION_ID]?.[prop]) {
            delete input?.[CUSTOM_PROPS_KEY]?.[TRANSLATION_ID]?.[prop];
        }
    });
};
const addTranslationId = (input, additionalTranslationProps = []) => {
    const model = input;
    const transProps = [...translationProps, ...additionalTranslationProps];
    _createTranslationId(model, '', transProps);
    return model;
};
const _createTranslationId = (input, path, transProps) => {
    Object.entries(input).forEach(([key, value]) => {
        if (typeof value == 'object') {
            if (input instanceof Array) {
                if (value && 'name' in value) {
                    _createTranslationId(value, `${path === '' ? path : path + TRANSLATION_TOKEN}${value.name}`, transProps);
                }
            }
            else {
                _createTranslationId(value, ((key === 'items') ? path : `${path === '' ? path : path + TRANSLATION_TOKEN}${key}`), transProps);
            }
        }
        else {
            if (':type' in input ||
                'type' in input ||
                'fieldType' in input) {
                for (const transProp of transProps) {
                    if (getOrElse(input, transProp) != null) {
                        if (!(CUSTOM_PROPS_KEY in input)) {
                            input[CUSTOM_PROPS_KEY] = {};
                        }
                        if (!(TRANSLATION_ID in input[CUSTOM_PROPS_KEY])) {
                            input[CUSTOM_PROPS_KEY][TRANSLATION_ID] = {};
                        }
                        if (!(transProp in input[CUSTOM_PROPS_KEY][TRANSLATION_ID])) {
                            input[CUSTOM_PROPS_KEY][TRANSLATION_ID][transProp] = `${path}${TRANSLATION_TOKEN}${transProp}${TRANSLATION_TOKEN}${Math.floor(Math.random() * 10000) + 1}`;
                        }
                    }
                }
            }
        }
    });
};
const _createTranslationObj = (input, translationObj, translationProps) => {
    Object.values(input).forEach((value) => {
        if (typeof value == 'object') {
            _createTranslationObj(value, translationObj, translationProps);
        }
        else {
            for (const translationProp of translationProps) {
                const objValue = getOrElse(input, translationProp);
                if (objValue && input?.[CUSTOM_PROPS_KEY]?.[TRANSLATION_ID]?.[translationProp]) {
                    if (objValue instanceof Array) {
                        objValue.forEach((item, index) => {
                            if (typeof item === 'string') {
                                translationObj[`${input[CUSTOM_PROPS_KEY][TRANSLATION_ID][translationProp]}${TRANSLATION_TOKEN}${index}`] = item;
                            }
                        });
                    }
                    else {
                        translationObj[`${input[CUSTOM_PROPS_KEY][TRANSLATION_ID][translationProp]}`] = objValue;
                    }
                }
            }
        }
    });
};
const getOrElse = (input, key, defaultValue = null) => {
    if (!key) {
        return defaultValue;
    }
    const arr = Array.isArray(key) ? key : key.split('.');
    let objValue = input, index = 0;
    while (index < arr.length && objValue.hasOwnProperty(arr[index])) {
        objValue = objValue[arr[index]];
        index++;
    }
    return index == arr.length ? objValue : defaultValue;
};
const createTranslationObj = (input, additionalTranslationProps = []) => {
    const obj = {};
    const transProps = [...translationProps, ...additionalTranslationProps];
    _createTranslationObj(input, obj, transProps);
    return obj;
};
const createTranslationObject = (input, additionalTranslationProps = [], bcp47LangTags = []) => {
    const transProps = [...translationProps, ...additionalTranslationProps];
    const inputCopy = JSON.parse(JSON.stringify(input));
    const obj = createTranslationObj(addTranslationId(inputCopy, additionalTranslationProps), transProps);
    const langTags = [...defaultBcp47LangTags, ...bcp47LangTags];
    const allLangs = {};
    for (const langTag of langTags) {
        allLangs[langTag] = JSON.parse(JSON.stringify(obj));
    }
    return [inputCopy, allLangs];
};

export { CUSTOM_PROPS_KEY, TRANSLATION_ID, TRANSLATION_TOKEN, addTranslationId, createTranslationObj, createTranslationObject, getOrElse, invalidateTranslation };
