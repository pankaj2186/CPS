/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { _ as __decorate, d as dependencyTracked } from './BaseNode-d78cc1b0.js';
import { isRepeatable, deepClone } from './utils/JsonUtils.js';
import Scriptable from './Scriptable.js';
import { propertyChange, Initialize, ExecuteRule, RemoveItem } from './controller/Events.js';
import DataGroup from './data/DataGroup.js';
import './utils/DataRefParser.js';
import './data/DataValue.js';
import './data/EmptyDataValue.js';
import './types/Json.js';
import './utils/SchemaUtils.js';

class Container extends Scriptable {
    _children = [];
    _childrenReference;
    _itemTemplate = null;
    fieldFactory;
    constructor(json, _options) {
        super(json, { form: _options.form, parent: _options.parent });
        this.fieldFactory = _options.fieldFactory;
    }
    ruleNodeReference() {
        return this._childrenReference;
    }
    get items() {
        return this._children;
    }
    get maxItems() {
        return this._jsonModel.maxItems;
    }
    set maxItems(m) {
        this._jsonModel.maxItems = m;
        const minItems = this._jsonModel.minItems || 1;
        const itemsLength = this._children.length;
        const items2Remove = Math.min(itemsLength - m, itemsLength - minItems);
        if (items2Remove > 0) {
            for (let i = 0; i < items2Remove; i++) {
                this.getDataNode().$removeDataNode(m + i);
                this._childrenReference.pop();
            }
            const elems = this._children.splice(m, items2Remove);
            this.notifyDependents(propertyChange('items', elems, null));
        }
    }
    get minItems() {
        return this._jsonModel.minItems;
    }
    hasDynamicItems() {
        return this._itemTemplate != null;
    }
    get isContainer() {
        return true;
    }
    _activeChild = null;
    isSiteContainer(item) {
        return ':items' in item;
    }
    isAFormField(item) {
        return ('fieldType' in item || 'id' in item || 'name' in item || 'dataRef' in item || 'type' in item);
    }
    getItemsState(isRepeatableChild = false) {
        if (this._jsonModel.type === 'array' || isRepeatable(this._jsonModel) || isRepeatableChild) {
            return this._children.map(x => {
                return { ...x.getState(true) };
            });
        }
        else {
            return this._jsonModel.items.map(x => {
                if (this.isSiteContainer(x)) {
                    return {
                        ...x,
                        ':items': this.walkSiteContainerItems(x)
                    };
                }
                else if (this.isAFormField(x)) {
                    return { ...this.form.getElement(x?.id).getState(isRepeatableChild) };
                }
                else {
                    return x;
                }
            });
        }
    }
    getState(isRepeatableChild = false) {
        return {
            ...super.getState(isRepeatableChild),
            items: this.getItemsState(isRepeatableChild)
        };
    }
    _createChild(child, options) {
        const { parent = this } = options;
        return this.fieldFactory.createField(child, {
            form: options.form,
            parent
        });
    }
    walkSiteContainerItems(x) {
        return Object.fromEntries(Object.entries(x[':items']).map(([key, value]) => {
            if (this.isAFormField(value)) {
                return [key, this.form.getElement(value?.id).getState()];
            }
            else if (this.isSiteContainer(value)) {
                return this.walkSiteContainerItems(value);
            }
            else {
                return [key, value];
            }
        }));
    }
    _addChildToRuleNode(child, options) {
        const self = this;
        const { parent = this } = options;
        const name = parent.type == 'array' ? parent._children.length + '' : child.name || '';
        if (name.length > 0) {
            Object.defineProperty(parent._childrenReference, name, {
                get: () => {
                    if (child.isContainer && child.hasDynamicItems()) {
                        self.ruleEngine.trackDependency(child);
                    }
                    if (self.hasDynamicItems()) {
                        self.ruleEngine.trackDependency(self);
                        if (this._children[name] !== undefined) {
                            return this._children[name].getRuleNode();
                        }
                    }
                    else {
                        return child.getRuleNode();
                    }
                },
                configurable: true,
                enumerable: true
            });
        }
    }
    _addChild(itemJson, index, cloneIds = false) {
        let nonTransparentParent = this;
        while (nonTransparentParent != null && nonTransparentParent.isTransparent()) {
            nonTransparentParent = nonTransparentParent.parent;
        }
        if (typeof index !== 'number' || index > nonTransparentParent._children.length) {
            index = this._children.length;
        }
        const form = this.form;
        const itemTemplate = {
            index,
            ...deepClone(itemJson, cloneIds ? () => { return form.getUniqueId(); } : undefined)
        };
        const retVal = this._createChild(itemTemplate, { parent: this, form: this.form });
        itemJson.id = retVal.id;
        this.form.fieldAdded(retVal);
        this._addChildToRuleNode(retVal, { parent: nonTransparentParent });
        if (index === this._children.length) {
            this._children.push(retVal);
        }
        else {
            this._children.splice(index, 0, retVal);
        }
        return retVal;
    }
    indexOf(f) {
        return this._children.indexOf(f);
    }
    defaultDataModel(name) {
        const type = this._jsonModel.type || undefined;
        if (type === undefined) {
            return undefined;
        }
        else {
            const instance = type === 'array' ? [] : {};
            return new DataGroup(name, instance, type);
        }
    }
    _initialize() {
        super._initialize();
        const items = this._jsonModel.items || [];
        this._childrenReference = this._jsonModel.type == 'array' ? [] : {};
        if (this._jsonModel.type == 'array' && items.length === 1 && this.getDataNode() != null) {
            this._itemTemplate = deepClone(items[0]);
            if (typeof (this._jsonModel.minItems) !== 'number') {
                this._jsonModel.minItems = 0;
            }
            if (typeof (this._jsonModel.maxItems) !== 'number') {
                this._jsonModel.maxItems = -1;
            }
            if (typeof (this._jsonModel.initialItems) !== 'number') {
                this._jsonModel.initialItems = Math.max(1, this._jsonModel.minItems);
            }
            for (let i = 0; i < this._jsonModel.initialItems; i++) {
                const child = this._addChild(this._itemTemplate, null, i > 0);
                items[0].id = child.id;
                child._initialize();
            }
        }
        else if (items.length > 0) {
            items.forEach((item) => {
                if (this.isSiteContainer(item)) {
                    this._initializeSiteContainer(item);
                }
                else if (this.isAFormField(item)) {
                    const child = this._addChild(item);
                    child._initialize();
                }
                else {
                    this.form.logger.warn('A container item was not initialized.');
                }
            });
            this._jsonModel.minItems = this._children.length;
            this._jsonModel.maxItems = this._children.length;
            this._jsonModel.initialItems = this._children.length;
        }
        else {
            this.form.logger.warn('A container exists with no items.');
        }
        this.setupRuleNode();
    }
    _initializeSiteContainer(item) {
        Object.entries(item[':items']).forEach(([key, value]) => {
            if (this.isAFormField(value)) {
                const child = this._addChild(value);
                child._initialize();
            }
            else if (this.isSiteContainer(value)) {
                return this._initializeSiteContainer(value);
            }
        });
    }
    addItem(action) {
        if ((action.type === 'addItem' || action.type == 'addInstance') && this._itemTemplate != null) {
            if ((this._jsonModel.maxItems === -1) || (this._children.length < this._jsonModel.maxItems)) {
                const dataNode = this.getDataNode();
                let instanceIndex = action.payload;
                const retVal = this._addChild(this._itemTemplate, action.payload, true);
                if (typeof instanceIndex !== 'number' || instanceIndex > this._children.length) {
                    instanceIndex = this._children.length;
                }
                const _data = retVal.defaultDataModel(instanceIndex);
                if (_data) {
                    dataNode.$addDataNode(instanceIndex, _data);
                }
                retVal._initialize();
                this.notifyDependents(propertyChange('items', retVal.getState(), null));
                retVal.dispatch(new Initialize());
                retVal.dispatch(new ExecuteRule());
                for (let i = instanceIndex + 1; i < this._children.length; i++) {
                    this._children[i].dispatch(new ExecuteRule());
                }
            }
        }
    }
    removeItem(action) {
        if ((action.type === 'removeItem' || action.type == 'removeInstance') && this._itemTemplate != null) {
            if (this._children.length == 0) {
                return;
            }
            let instanceIndex = action.payload;
            if (typeof instanceIndex !== 'number') {
                instanceIndex = this._children.length - 1;
            }
            const state = this._children[instanceIndex].getState();
            if (this._children.length > this._jsonModel.minItems) {
                this._childrenReference.pop();
                this._children.splice(instanceIndex, 1);
                this.getDataNode().$removeDataNode(instanceIndex);
                for (let i = instanceIndex; i < this._children.length; i++) {
                    this._children[i].dispatch(new ExecuteRule());
                }
                this.notifyDependents(propertyChange('items', null, state));
            }
        }
    }
    queueEvent(action) {
        super.queueEvent(action);
        if (action.metadata?.dispatch) {
            this.items.forEach(x => {
                x.queueEvent(action);
            });
        }
    }
    reset() {
        if (this.type === 'array' || isRepeatable(this._jsonModel)) {
            if (this.items.length > this._jsonModel.initialItems) {
                const itemsToBeRemoved = this.items.length - this._jsonModel.initialItems;
                for (let i = 0; i < itemsToBeRemoved; i++) {
                    this.dispatch(new RemoveItem());
                }
            }
        }
        this.items.forEach(x => {
            x.reset();
        });
    }
    validate() {
        return this.items.flatMap(x => {
            return x.validate();
        }).filter(x => x.fieldName !== '');
    }
    dispatch(action) {
        super.dispatch(action);
    }
    importData(contextualDataModel) {
        this._bindToDataModel(contextualDataModel);
        const dataNode = this.getDataNode() || contextualDataModel;
        this.syncDataAndFormModel(dataNode);
    }
    syncDataAndFormModel(contextualDataModel) {
        if (contextualDataModel?.$type === 'array' && this._itemTemplate != null) {
            const dataLength = contextualDataModel?.$value.length;
            const itemsLength = this._children.length;
            const maxItems = this._jsonModel.maxItems === -1 ? dataLength : this._jsonModel.maxItems;
            const minItems = this._jsonModel.minItems;
            let items2Add = Math.min(dataLength - itemsLength, maxItems - itemsLength);
            const items2Remove = Math.min(itemsLength - dataLength, itemsLength - minItems);
            while (items2Add > 0) {
                items2Add--;
                const child = this._addChild(this._itemTemplate);
                child._initialize();
            }
            if (items2Remove > 0) {
                this._children.splice(dataLength, items2Remove);
                for (let i = 0; i < items2Remove; i++) {
                    this._childrenReference.pop();
                }
            }
        }
        this._children.forEach(x => {
            x.importData(contextualDataModel);
        });
    }
    get activeChild() {
        return this._activeChild;
    }
    set activeChild(c) {
        if (c !== this._activeChild) {
            let activeChild = this._activeChild;
            while (activeChild instanceof Container) {
                const temp = activeChild.activeChild;
                activeChild.activeChild = null;
                activeChild = temp;
            }
            const change = propertyChange('activeChild', c, this._activeChild);
            this._activeChild = c;
            if (this.parent && c !== null) {
                this.parent.activeChild = this;
            }
            this._jsonModel.activeChild = c?.id;
            this.notifyDependents(change);
        }
    }
}
__decorate([
    dependencyTracked()
], Container.prototype, "maxItems", null);
__decorate([
    dependencyTracked()
], Container.prototype, "minItems", null);
__decorate([
    dependencyTracked()
], Container.prototype, "activeChild", null);

export { Container as default };
