/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { propertyChange } from './controller/Events.js';
import Field from './Field.js';
import { getFileSizeInBytes } from './utils/FormUtils.js';
import { FileObject } from './FileObject.js';
import { Constraints } from './utils/ValidationUtils.js';
import './BaseNode-d78cc1b0.js';
import './utils/DataRefParser.js';
import './data/DataGroup.js';
import './data/DataValue.js';
import './data/EmptyDataValue.js';
import './types/Model.js';
import './Scriptable.js';
import './utils/SchemaUtils.js';
import '@aemforms/af-formatters';
import './utils/JsonUtils.js';
import './types/Json.js';

function addNameToDataURL(dataURL, name) {
    return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);
}
function processFiles(files) {
    return Promise.all([].map.call(files, processFile));
}
async function processFile(file) {
    const { name, size, type } = file;
    const fileObj = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = event => {
            resolve(new FileObject({
                data: addNameToDataURL(event.target.result, name),
                type,
                name,
                size
            }));
        };
        reader.readAsDataURL(file.data);
    });
    return fileObj;
}
class FileUpload extends Field {
    _getDefaults() {
        return {
            ...super._getDefaults(),
            accept: ['audio/*', 'video/*', 'image/*', 'text/*', 'application/pdf'],
            maxFileSize: '2MB'
        };
    }
    _getFallbackType() {
        return 'file';
    }
    get maxFileSize() {
        return getFileSizeInBytes(this._jsonModel.maxFileSize);
    }
    get accept() {
        return this._jsonModel.accept;
    }
    _applyUpdates(propNames, updates) {
        return propNames.reduce((acc, propertyName) => {
            const prevValue = this._jsonModel[propertyName];
            const currentValue = updates[propertyName];
            if (currentValue !== prevValue) {
                acc[propertyName] = {
                    propertyName,
                    currentValue,
                    prevValue
                };
                if (prevValue instanceof FileObject && typeof currentValue === 'object' && propertyName === 'value') {
                    this._jsonModel[propertyName] = new FileObject({ ...prevValue, ...{ 'data': currentValue.data } });
                }
                else {
                    this._jsonModel[propertyName] = currentValue;
                }
            }
            return acc;
        }, {});
    }
    getInternalType() {
        return this.type?.endsWith('[]') ? 'file[]' : 'file';
    }
    getDataNodeValue(typedValue) {
        let dataNodeValue = typedValue;
        if (dataNodeValue != null) {
            if (this.type === 'string') {
                dataNodeValue = dataNodeValue.data?.toString();
            }
            else if (this.type === 'string[]') {
                dataNodeValue = dataNodeValue instanceof Array ? dataNodeValue : [dataNodeValue];
                dataNodeValue = dataNodeValue.map((_) => _?.data?.toString());
            }
        }
        return dataNodeValue;
    }
    async _serialize() {
        const val = this._jsonModel.value;
        if (val === undefined) {
            return null;
        }
        const filesInfo = await processFiles(val instanceof Array ? val : [val]);
        return filesInfo;
    }
    importData(dataModel) {
        this._bindToDataModel(dataModel);
        const dataNode = this.getDataNode();
        if (dataNode !== undefined) {
            const value = dataNode?.$value;
            if (value != null) {
                const res = Constraints.type(this.getInternalType(), value);
                if (!res.valid) {
                    this.form.logger.error(`unable to bind ${this.name} to data`);
                }
                this.form.getEventQueue().queue(this, propertyChange('value', res.value, this._jsonModel.value));
                this._jsonModel.value = res.value;
            }
            else {
                this._jsonModel.value = null;
            }
        }
    }
}

export { FileUpload as default };
