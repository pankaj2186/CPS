/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import Form from './Form.js';
import { jsonString } from './utils/JsonUtils.js';
import { request } from './utils/Fetch.js';
import RuleEngine from './rules/RuleEngine.js';
import EventQueue from './controller/EventQueue.js';
import { Logger } from './controller/Logger.js';
import { FormFieldFactory } from './utils/FormCreationUtils.js';
import { FunctionRuntime } from './rules/FunctionRuntime.js';
import './Container.js';
import './BaseNode-d78cc1b0.js';
import './controller/Events.js';
import './utils/DataRefParser.js';
import './data/DataGroup.js';
import './data/DataValue.js';
import './data/EmptyDataValue.js';
import './Scriptable.js';
import './types/Json.js';
import './utils/SchemaUtils.js';
import './FormMetaData.js';
import './Node.js';
import './utils/FormUtils.js';
import './FileObject.js';
import '@adobe/json-formula';
import './InstanceManager.js';
import './Fieldset.js';
import './FileUpload.js';
import './Field.js';
import './types/Model.js';
import './utils/ValidationUtils.js';
import '@aemforms/af-formatters';
import './Checkbox.js';
import './CheckboxGroup.js';
import './DateField.js';

const createFormInstance = (formModel, callback, logLevel = 'error', fModel = undefined) => {
    try {
        let f = fModel;
        if (f == null) {
            f = new Form({ ...formModel }, FormFieldFactory, new RuleEngine(), new EventQueue(new Logger(logLevel)), logLevel);
        }
        const formData = formModel?.data;
        if (formData) {
            f.importData(formData);
        }
        if (typeof callback === 'function') {
            callback(f);
        }
        f.getEventQueue().runPendingQueue();
        return f;
    }
    catch (e) {
        console.error(`Unable to create an instance of the Form ${e}`);
        throw new Error(e);
    }
};
const validateFormInstance = (formModel, data) => {
    try {
        const f = new Form({ ...formModel }, FormFieldFactory, new RuleEngine());
        if (data) {
            f.importData(data);
        }
        return f.validate().length === 0;
    }
    catch (e) {
        throw new Error(e);
    }
};
const validateFormData = (formModel, data) => {
    try {
        const f = new Form({ ...formModel }, FormFieldFactory, new RuleEngine());
        if (data) {
            f.importData(data);
        }
        const res = f.validate();
        return {
            messages: res,
            valid: res.length === 0
        };
    }
    catch (e) {
        throw new Error(e);
    }
};
const fetchForm = (url, headers = {}) => {
    const headerObj = new Headers();
    Object.entries(headers).forEach(([key, value]) => {
        headerObj.append(key, value);
    });
    return new Promise((resolve, reject) => {
        request(`${url}.model.json`, null, { headers }).then((response) => {
            if (response.status !== 200) {
                reject('Not Found');
            }
            else {
                let formObj = response.body;
                if ('model' in formObj) {
                    const { model } = formObj;
                    formObj = model;
                }
                resolve(jsonString(formObj));
            }
        });
    });
};
const registerFunctions = (functions) => {
    FunctionRuntime.registerFunctions(functions);
};

export { createFormInstance, fetchForm, registerFunctions, validateFormData, validateFormInstance };
