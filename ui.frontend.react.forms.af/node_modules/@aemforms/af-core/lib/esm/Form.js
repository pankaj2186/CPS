/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import Container from './Container.js';
import FormMetaData from './FormMetaData.js';
import EventQueue from './controller/EventQueue.js';
import { Logger } from './controller/Logger.js';
import { IdGenerator, getAttachments } from './utils/FormUtils.js';
import DataGroup from './data/DataGroup.js';
import { submit } from './rules/FunctionRuntime.js';
import { Initialize, ExecuteRule, FormLoad, FieldChanged, ValidationComplete } from './controller/Events.js';
import './BaseNode-d78cc1b0.js';
import './utils/DataRefParser.js';
import './data/DataValue.js';
import './data/EmptyDataValue.js';
import './utils/JsonUtils.js';
import './types/Json.js';
import './utils/SchemaUtils.js';
import './Scriptable.js';
import './Node.js';
import './FileObject.js';
import './utils/Fetch.js';

class Form extends Container {
    _ruleEngine;
    _eventQueue;
    _fields = {};
    _ids;
    _invalidFields = [];
    _logger;
    constructor(n, fieldFactory, _ruleEngine, _eventQueue = new EventQueue(), logLevel = 'off') {
        super(n, { fieldFactory: fieldFactory });
        this._ruleEngine = _ruleEngine;
        this._eventQueue = _eventQueue;
        this._logger = new Logger(logLevel);
        this.queueEvent(new Initialize());
        this.queueEvent(new ExecuteRule());
        this._ids = IdGenerator();
        this._bindToDataModel(new DataGroup('$form', {}));
        this._initialize();
        this.queueEvent(new FormLoad());
    }
    get logger() {
        return this._logger;
    }
    dataRefRegex = /("[^"]+?"|[^.]+?)(?:\.|$)/g;
    get metaData() {
        const metaData = this._jsonModel.metadata || {};
        return new FormMetaData(metaData);
    }
    get action() {
        return this._jsonModel.action;
    }
    get lang() {
        return this._jsonModel.lang || 'en';
    }
    importData(dataModel) {
        this._bindToDataModel(new DataGroup('$form', dataModel));
        this.syncDataAndFormModel(this.getDataNode());
        this._eventQueue.runPendingQueue();
    }
    exportData() {
        return this.getDataNode()?.$value;
    }
    setFocus(field) {
        const parent = field.parent;
        const currentField = field;
        while (parent != null && parent.activeChild != currentField) {
            parent.activeChild = currentField;
        }
    }
    getState() {
        const self = this;
        const res = super.getState();
        res.id = '$form';
        Object.defineProperty(res, 'data', {
            get: function () {
                return self.exportData();
            }
        });
        Object.defineProperty(res, 'attachments', {
            get: function () {
                return getAttachments(self);
            }
        });
        return res;
    }
    get type() {
        return 'object';
    }
    isTransparent() {
        return false;
    }
    get form() {
        return this;
    }
    get ruleEngine() {
        return this._ruleEngine;
    }
    getUniqueId() {
        if (this._ids == null) {
            return '';
        }
        return this._ids.next().value;
    }
    fieldAdded(field) {
        this._fields[field.id] = field;
        field.subscribe((action) => {
            if (this._invalidFields.indexOf(action.target.id) === -1) {
                this._invalidFields.push(action.target.id);
            }
        }, 'invalid');
        field.subscribe((action) => {
            const index = this._invalidFields.indexOf(action.target.id);
            if (index > -1) {
                this._invalidFields.splice(index, 1);
            }
        }, 'valid');
        field.subscribe((action) => {
            const field = action.target.getState();
            if (field) {
                const fieldChangedAction = new FieldChanged(action.payload.changes, field);
                this.dispatch(fieldChangedAction);
            }
        });
    }
    visit(callBack) {
        this.traverseChild(this, callBack);
    }
    traverseChild(container, callBack) {
        container.items.forEach((field) => {
            if (field.isContainer) {
                this.traverseChild(field, callBack);
            }
            callBack(field);
        });
    }
    validate() {
        const validationErrors = super.validate();
        this.dispatch(new ValidationComplete(validationErrors));
        return validationErrors;
    }
    isValid() {
        return this._invalidFields.length === 0;
    }
    dispatch(action) {
        if (action.type === 'submit') {
            super.queueEvent(action);
            this._eventQueue.runPendingQueue();
        }
        else {
            super.dispatch(action);
        }
    }
    submit(action, context) {
        if (this.validate().length === 0) {
            const payload = action?.payload || {};
            submit(context, payload?.success, payload?.error, payload?.submit_as, payload?.data);
        }
    }
    reset() {
        super.reset();
        this._invalidFields = [];
    }
    getElement(id) {
        if (id == this.id) {
            return this;
        }
        return this._fields[id];
    }
    get qualifiedName() {
        return '$form';
    }
    getEventQueue() {
        return this._eventQueue;
    }
    get name() {
        return '$form';
    }
    get value() {
        return null;
    }
    get id() {
        return '$form';
    }
    get title() {
        return this._jsonModel.title || '';
    }
}

export { Form as default };
