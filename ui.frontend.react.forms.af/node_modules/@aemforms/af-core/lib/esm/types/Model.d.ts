import { ConstraintsJson, ContainerJson, FieldJson, FieldsetJson, FormJson, Label, MetaDataJson } from './Json.js';
import RuleEngine from '../rules/RuleEngine.js';
import EventQueue from '../controller/EventQueue.js';
import DataGroup from '../data/DataGroup.js';
import { Logger } from '../controller/Logger.js';
export interface ScriptableField {
    rules?: {
        [key: string]: string;
    };
    events?: {
        [key: string]: string;
    };
    ruleEngine: RuleEngine;
}
interface WithState<T> {
    getState: () => any;
}
type stateProps = {
    id: string;
    index: number;
    ':type': string;
};
export type State<T> = stateProps & (T extends ContainerJson ? T & {
    items: Array<State<FieldJson | ContainerJson>>;
} : T);
export type Subscription = {
    unsubscribe(): void;
};
export interface Action {
    type: string;
    payload: any;
    metadata: any;
    readonly isCustomEvent: boolean;
    readonly target: FormModel | FieldModel | FieldsetModel;
    readonly originalAction?: Action;
}
export type callbackFn = (action: Action) => void;
export interface WithController {
    subscribe(callback: callbackFn, eventName?: string): Subscription;
    dispatch(action: Action): void;
}
export interface BaseModel extends ConstraintsJson, WithController {
    readonly name?: string;
    readonly dataRef?: string | null;
    readonly id: string;
    readonly index: number;
    readonly qualifiedName: string;
    label?: Label;
    description?: string;
    readOnly?: boolean;
    enabled?: boolean;
    visible?: boolean;
    placeholder?: string;
    valid?: boolean;
    readonly ':type': string;
    readonly 'fieldType': string;
    properties: {
        [key: string]: any;
    };
    readonly isContainer: boolean;
    readonly parent: ContainerModel | null;
    readonly items?: Array<FieldsetModel | FieldModel>;
    value: any;
    readonly default?: any;
    readonly repeatable?: boolean;
    readonly language?: string;
    validate(): Array<ValidationError>;
    reset(): any;
    importData(a?: DataGroup): any;
    getRuleNode(): any;
    ruleNodeReference(): any;
    _initialize(): any;
    _addDependent(dependent: BaseModel): any;
}
export interface FieldModel extends BaseModel, ScriptableField, WithState<FieldJson> {
    parent: ContainerModel;
    readonly editFormat?: string;
    readonly displayFormat?: string;
    readonly displayValue?: string;
    readonly editValue?: string;
}
export interface FormMetaDataModel {
    readonly version: string;
    readonly grammar: string;
}
export interface ContainerModel extends BaseModel, ScriptableField {
    items: Array<FieldsetModel | FieldModel>;
    parent: ContainerModel;
    indexOf(f: FieldModel | FieldsetModel): number;
    isTransparent(): boolean;
    activeChild: BaseModel | null;
}
export interface FieldsetModel extends ContainerModel, WithState<FieldsetJson> {
    type?: 'array' | 'object';
}
export interface FormModel extends ContainerModel, WithState<FormJson> {
    readonly id: string;
    readonly data?: any;
    readonly metadata?: MetaDataJson;
    readonly title: string;
    readonly logger: Logger;
    importData(data: any): any;
    exportData(): any;
    getElement(id: string): FieldModel | FormModel | FieldsetModel;
    getUniqueId(): string;
    getEventQueue(): EventQueue;
    visit(callBack: (field: FieldModel | FieldsetModel) => void): void;
    fieldAdded(field: FieldModel | FieldsetModel): void;
}
export interface IFormFieldFactory {
    createField(child: FieldsetJson | FieldJson, options: {
        form: FormModel;
        parent: ContainerModel;
    }): FieldModel | FieldsetModel;
}
export interface IFileObject {
    name: string;
    mediaType: string;
    data?: any;
    size?: number;
}
export interface IValidationError {
    fieldName: string;
    errorMessages: Array<string>;
}
export declare class ValidationError implements IValidationError {
    fieldName: string;
    errorMessages: Array<string>;
    constructor(fieldName?: string, errorMessages?: Array<any>);
}
export {};
