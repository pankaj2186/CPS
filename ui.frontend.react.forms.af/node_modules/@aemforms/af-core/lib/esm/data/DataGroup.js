/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import DataValue from './DataValue.js';
import NullDataValue from './EmptyDataValue.js';

class DataGroup extends DataValue {
    $_items;
    createEntry(key, value) {
        const t = value instanceof Array ? 'array' : typeof value;
        if (typeof value === 'object' && value != null) {
            return new DataGroup(key, value, t);
        }
        else {
            return new DataValue(key, value, t);
        }
    }
    constructor(_name, _value, _type = typeof _value) {
        super(_name, _value, _type);
        if (_value instanceof Array) {
            this.$_items = _value.map((value, index) => {
                return this.createEntry(index, value);
            });
        }
        else {
            this.$_items = Object.fromEntries(Object.entries(_value).map(([key, value]) => {
                return [key, this.createEntry(key, value)];
            }));
        }
    }
    get $value() {
        const enabled = this.$_fields.find(x => x.enabled !== false);
        if (!enabled && this.$_fields.length) {
            return this.$type === 'array' ? [] : {};
        }
        else if (this.$type === 'array') {
            return Object.values(this.$_items).filter(x => typeof x !== 'undefined').map(x => x.$value);
        }
        else {
            return Object.fromEntries(Object.values(this.$_items).filter(x => typeof x !== 'undefined').map(x => {
                return [x.$name, x.$value];
            }));
        }
    }
    get $length() {
        return Object.entries(this.$_items).length;
    }
    $convertToDataValue() {
        return new DataValue(this.$name, this.$value, this.$type);
    }
    $addDataNode(name, value, override = false) {
        if (value !== NullDataValue) {
            if (this.$type === 'array') {
                const index = name;
                if (!override) {
                    this.$_items.splice(index, 0, value);
                }
                else {
                    this.$_items[name] = value;
                }
            }
            else {
                this.$_items[name] = value;
            }
        }
    }
    $removeDataNode(name) {
        this.$_items[name] = undefined;
    }
    $getDataNode(name) {
        if (this.$_items.hasOwnProperty(name)) {
            return this.$_items[name];
        }
    }
    $containsDataNode(name) {
        return this.$_items.hasOwnProperty(name) && typeof (this.$_items[name]) !== 'undefined';
    }
    get $isDataGroup() {
        return true;
    }
}

export { DataGroup as default };
