"use strict";
/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateConvertor = exports.withErrorMessage = exports.inputTypeConvertor = exports.enumConvertor = exports.enumToChildConvertor = exports.stringConstraintConvertor = exports.fieldConvertor = exports.formatedErrorMessage = exports.constraintConvertor = exports.baseConvertor = exports.richTextString = exports.combineConvertors = void 0;
const af_core_1 = require("@aemforms/af-core");
const react_1 = __importDefault(require("react"));
const sanitize_html_1 = __importDefault(require("sanitize-html"));
const af_react_renderer_1 = require("@aemforms/af-react-renderer");
require("../styles.css");
const clsx_1 = __importDefault(require("clsx"));
const af_core_2 = require("@aemforms/af-core");
const date_1 = require("@internationalized/date");
const DEFAULT_ERROR_MESSAGE = 'There is an error in the field';
const combineConvertors = function (...convertors) {
    const newConvertor = (a, b, f) => {
        return convertors.reduce(function (newVal, curr) {
            return {
                ...newVal,
                ...curr(a, b, f)
            };
        }, {});
    };
    return newConvertor;
};
exports.combineConvertors = combineConvertors;
const richTextString = (stringMsg = '') => {
    const htmlProp = { __html: (0, sanitize_html_1.default)(stringMsg) };
    return (react_1.default.createElement("div", { dangerouslySetInnerHTML: htmlProp }));
};
exports.richTextString = richTextString;
const baseConvertor = (a, b, f) => {
    let localizedDescription = f('description');
    const layout = a?.properties?.['afs:layout'] || {};
    let localizedLabel = f('label.value');
    return {
        ...layout,
        isHidden: a.visible === false,
        name: a.name,
        isDisabled: a.enabled === false,
        label: a.label?.visible === false ? '' : (a.label?.richText === true ? (0, exports.richTextString)(localizedLabel) : localizedLabel),
        description: (localizedDescription && localizedDescription.length > 0) ? (0, exports.richTextString)(localizedDescription) : null,
        'aria-label': a.label?.visible === false ? a.label?.value : undefined
    };
};
exports.baseConvertor = baseConvertor;
const constraintConvertor = (a) => {
    // if there are no constraints and type is string, valid would anyways always be true, hence validationState would be optional
    const optionalValidation = !(0, af_core_1.checkIfConstraintsArePresent)(a) && a.type === 'string';
    return {
        ...(a.required && {
            isRequired: true,
            necessityIndicator: 'icon'
        }),
        validationState: a.valid === false ? 'invalid' : ((a.valid === undefined || (0, af_core_2.isEmpty)(a.value) || optionalValidation) ? undefined : 'valid')
    };
};
exports.constraintConvertor = constraintConvertor;
const formatedErrorMessage = (a) => {
    const i18n = (0, af_react_renderer_1.useFormIntl)();
    const formatedMessage = i18n.formatMessage({ id: 'defaultErrorMessage', defaultMessage: DEFAULT_ERROR_MESSAGE });
    const errorMessage = a.errorMessage === '' && a.valid === false ? formatedMessage : a.errorMessage;
    return errorMessage;
};
exports.formatedErrorMessage = formatedErrorMessage;
const commonFieldConvertor = (a, b, f) => {
    // if there are no constraints and type is string, valid would anyways always be true, hence validationState would be optional
    const optionalValidation = !(0, af_core_1.checkIfConstraintsArePresent)(a) && a.type === 'string';
    const errorMessage = (0, exports.formatedErrorMessage)(a);
    return {
        placeholder: f('placeholder'),
        validationState: a.valid === false ? 'invalid' : ((a.valid === undefined || (0, af_core_2.isEmpty)(a.value) || optionalValidation) ? undefined : 'valid'),
        onChange: b.dispatchChange,
        onBlur: b.dispatchBlur,
        onFocus: b.dispatchFocus,
        isReadOnly: a.readOnly === true,
        editValue: a.editValue,
        displayValue: a.displayValue,
        errorMessage
    };
};
const fieldConvertor = (a, b, f) => ({
    ...commonFieldConvertor(a, b, f),
    value: a.value == null ? '' : a.value
});
exports.fieldConvertor = fieldConvertor;
const stringConstraintConvertor = (a) => {
    return {
        minLength: a.minLength,
        maxLength: a.maxLength,
        pattern: a.pattern
    };
};
exports.stringConstraintConvertor = stringConstraintConvertor;
const enumToChildConvertor = (Component) => {
    return (0, exports.enumConvertor)('children', (text, value) => {
        return react_1.default.createElement(Component, { key: value, value: value }, text + '');
    });
};
exports.enumToChildConvertor = enumToChildConvertor;
const enumConvertor = (propertyName, callback) => (a, b, f) => {
    const options = a.enum || [];
    const localizedOptions = f('enum');
    const localizedOptionsName = f('enumNames');
    const radio = (option, i) => {
        const value = option;
        const text = (localizedOptionsName && i < localizedOptionsName.length) ? localizedOptionsName[i] : localizedOptions[i];
        return callback(text, value);
    };
    return {
        [propertyName]: options.map(radio)
    };
};
exports.enumConvertor = enumConvertor;
const inputTypeConvertor = (a) => {
    return {
        ...(a.type && {
            type: a.type
        })
    };
};
exports.inputTypeConvertor = inputTypeConvertor;
const withErrorMessage = (Component) => (props) => {
    const invalid = props.validationState === 'invalid';
    const helpText = invalid ? props.errorMessage || '' : props.description;
    const hasHelpText = (typeof helpText === 'string' && helpText.length > 0) || helpText != null;
    return (react_1.default.createElement("div", { className: (0, clsx_1.default)('formField', invalid && 'formField--invalid') },
        react_1.default.createElement(Component, { ...props }),
        hasHelpText ? react_1.default.createElement("div", { className: 'formField__helpText' }, helpText) : null));
};
exports.withErrorMessage = withErrorMessage;
const dateConvertor = (a, b, f) => {
    const fieldProps = commonFieldConvertor(a, b, f);
    if (a.default && a.default !== '') {
        fieldProps.defaultValue = (0, date_1.parseDate)(a.default);
    }
    if (a.value && a.value !== '') {
        fieldProps.value = (0, date_1.parseDate)(a.value);
    }
    return fieldProps;
};
exports.dateConvertor = dateConvertor;
