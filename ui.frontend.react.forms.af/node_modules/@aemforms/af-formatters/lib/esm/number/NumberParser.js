/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { parseNumberSkeleton } from './SkeletonParser.js';
import './currencies.js';

function formatNumber(numberValue, language, skeletn) {
    if (skeletn.startsWith('num|')) {
        skeletn = skel.split('|')[1];
    }
    if (!skeletn) return numberValue
    language = language || "en";
    const {options, order} = parseNumberSkeleton(skeletn, language);
    return new Intl.NumberFormat(language, options).format(numberValue);
}
function getMetaInfo(language, skel) {
    const parts = {};
    let options = new Intl.NumberFormat(language, {style:'decimal', useGrouping:false}).formatToParts(9876543210.1);
    parts.digits = options.find(p => p.type === 'integer').value.split('').reverse();
    parts.decimal = options.find(p => p.type === 'decimal').value;
    const gather = type => {
        const find = options.find(p => p.type === type);
        if (find) parts[type] = find.value;
    };
    const parsed = parseNumberSkeleton(skel);
    const nf = new Intl.NumberFormat(language, parsed);
    options = nf.formatToParts(-987654321);
    gather('group');
    gather('minusSign');
    gather('percentSign');
    parts.currency = options.filter(p => p.type === 'currency').map(p => p.value);
    parts.literal = options.filter(p => p.type === 'literal').map(p => p.value);
    options = nf.formatToParts(987654321);
    gather('plusSign');
    gather('exponentSeparator');
    gather('unit');
    return parts;
}
function parseNumber(numberString, language, skel) {
    try {
        if (skel.startsWith('num|')) {
            skel = skel.split('|')[1];
        }
        let factor = 1;
        let number = numberString;
        const meta = getMetaInfo(language, skel);
        if (meta.group) number = number.replaceAll(meta.group, '');
        number = number.replace(meta.decimal, '.');
        if (meta.unit) number = number.replaceAll(meta.unit, '');
        if (meta.minusSign && number.includes(meta.minusSign)) {
            number = number.replace(meta.minusSign, '');
            factor *= -1;
        }
        if (meta.percentSign && number.includes(meta.percentSign)) {
            factor = factor/100;
            number = number.replace(meta.percentSign, '');
        }
        meta.currency.forEach(currency => number = number.replace(currency, ''));
        meta.literal.forEach(literal => {
            if (number.includes(literal)) {
                if (literal === '(') factor = factor * -1;
                number = number.replace(literal, '');
            }
        });
        if (meta.plusSign) number = number.replace(meta.plusSign, '');
        if (meta.exponentSeparator) {
            let e;
            [number, e] = number.split(meta.exponentSeparator);
            factor = factor * Math.pow(10, e);
        }
        const result = factor * number;
        return isNaN(result) ? numberString : result;
    } catch (e) {
        console.dir(e);
        return numberString;
    }
}
function parseDefaultNumber(numberString, language) {
    const currency = currencies[language] || 'USD';
    return parseNumber(numberString, language, `currency/${currency}`);
}

export { formatNumber, parseDefaultNumber, parseNumber };
