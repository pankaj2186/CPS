/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

const DATE_TIME_REGEX =
    /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvV]{1,5}|[zZOvVxX]{1,3}|S{1,3}|'(?:[^']|'')*')|[^a-zA-Z']+/g;
const ShorthandStyles = ["full", "long", "medium", "short"];
function getSkeleton(skeleton, language) {
    if (ShorthandStyles.find(type => skeleton.includes(type))) {
        const parsed = parseDateStyle(skeleton, language);
        const result = [];
        const symbols = {
            month : 'M',
            year : 'Y',
            day : 'd'
        };
        parsed.forEach(([type, option, length]) => {
            if (type in symbols) {
                result.push(Array(length).fill(symbols[type]).join(''));
            } else if (type === 'literal') {
                result.push(option);
            }
        });
        return result.join('');
    }
    return skeleton;
}
function parseDateStyle(skeleton, language) {
    const options = {};
    const styles = skeleton.split(/\s/).filter(s => s.length);
    options.dateStyle = styles[0];
    if (styles.length > 1) options.timeStyle = styles[1];
    const testDate = new Date(2000, 2, 1, 2, 3, 4);
    const parts = new Intl.DateTimeFormat(language, options).formatToParts(testDate);
    const formattedMarch = parts.find(p => p.type === 'month').value;
    const longMarch = new Intl.DateTimeFormat(language, {month: 'long'}).formatToParts(testDate)[0].value;
    const shortMarch = new Intl.DateTimeFormat(language, {month: 'short'}).formatToParts(testDate)[0].value;
    const result = [];
    parts.forEach(({type, value}) => {
        let option;
        if (type === 'month') {
            option = {
                [formattedMarch]: skeleton === 'medium' ? 'short' : 'long',
                [longMarch]: 'long',
                [shortMarch]: 'short',
                '03': '2-digit',
                '3': 'numeric'
            }[value];
        }
        if (type === 'year') option = {'2000': 'numeric', '00': '2-digit'}[value];
        if (['day', 'hour', 'minute', 'second'].includes(type)) option = value.length === 2 ? '2-digit' : 'numeric';
        if (type === 'literal') option = value;
        if (type === 'dayPeriod') option = 'short';
        result.push([type, option, value.length]);
    });
    return result;
}
function parseDateTimeSkeleton(skeleton, language) {
    if (ShorthandStyles.find(type => skeleton.includes(type))) {
        return parseDateStyle(skeleton, language);
    }
    const result = [];
    skeleton.replace(DATE_TIME_REGEX, match => {
        const len = match.length;
        switch (match[0]) {
            case 'G':
                result.push(['era', len === 4 ? 'long' : len === 5 ? 'narrow' : 'short', len]);
                break;
            case 'y':
                result.push(['year', len === 2 ? '2-digit' : 'numeric', len]);
                break;
            case 'Y':
            case 'u':
            case 'U':
            case 'r':
                throw new RangeError(
                    '`Y/u/U/r` (year) patterns are not supported, use `y` instead'
                );
            case 'q':
            case 'Q':
                throw new RangeError('`q/Q` (quarter) patterns are not supported');
            case 'M':
            case 'L':
                result.push(['month', ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1], len]);
                break;
            case 'w':
            case 'W':
                throw new RangeError('`w/W` (week) patterns are not supported');
            case 'd':
                result.push(['day', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'D':
            case 'F':
            case 'g':
                throw new RangeError(
                    '`D/F/g` (day) patterns are not supported, use `d` instead'
                );
            case 'E':
                result.push(['weekday', ['short', 'short', 'short', 'long', 'narrow', 'narrow'][len - 1], len]);
                break;
            case 'e':
                if (len < 4) {
                    throw new RangeError('`e..eee` (weekday) patterns are not supported');
                }
                result.push(['weekday', ['short', 'long', 'narrow', 'short'][len - 4], len]);
                break;
            case 'c':
                if (len < 3 || len > 5) {
                    throw new RangeError('`c, cc, cccccc` (weekday) patterns are not supported');
                }
                result.push(['weekday', ['short', 'long', 'narrow', 'short'][len - 3], len]);
                break;
            case 'a':
                result.push(['hour12', true, 1]);
                break;
            case 'b':
            case 'B':
                throw new RangeError(
                    '`b/B` (period) patterns are not supported, use `a` instead'
                );
            case 'h':
                result.push(['hourCycle', 'h12']);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'H':
                result.push(['hourCycle', 'h23', 1]);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'K':
                result.push(['hourCycle', 'h11', 1]);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'k':
                result.push(['hourCycle', 'h24', 1]);
                result.push(['hour', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'j':
            case 'J':
            case 'C':
                throw new RangeError(
                    '`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead'
                );
            case 'm':
                result.push(['minute', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 's':
                result.push(['second', ['numeric', '2-digit'][len - 1], len]);
                break;
            case 'S':
                result.push(['fractionalSecondDigits', len, len]);
                break;
            case 'A':
                throw new RangeError(
                    '`S/A` (millisecond) patterns are not supported, use `s` instead'
                );
            case 'O':
                result.push(['timeZoneName', len < 4 ? 'shortOffset' : 'longOffset', len]);
                result.push(['x-timeZoneName', len < 4 ? 'O' : 'OOOO', len]);
                break;
            case 'X':
            case 'x':
            case 'Z':
                result.push(['timeZoneName', 'longOffset', 1]);
                result.push(['x-timeZoneName', match, 1]);
                break;
            case 'z':
            case 'v':
            case 'V':
                throw new RangeError(
                    'z/v/V` (timeZone) patterns are not supported, use `X/x/Z/O` instead'
                );
            case '\'':
                result.push(['literal', match.slice(1, -1).replace(/''/g, '\''), -1]);
                break;
            default:
                result.push(['literal', match, -1]);
        }
        return '';
    });
    return result;
}

export { ShorthandStyles, getSkeleton, parseDateTimeSkeleton };
