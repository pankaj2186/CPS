/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2022 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.

* Adobe permits you to use and modify this file solely in accordance with
* the terms of the Adobe license agreement accompanying it.
*************************************************************************/

import { ShorthandStyles, parseDateTimeSkeleton } from './SkeletonParser.js';

const twelveMonths = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(m => new Date(2000, m, 1));
function monthNames(locale, options) {
    return twelveMonths.map(month => {
        const parts = new Intl.DateTimeFormat(locale, options).formatToParts(month);
        const m = parts.find(p => p.type === 'month');
        return m && m.value;
    });
}
function digitChars(locale) {
    return new Intl.NumberFormat(locale, {style:'decimal', useGrouping:false})
        .format(9876543210)
        .split('')
        .reverse();
}
function calendarName(locale) {
    const parts = new Intl.DateTimeFormat(locale, {era:'short'}).formatToParts(new Date());
    const era = parts.find(p => p.type === 'era')?.value;
    return era === 'هـ' ? 'islamic' : 'gregory';
}
function getDayPeriod(language) {
    const morning = new Date(2000, 1, 1, 1, 1, 1);
    const afternoon = new Date(2000, 1, 1, 16, 1, 1);
    const df = new Intl.DateTimeFormat(language, {dateStyle: 'full', timeStyle: 'full'});
    const am = df.formatToParts(morning).find(p => p.type === 'dayPeriod');
    const pm = df.formatToParts(afternoon).find(p => p.type === 'dayPeriod');
    if (!am || !pm) return null;
    return {
        regex: `(${am.value}|${pm.value})`,
        fn: (period, obj) => obj.hour += (period === pm.value) ? 12 : 0
    };
}
function offsetMS(dateObj, timeZone) {
    let tzOffset;
    try {
        tzOffset = new Intl.DateTimeFormat('en-US', {timeZone, timeZoneName: 'longOffset'}).format(dateObj);
    } catch(e) {
        return offsetMSFallback(dateObj, timeZone);
    }
    const offset = /GMT([+\-−])?(\d{1,2}):?(\d{0,2})?/.exec(tzOffset);
    if (!offset) return 0;
    const [sign, hours, minutes] = offset.slice(1);
    const nHours = isNaN(parseInt(hours)) ? 0 : parseInt(hours);
    const nMinutes = isNaN(parseInt(minutes)) ? 0 : parseInt(minutes);
    const result = ((nHours  * 60) + nMinutes) * 60 * 1000;
    return sign === '-' ? - result : result;
}
function getTimezoneOffsetFrom(otherTimezone) {
    var date = new Date();
    function objFromStr(str) {
        var array = str.replace(":", " ").split(" ");
        return {
            day: parseInt(array[0]),
            hour: parseInt(array[1]),
            minute: parseInt(array[2])
        };
    }
    var str = date.toLocaleString('en-US', { timeZone: otherTimezone, day: 'numeric', hour: 'numeric', minute: 'numeric', hourCycle: 'h23' });
    var other = objFromStr(str);
    str = date.toLocaleString('en-US', { day: 'numeric', hour: 'numeric', minute: 'numeric', hourCycle: 'h23' });
    var myLocale = objFromStr(str);
    var otherOffset = (other.day * 24 * 60) + (other.hour * 60) + (other.minute);
    var myLocaleOffset = (myLocale.day * 24 * 60) + (myLocale.hour * 60) + (myLocale.minute);
    return otherOffset - myLocaleOffset - date.getTimezoneOffset();
}
function offsetMSFallback(dateObj, timezone) {
    const timezoneOffset = getTimezoneOffsetFrom(timezone);
    return timezoneOffset * 60 * 1000;
}
function adjustTimeZone(dateObj, timeZone) {
    if (dateObj === null) return null;
    let baseDate = dateObj.getTime() - dateObj.getTimezoneOffset() * 60 * 1000;
    const offset = offsetMS(dateObj, timeZone);
    offsetMSFallback(dateObj, timeZone);
    baseDate += - offset;
    return new Date(baseDate);
}
function datetimeToNumber(dateObj) {
    if (dateObj === null) return 0;
    return dateObj.getTime() / ( 1000 * 60 * 60 * 24 );
}
function numberToDatetime(num) {
    return new Date(Math.round(num * 1000 * 60 * 60 * 24));
}
function fixDigits(formattedParts, parsed) {
    ['hour', 'minute', 'second'].forEach(type => {
        const defn = formattedParts.find(f => f.type === type);
        if (!defn) return;
        const fmt = parsed.find(pair => pair[0] === type)[1];
        if (fmt === '2-digit' && defn.value.length === 1) defn.value = `0${defn.value}`;
        if (fmt === 'numeric' && defn.value.length === 2 && defn.value.charAt(0) === '0') defn.value = defn.value.slice(1);
    });
}
function fixYear(formattedParts, parsed) {
    const defn = formattedParts.find(f => f.type === 'year');
    if (!defn) return;
    const chars = parsed.find(pair => pair[0] === 'year')[2];
    while(defn.value.length < chars) {
        defn.value = `0${defn.value}`;
    }
}
function formatDateToParts(dateValue, language, skeleton, timeZone) {
    const mappings = key => ({
        hour12: 'dayPeriod',
        fractionalSecondDigits: 'fractionalSecond',
    })[key] || key;
    const allParameters = parseDateTimeSkeleton(skeleton, language);
    allParameters.push(['timeZone', timeZone]);
    const parsed = allParameters.filter(p => !p[0].startsWith('x-'));
    const nonStandard = allParameters.filter(p => p[0].startsWith('x-'));
    const options = Object.fromEntries(parsed);
    delete options.literal;
    const df = new Intl.DateTimeFormat(language, options);
    const formattedParts = df.formatToParts(dateValue);
    fixDigits(formattedParts, allParameters);
    fixYear(formattedParts, parsed);
    return parsed.reduce((result, cur) => {
        if (cur[0] === 'literal') result.push(cur);
        else {
            const v = formattedParts.find(p => p.type === mappings(cur[0]));
            if (v && v.type === 'timeZoneName') {
                const tz = nonStandard.find(p => p[0] === 'x-timeZoneName')[1];
                const category = tz[0];
                if (category === 'Z') {
                    if (tz.length < 4) {
                        v.value = v.value.replace(/(GMT|:)/g, '');
                        if (v.value === '') v.value = '+0000';
                    } else if (tz.length === 5) {
                        if (v.value === 'GMT') v.value = 'Z';
                        else v.value = v.value.replace(/GMT/, '');
                    }
                }
                if (category === 'X' || category === 'x') {
                    if (tz.length === 1) {
                        v.value = v.value.replace(/(GMT|:(00)?)/g, '');
                    }
                    if (tz.length === 2) {
                        v.value = v.value.replace(/(GMT|:)/g, '');
                    }
                    if (tz.length === 3) {
                        v.value = v.value.replace(/GMT/g, '');
                    }
                    if (category === 'X' && v.value === '') v.value = 'Z';
                } else if (tz === 'O') {
                    v.value = v.value.replace(/GMT/g, '').replace(/0(\d+):/, '$1:').replace(/:00/, '');
                    if (v.value === '') v.value = '+0';
                }
            }
            if (v) result.push([v.type, v.value]);
        }
        return result;
    }, []);
}
function formatDate(dateValue, language, skeleton, timeZone) {
    if (skeleton.startsWith('date|')) {
        skeleton = skeleton.split('|')[1];
    }
    if (ShorthandStyles.find(type => skeleton.includes(type))) {
        const options = {timeZone};
        const parts = skeleton.split(/\s/).filter(s => s.length);
        if (ShorthandStyles.indexOf(parts[0]) > -1) {
            options.dateStyle = parts[0];
        }
        if (parts.length > 1 && ShorthandStyles.indexOf(parts[1]) > -1) {
            options.timeStyle = parts[1];
        }
        return new Intl.DateTimeFormat(language, options).format(dateValue);
    }
    const parts = formatDateToParts(dateValue, language, skeleton, timeZone);
    return parts.map(p => p[1]).join('');
}
function parseDate(dateString, language, skeleton, timeZone, bUseUTC = false) {
    if (skeleton.startsWith('date|')) {
        skeleton = skeleton.split('|')[1];
    }
    const lookups = [];
    const regexParts = [];
    const calendar = calendarName(language);
    const digits = digitChars(language);
    const twoDigit = `([${digits[0]}-${digits[9]}]{1,2})`;
    const threeDigit = `([${digits[0]}-${digits[9]}]{1,3})`;
    const fourDigit = `([${digits[0]}-${digits[9]}]{1,4})`;
    let hourCycle = 'h12';
    let _bUseUTC = bUseUTC;
    let _setFullYear = false;
    const isSeparator = str => str.length === 1 &&  ':-/.'.includes(str);
    const monthNumber = str => getNumber(str) - 1;
    const getNumber = str => str.split('').reduce((total, digit) => (total * 10) + digits.indexOf(digit), 0);
    const yearNumber = templateDigits => str => {
        let year = getNumber(str);
        year = year < 100 && templateDigits === 2 ? year + 2000 : year;
        if (calendar === 'islamic') year = Math.ceil(year * 0.97 + 622);
        if (templateDigits > 2 && year < 100) {
            _setFullYear = true;
        }
        return year;
    };
    const monthLookup = list => month => list.indexOf(month);
    const parsed = parseDateTimeSkeleton(skeleton, language);
    const months = monthNames(language, Object.fromEntries(parsed));
    parsed.forEach(([option, value, len]) => {
        if (option === 'literal') {
            if (isSeparator(value)) regexParts.push(`[^${digits[0]}-${digits[9]}]`);
            else regexParts.push(value);
        } else if (option === 'month' && ['numeric', '2-digit'].includes(value)) {
            regexParts.push(twoDigit);
            lookups.push(['month', monthNumber]);
        } else if (option === 'month' && ['formatted', 'long', 'short', 'narrow'].includes(value)) {
            regexParts.push(`(${months.join('|')})`);
            lookups.push(['month', monthLookup(months)]);
        } else if (['day', 'minute', 'second'].includes(option)) {
            if (option === 'minute' || option === 'second') {
                _bUseUTC = false;
            }
            regexParts.push(twoDigit);
            lookups.push([option, getNumber]);
        } else if (option === 'fractionalSecondDigits') {
            _bUseUTC = false;
            regexParts.push(threeDigit);
            lookups.push([option, (v, obj) => obj.fractionalSecondDigits + getNumber(v)]);
        } else if (option === 'hour') {
            _bUseUTC = false;
            regexParts.push(twoDigit);
            lookups.push([option, (v, obj) => obj.hour + getNumber(v)]);
        } else if (option === 'year') {
            regexParts.push('numeric' === value ? fourDigit : twoDigit);
            lookups.push(['year', yearNumber(len)]);
        } else if (option === 'dayPeriod') {
            _bUseUTC = false;
            const dayPeriod = getDayPeriod(language);
            if (dayPeriod) {
                regexParts.push(dayPeriod.regex);
                lookups.push(['hour', dayPeriod.fn]);
            }
        } else if (option === 'hourCycle') {
            _bUseUTC = false;
            hourCycle = value;
        } else if (option === 'x-timeZoneName') {
            _bUseUTC = false;
            regexParts.push('(?:GMT|UTC|Z)?([+\\-−0-9]{0,3}:?[0-9]{0,2})');
            lookups.push([option, (v, obj) => {
                _bUseUTC = true;
                if (!v) return;
                const timeParts = v.replace(/−/, '-').match(/([+\-\d]{2,3}):?(\d{0,2})/);
                const hours = timeParts[1] * 1;
                obj.hour -= hours;
                const mins = timeParts.length > 2 ? timeParts[2] * 1 : 0;
                obj.minute -= (hours < 0) ? - mins : mins;
            }]);
        } else if (option !== 'timeZoneName') {
            _bUseUTC = false;
            regexParts.push('.+?');
        }
        return regexParts;
    }, []);
    const regex = new RegExp(regexParts.join(''));
    const match = dateString.match(regex);
    if (match === null) return dateString;
    const dateObj = {year: 1972, month: 0, day: 1, hour: 0, minute: 0, second: 0, fractionalSecondDigits: 0};
    match.slice(1).forEach((m, index) => {
        const [element, func] = lookups[index];
        dateObj[element] = func(m, dateObj);
    });
    if (hourCycle === 'h24' && dateObj.hour === 24) dateObj.hour = 0;
    if (hourCycle === 'h12' && dateObj.hour === 12) dateObj.hour = 0;
    if (_bUseUTC) {
        const utcDate = new Date(Date.UTC(
            dateObj.year,
            dateObj.month,
            dateObj.day,
            dateObj.hour,
            dateObj.minute,
            dateObj.second,
            dateObj.fractionalSecondDigits,
        ));
        if (_setFullYear) {
            utcDate.setUTCFullYear(dateObj.year);
        }
        return utcDate;
    }
    const jsDate = new Date(
        dateObj.year,
        dateObj.month,
        dateObj.day,
        dateObj.hour,
        dateObj.minute,
        dateObj.second,
        dateObj.fractionalSecondDigits,
    );
    if (_setFullYear) {
        jsDate.setFullYear(dateObj.year);
    }
    return timeZone == null ? jsDate : adjustTimeZone(jsDate, timeZone);
}
function parseDefaultDate(dateString, language, bUseUTC) {
    return parseDate(dateString, language, 'short', null, false);
}

export { adjustTimeZone, datetimeToNumber, formatDate, numberToDatetime, offsetMS, offsetMSFallback, parseDate, parseDefaultDate };
