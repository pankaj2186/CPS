var $kYtlh$reactariautils = require("@react-aria/utils");
var $kYtlh$reactariainteractions = require("@react-aria/interactions");
var $kYtlh$reactstatelyvirtualizer = require("@react-stately/virtualizer");
var $kYtlh$react = require("react");
var $kYtlh$reactdom = require("react-dom");
var $kYtlh$reactariai18n = require("@react-aria/i18n");
var $kYtlh$reactariafocus = require("@react-aria/focus");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useVirtualizer", () => $e1fb6f3669e1c329$export$dd6d526d88b5a137);
$parcel$export(module.exports, "Virtualizer", () => $e1fb6f3669e1c329$export$89be5a243e59c4b2);
$parcel$export(module.exports, "useVirtualizerItem", () => $7d70e069fceb2deb$export$1da781778207e0a2);
$parcel$export(module.exports, "VirtualizerItem", () => $d6a26279cc31826b$export$6796df8ba7398521);
$parcel$export(module.exports, "layoutInfoToStyle", () => $d6a26279cc31826b$export$1481e64fbe01b8b3);
$parcel$export(module.exports, "ScrollView", () => $00ca8c0b29e3e07c$export$5665e3d6be6adea);
$parcel$export(module.exports, "getRTLOffsetType", () => $efdd61e59e023a1d$export$faf7630257ad4304);
$parcel$export(module.exports, "getScrollLeft", () => $efdd61e59e023a1d$export$1389d168952b34b5);
$parcel$export(module.exports, "setScrollLeft", () => $efdd61e59e023a1d$export$ed5fd5ffe5ab0ac);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // @ts-ignore

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $efdd61e59e023a1d$var$cachedRTLResult = null;
function $efdd61e59e023a1d$export$faf7630257ad4304(recalculate = false) {
    if ($efdd61e59e023a1d$var$cachedRTLResult === null || recalculate) {
        const outerDiv = document.createElement("div");
        const outerStyle = outerDiv.style;
        outerStyle.width = "50px";
        outerStyle.height = "50px";
        outerStyle.overflow = "scroll";
        outerStyle.direction = "rtl";
        const innerDiv = document.createElement("div");
        const innerStyle = innerDiv.style;
        innerStyle.width = "100px";
        innerStyle.height = "100px";
        outerDiv.appendChild(innerDiv);
        document.body.appendChild(outerDiv);
        if (outerDiv.scrollLeft > 0) $efdd61e59e023a1d$var$cachedRTLResult = "positive-descending";
        else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) $efdd61e59e023a1d$var$cachedRTLResult = "negative";
            else $efdd61e59e023a1d$var$cachedRTLResult = "positive-ascending";
        }
        document.body.removeChild(outerDiv);
        return $efdd61e59e023a1d$var$cachedRTLResult;
    }
    return $efdd61e59e023a1d$var$cachedRTLResult;
}
function $efdd61e59e023a1d$export$1389d168952b34b5(node, direction) {
    let { scrollLeft: scrollLeft  } = node;
    // scrollLeft in rtl locales differs across browsers, so normalize.
    // See comment by getRTLOffsetType below for details.
    if (direction === "rtl") {
        let { scrollWidth: scrollWidth , clientWidth: clientWidth  } = node;
        switch($efdd61e59e023a1d$export$faf7630257ad4304()){
            case "negative":
                scrollLeft = -scrollLeft;
                break;
            case "positive-descending":
                scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
        }
    }
    return scrollLeft;
}
function $efdd61e59e023a1d$export$ed5fd5ffe5ab0ac(node, direction, scrollLeft) {
    if (direction === "rtl") switch($efdd61e59e023a1d$export$faf7630257ad4304()){
        case "negative":
            scrollLeft = -scrollLeft;
            break;
        case "positive-ascending":
            break;
        default:
            {
                const { clientWidth: clientWidth , scrollWidth: scrollWidth  } = node;
                scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
            }
    }
    node.scrollLeft = scrollLeft;
}







function $00ca8c0b29e3e07c$var$ScrollView(props, ref) {
    let { contentSize: contentSize , onVisibleRectChange: onVisibleRectChange , children: children , innerStyle: innerStyle , sizeToFit: sizeToFit , onScrollStart: onScrollStart , onScrollEnd: onScrollEnd , scrollDirection: scrollDirection = "both" , ...otherProps } = props;
    let defaultRef = (0, $kYtlh$react.useRef)();
    ref = ref || defaultRef;
    let state = (0, $kYtlh$react.useRef)({
        scrollTop: 0,
        scrollLeft: 0,
        scrollEndTime: 0,
        scrollTimeout: null,
        width: 0,
        height: 0,
        isScrolling: false
    }).current;
    let { direction: direction  } = (0, $kYtlh$reactariai18n.useLocale)();
    let [isScrolling, setScrolling] = (0, $kYtlh$react.useState)(false);
    let onScroll = (0, $kYtlh$react.useCallback)((e)=>{
        if (e.target !== e.currentTarget) return;
        if (props.onScroll) props.onScroll(e);
        (0, $kYtlh$reactdom.flushSync)(()=>{
            let scrollTop = e.currentTarget.scrollTop;
            let scrollLeft = (0, $efdd61e59e023a1d$export$1389d168952b34b5)(e.currentTarget, direction);
            // Prevent rubber band scrolling from shaking when scrolling out of bounds
            state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));
            state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));
            onVisibleRectChange(new (0, $kYtlh$reactstatelyvirtualizer.Rect)(state.scrollLeft, state.scrollTop, state.width, state.height));
            if (!state.isScrolling) {
                state.isScrolling = true;
                setScrolling(true);
                if (onScrollStart) onScrollStart();
            }
            // So we don't constantly call clearTimeout and setTimeout,
            // keep track of the current timeout time and only reschedule
            // the timer when it is getting close.
            let now = Date.now();
            if (state.scrollEndTime <= now + 50) {
                state.scrollEndTime = now + 300;
                clearTimeout(state.scrollTimeout);
                state.scrollTimeout = setTimeout(()=>{
                    state.isScrolling = false;
                    setScrolling(false);
                    state.scrollTimeout = null;
                    if (onScrollEnd) onScrollEnd();
                }, 300);
            }
        });
    }, [
        props,
        direction,
        state,
        contentSize,
        onVisibleRectChange,
        onScrollStart,
        onScrollEnd
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $kYtlh$react.useEffect)(()=>{
        return ()=>{
            clearTimeout(state.scrollTimeout);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    let updateSize = (0, $kYtlh$react.useCallback)(()=>{
        let dom = ref.current;
        if (!dom) return;
        let w = dom.clientWidth;
        let h = dom.clientHeight;
        if (sizeToFit && contentSize.width > 0 && contentSize.height > 0) {
            if (sizeToFit === "width") w = Math.min(w, contentSize.width);
            else if (sizeToFit === "height") h = Math.min(h, contentSize.height);
        }
        if (state.width !== w || state.height !== h) {
            state.width = w;
            state.height = h;
            onVisibleRectChange(new (0, $kYtlh$reactstatelyvirtualizer.Rect)(state.scrollLeft, state.scrollTop, w, h));
        }
    }, [
        onVisibleRectChange,
        ref,
        state,
        sizeToFit,
        contentSize
    ]);
    (0, $kYtlh$reactariautils.useLayoutEffect)(()=>{
        updateSize();
    }, [
        updateSize
    ]);
    (0, $kYtlh$reactariautils.useResizeObserver)({
        ref: ref,
        onResize: updateSize
    });
    let style = {
        // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.
        padding: 0,
        ...otherProps.style
    };
    if (scrollDirection === "horizontal") {
        style.overflowX = "auto";
        style.overflowY = "hidden";
    } else if (scrollDirection === "vertical") {
        style.overflowY = "auto";
        style.overflowX = "hidden";
    } else style.overflow = "auto";
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement("div", {
        ...otherProps,
        style: style,
        ref: ref,
        onScroll: onScroll
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement("div", {
        role: "presentation",
        style: {
            width: contentSize.width,
            height: contentSize.height,
            pointerEvents: isScrolling ? "none" : "auto",
            position: "relative",
            ...innerStyle
        }
    }, children));
}
const $00ca8c0b29e3e07c$export$5665e3d6be6adea = /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).forwardRef($00ca8c0b29e3e07c$var$ScrollView);


/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $d9e30fd7b96073c4$export$eac1895992b9f3d6({ isEmpty: isEmpty , hasRenderedAnything: hasRenderedAnything  }, ref) {
    let [hasTabbableChild, setHasTabbableChild] = (0, $kYtlh$react.useState)(false);
    (0, $kYtlh$react.useEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && isEmpty && hasRenderedAnything) {
            // Detect if there are any tabbable elements and update the tabIndex accordingly.
            let walker = (0, $kYtlh$reactariafocus.getFocusableTreeWalker)(ref.current, {
                tabbable: true
            });
            setHasTabbableChild(!!walker.nextNode());
        }
    }, [
        ref,
        isEmpty,
        hasRenderedAnything
    ]);
    return hasTabbableChild;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $7d70e069fceb2deb$export$1da781778207e0a2(options) {
    let { reusableView: { layoutInfo: layoutInfo , virtualizer: virtualizer  } , ref: ref  } = options;
    let updateSize = (0, $kYtlh$react.useCallback)(()=>{
        let size = $7d70e069fceb2deb$var$getSize(ref.current);
        virtualizer.updateItemSize(layoutInfo.key, size);
    }, [
        virtualizer,
        layoutInfo.key,
        ref
    ]);
    (0, $kYtlh$reactariautils.useLayoutEffect)(()=>{
        if (layoutInfo.estimatedSize) updateSize();
    });
    return {
        updateSize: updateSize
    };
}
function $7d70e069fceb2deb$var$getSize(node) {
    // Reset height before measuring so we get the intrinsic size
    let height = node.style.height;
    node.style.height = "";
    let size = new (0, $kYtlh$reactstatelyvirtualizer.Size)(node.scrollWidth, node.scrollHeight);
    node.style.height = height;
    return size;
}


function $d6a26279cc31826b$export$6796df8ba7398521(props) {
    let { className: className , reusableView: reusableView , parent: parent  } = props;
    let { direction: direction  } = (0, $kYtlh$reactariai18n.useLocale)();
    let ref = (0, $kYtlh$react.useRef)();
    (0, $7d70e069fceb2deb$export$1da781778207e0a2)({
        reusableView: reusableView,
        ref: ref
    });
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement("div", {
        role: "presentation",
        ref: ref,
        className: className,
        style: $d6a26279cc31826b$export$1481e64fbe01b8b3(reusableView.layoutInfo, direction, parent && parent.layoutInfo)
    }, reusableView.rendered);
}
let $d6a26279cc31826b$var$cache = new WeakMap();
function $d6a26279cc31826b$export$1481e64fbe01b8b3(layoutInfo, dir, parent) {
    let xProperty = dir === "rtl" ? "right" : "left";
    let cached = $d6a26279cc31826b$var$cache.get(layoutInfo);
    if (cached && cached[xProperty] != null) {
        if (!parent) return cached;
        // Invalidate if the parent position changed.
        let top = layoutInfo.rect.y - parent.rect.y;
        let x = layoutInfo.rect.x - parent.rect.x;
        if (cached.top === top && cached[xProperty] === x) return cached;
    }
    let style = {
        position: layoutInfo.isSticky ? "sticky" : "absolute",
        overflow: layoutInfo.allowOverflow ? "visible" : "hidden",
        top: layoutInfo.rect.y - (parent ? parent.rect.y : 0),
        [xProperty]: layoutInfo.rect.x - (parent ? parent.rect.x : 0),
        transition: "all",
        WebkitTransition: "all",
        WebkitTransitionDuration: "inherit",
        transitionDuration: "inherit",
        width: layoutInfo.rect.width,
        height: layoutInfo.rect.height,
        opacity: layoutInfo.opacity,
        zIndex: layoutInfo.zIndex,
        transform: layoutInfo.transform,
        contain: "size layout style"
    };
    $d6a26279cc31826b$var$cache.set(layoutInfo, style);
    return style;
}


function $e1fb6f3669e1c329$var$Virtualizer(props, ref) {
    let { children: renderView , renderWrapper: renderWrapper , layout: layout , collection: collection , sizeToFit: sizeToFit , scrollDirection: scrollDirection , transitionDuration: transitionDuration , isLoading: isLoading , onLoadMore: onLoadMore , focusedKey: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusedKey , shouldUseVirtualFocus: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldUseVirtualFocus , scrollToItem: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    scrollToItem , ...otherProps } = props;
    let fallbackRef = (0, $kYtlh$react.useRef)();
    ref = ref || fallbackRef;
    let state = (0, $kYtlh$reactstatelyvirtualizer.useVirtualizerState)({
        transitionDuration: transitionDuration,
        layout: layout,
        collection: collection,
        renderView: renderView,
        renderWrapper: renderWrapper || $e1fb6f3669e1c329$var$defaultRenderWrapper,
        onVisibleRectChange (rect) {
            ref.current.scrollLeft = rect.x;
            ref.current.scrollTop = rect.y;
        }
    });
    let { virtualizerProps: virtualizerProps  } = $e1fb6f3669e1c329$export$dd6d526d88b5a137(props, state, ref);
    // Handle scrolling, and call onLoadMore when nearing the bottom.
    let onVisibleRectChange = (0, $kYtlh$react.useCallback)((rect)=>{
        state.setVisibleRect(rect);
        if (!isLoading && onLoadMore) {
            let scrollOffset = state.virtualizer.contentSize.height - rect.height * 2;
            if (rect.y > scrollOffset) onLoadMore();
        }
    }, [
        isLoading,
        onLoadMore,
        state
    ]);
    (0, $kYtlh$reactariautils.useLayoutEffect)(()=>{
        if (!isLoading && onLoadMore && !state.isAnimating) {
            if (state.contentSize.height > 0 && state.contentSize.height <= state.virtualizer.visibleRect.height) onLoadMore();
        }
    }, [
        state.contentSize,
        state.isAnimating,
        state.virtualizer,
        onLoadMore,
        isLoading
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement((0, $00ca8c0b29e3e07c$export$5665e3d6be6adea), {
        ...(0, $kYtlh$reactariautils.mergeProps)(otherProps, virtualizerProps),
        ref: ref,
        innerStyle: state.isAnimating ? {
            transition: `none ${state.virtualizer.transitionDuration}ms`
        } : undefined,
        contentSize: state.contentSize,
        onVisibleRectChange: onVisibleRectChange,
        onScrollStart: state.startScrolling,
        onScrollEnd: state.endScrolling,
        sizeToFit: sizeToFit,
        scrollDirection: scrollDirection
    }, state.visibleViews);
}
function $e1fb6f3669e1c329$export$dd6d526d88b5a137(props, state, ref) {
    let { focusedKey: focusedKey , scrollToItem: scrollToItem , shouldUseVirtualFocus: shouldUseVirtualFocus  } = props;
    let { virtualizer: virtualizer  } = state;
    // Scroll to the focusedKey when it changes. Actually focusing the focusedKey
    // is up to the implementation using Virtualizer since we don't have refs
    // to all of the item DOM nodes.
    let lastFocusedKey = (0, $kYtlh$react.useRef)(null);
    let isFocusWithin = (0, $kYtlh$react.useRef)(false);
    (0, $kYtlh$react.useEffect)(()=>{
        if (virtualizer.visibleRect.height === 0) return;
        // Only scroll the focusedKey into view if the modality is not pointer to avoid jumps in position when clicking/pressing tall items.
        // Exception made if focus isn't within the virtualizer (e.g. opening a picker via click should scroll the selected item into view)
        let modality = (0, $kYtlh$reactariainteractions.getInteractionModality)();
        if (focusedKey !== lastFocusedKey.current && (modality !== "pointer" || !isFocusWithin.current)) {
            if (scrollToItem) scrollToItem(focusedKey);
            else virtualizer.scrollToItem(focusedKey, {
                duration: 0
            });
        }
        lastFocusedKey.current = focusedKey;
    }, [
        focusedKey,
        virtualizer.visibleRect.height,
        virtualizer,
        lastFocusedKey,
        scrollToItem
    ]);
    // Persist the focusedKey and prevent it from being removed from the DOM when scrolled out of view.
    virtualizer.persistedKeys = (0, $kYtlh$react.useMemo)(()=>focusedKey ? new Set([
            focusedKey
        ]) : new Set(), [
        focusedKey
    ]);
    let onFocus = (0, $kYtlh$react.useCallback)((e)=>{
        // If the focused item is scrolled out of view and is not in the DOM, the collection
        // will have tabIndex={0}. When tabbing in from outside, scroll the focused item into view.
        // Ignore focus events that bubble through portals (e.g. focus that happens on a menu popover child of the virtualizer)
        // Don't scroll focused key into view if modality is pointer to prevent sudden jump in position (e.g. CardView).
        let modality = (0, $kYtlh$reactariainteractions.getInteractionModality)();
        if (!isFocusWithin.current && ref.current.contains(e.target) && modality !== "pointer") {
            if (scrollToItem) scrollToItem(focusedKey);
            else virtualizer.scrollToItem(focusedKey, {
                duration: 0
            });
        }
        isFocusWithin.current = e.target !== ref.current;
    }, [
        ref,
        virtualizer,
        focusedKey,
        scrollToItem
    ]);
    let onBlur = (0, $kYtlh$react.useCallback)((e)=>{
        isFocusWithin.current = ref.current.contains(e.relatedTarget);
    }, [
        ref
    ]);
    // When the focused item is scrolled out of view and is removed from the DOM,
    // move focus to the collection view as a whole if focus was within before.
    let focusedView = virtualizer.getView(focusedKey);
    (0, $kYtlh$react.useEffect)(()=>{
        if (focusedKey && !focusedView && isFocusWithin.current && document.activeElement !== ref.current) (0, $kYtlh$reactariautils.focusWithoutScrolling)(ref.current);
    });
    let hasTabbableChild = (0, $d9e30fd7b96073c4$export$eac1895992b9f3d6)({
        isEmpty: virtualizer.collection.size === 0,
        hasRenderedAnything: virtualizer.contentSize.height > 0 || virtualizer.contentSize.width > 0
    }, ref);
    // Set tabIndex to -1 if the focused view is in the DOM, otherwise 0 so that the collection
    // itself is tabbable. When the collection receives focus, we scroll the focused item back into
    // view, which will allow it to be properly focused. If using virtual focus, don't set a
    // tabIndex at all so that VoiceOver on iOS 14 doesn't try to move real DOM focus to the element anyway.
    let tabIndex;
    if (!shouldUseVirtualFocus) // When there is no focusedView the default tabIndex is 0. We include logic for empty collections too.
    // For collections that are empty, but have a link in the empty children we want to skip focusing this
    // and let focus move to the link similar to link moving to children.
    tabIndex = focusedView || hasTabbableChild ? -1 : 0;
    return {
        virtualizerProps: {
            tabIndex: tabIndex,
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}
// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref
const $e1fb6f3669e1c329$export$89be5a243e59c4b2 = /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).forwardRef($e1fb6f3669e1c329$var$Virtualizer);
function $e1fb6f3669e1c329$var$defaultRenderWrapper(parent, reusableView) {
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement((0, $d6a26279cc31826b$export$6796df8ba7398521), {
        key: reusableView.key,
        reusableView: reusableView,
        parent: parent
    });
}








//# sourceMappingURL=main.js.map
